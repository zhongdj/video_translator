
==================================================
文件路径: .g8\form\app\controllers\$model__Camel$Controller.scala
==================================================

package controllers

import javax.inject._
import play.api.mvc._

import play.api.data._
import play.api.data.Forms._

case class $model;format="Camel"$Data(name: String, age: Int)
object $model;format="Camel"$Data {
  def unapply(data: $model;format="Camel"$Data): Option[(String, Int)] = Some((data.name, data.age))
}

// NOTE: Add the following to conf/routes to enable compilation of this class:
/*
GET     /$model;format="camel"$        controllers.$model;format="Camel"$Controller.$model;format="camel"$Get()
POST    /$model;format="camel"$        controllers.$model;format="Camel"$Controller.$model;format="camel"$Post()
*/

/**
 * $model;format="Camel"$ form controller for Play Scala
 */
class $model;format="Camel"$Controller @Inject()(mcc: MessagesControllerComponents) extends MessagesAbstractController(mcc) {

  val $model;format="camel"$Form = Form(
    mapping(
      "name" -> text,
      "age" -> number
    )($model;format="Camel"$Data.apply)($model;format="Camel"$Data.unapply)
  )

  def $model;format="camel"$Get() = Action { implicit request: MessagesRequest[AnyContent] =>
    Ok(views.html.$model;format="camel"$.form($model;format="camel"$Form))
  }

  def $model;format="camel"$Post() = Action { implicit request: MessagesRequest[AnyContent] =>
    $model;format="camel"$Form.bindFromRequest().fold(
      formWithErrors => {
        // binding failure, you retrieve the form containing errors:
        BadRequest(views.html.$model;format="camel"$.form(formWithErrors))
      },
      $model;format="camel"$Data => {
        /* binding success, you get the actual value. */       
        /* flashing uses a short lived cookie */ 
        Redirect(routes.$model;format="Camel"$Controller.$model;format="camel"$Get()).flashing("success" -> ("Successful " + $model;format="camel"$Data.toString))
      }
    )
  }
}


==================================================
文件路径: .g8\form\test\controllers\$model__Camel$ControllerSpec.scala
==================================================

package controllers

import play.api.mvc._
import play.api.i18n._
import org.scalatestplus.play._
import org.scalatestplus.play.guice.GuiceOneAppPerTest
import play.api.http.FileMimeTypes
import play.api.test._
import play.api.test.Helpers._
import play.api.test.CSRFTokenHelper._

import scala.concurrent.ExecutionContext

/**
 * $model;format="Camel"$ form controller specs
 */
class $model;format="Camel"$ControllerSpec extends PlaySpec with GuiceOneAppPerTest with Injecting {

  // Provide stubs for components based off Helpers.stubControllerComponents()
  class StubComponents(cc:ControllerComponents = stubControllerComponents()) extends MessagesControllerComponents {
    override val parsers: PlayBodyParsers = cc.parsers
    override val messagesApi: MessagesApi = cc.messagesApi
    override val langs: Langs = cc.langs
    override val fileMimeTypes: FileMimeTypes = cc.fileMimeTypes
    override val executionContext: ExecutionContext = cc.executionContext
    override val actionBuilder: ActionBuilder[Request, AnyContent] = cc.actionBuilder
    override val messagesActionBuilder: MessagesActionBuilder = new DefaultMessagesActionBuilderImpl(parsers.default, messagesApi)(executionContext)
  }

  "$model;format="Camel"$Controller GET" should {

    "render the index page from a new instance of controller" in {
      val controller = new $model;format="Camel"$Controller(new StubComponents())
      val request = FakeRequest().withCSRFToken
      val home = controller.$model;format="camel"$Get().apply(request)

      status(home) mustBe OK
      contentType(home) mustBe Some("text/html")
    }

    "render the index page from the application" in {
      val controller = inject[$model;format="Camel"$Controller]
      val request = FakeRequest().withCSRFToken
      val home = controller.$model;format="camel"$Get().apply(request)

      status(home) mustBe OK
      contentType(home) mustBe Some("text/html")
    }

    "render the index page from the router" in {
      val request = CSRFTokenHelper.addCSRFToken(FakeRequest(GET, "/$model;format="camel"$"))
      val home = route(app, request).get

      status(home) mustBe OK
      contentType(home) mustBe Some("text/html")
    }
  }

  "$model;format="Camel"$Controller POST" should {
    "process form" in {
      val request = {
        FakeRequest(POST, "/$model;format="camel"$")
          .withFormUrlEncodedBody("name" -> "play", "age" -> "4")
      }
      val home = route(app, request).get

      status(home) mustBe SEE_OTHER
    }
  }

}


==================================================
文件路径: app\controllers\HomeController.scala
==================================================

package controllers

import akka.actor.typed.Scheduler
import akka.actor.typed.javadsl.Adapter
import akka.actor.typed.scaladsl.adapter.ClassicActorSystemOps
import akka.actor.{ActorSystem, typed}
import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import net.imadz.application.aggregates.CreditBalanceAggregate.CreditBalanceConfirmation
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.application.projection.ScalikeJdbcSetup
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.application.queries.{GetBalanceQuery, GetRecent12MonthsIncomeAndExpenseReport}
import net.imadz.application.services.transactor.MoneyTransferTransactionRepository
import net.imadz.application.services.{CreateCreditBalanceService, DepositService, MoneyTransferService, WithdrawService}
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.common.Id
import net.imadz.domain.values.Money
import net.imadz.infra.saga.repository.TransactionCoordinatorRepository
import net.imadz.infrastructure.bootstrap._
import play.api.libs.json._
import play.api.mvc._

import java.util.Currency
import javax.inject._
import scala.concurrent.ExecutionContext

/**
 * This controller creates an `Action` to handle HTTP requests to the
 * application's home page.
 */
@Singleton
class HomeController @Inject()(
                                val system: ActorSystem,
                                val sharding: ClusterSharding,
                                val monthlyQuery: GetRecent12MonthsIncomeAndExpenseReport,
                                val monthlyRepository: MonthlyIncomeAndExpenseSummaryRepository,
                                val creditBalanceRepository: CreditBalanceRepository,
                                val transactionRepository: MoneyTransferTransactionRepository,
                                val coordinatorRepository: TransactionCoordinatorRepository,
                                val getBalanceQuery: GetBalanceQuery,
                                val createService: CreateCreditBalanceService,
                                val depositService: DepositService,
                                val withdrawService: WithdrawService,
                                val controllerComponents: ControllerComponents
                              )(implicit executionContext: ExecutionContext) extends BaseController
  with MonthlyIncomeAndExpenseBootstrap
  with CreditBalanceBootstrap
//  with TransactionBootstrap
  with SagaTransactionCoordinatorBootstrap {
  val typedSystem: typed.ActorSystem[Nothing] = system.toTyped
  ScalikeJdbcSetup.init(Adapter.toTyped(system))

  implicit val scheduler: Scheduler = typedSystem.scheduler
  val moneyTransferService: MoneyTransferService = new MoneyTransferService(system.toTyped, transactionRepository)

  initMonthlySummaryProjection(Adapter.toTyped(system), sharding, monthlyRepository)
  initCreditBalanceAggregate(sharding)
  initSagaTransactionCoordinatorAggregate(sharding, creditBalanceRepository)
//  initTransactionAggregate(sharding, coordinatorRepository, creditBalanceRepository)

  /**
   * Create an Action to render an HTML page.
   *
   * The configuration in the `routes` file means that this method
   * will be called when the application receives a `GET` request with
   * a path of `/`.
   */
  def index() = Action { implicit request: Request[AnyContent] =>
    Ok(views.html.index())
  }
  implicit val iMadzErrorFormat: OFormat[iMadzError] = Json.format[iMadzError]
  implicit val moneyFormat: Format[Money] = new Format[Money] {
    def writes(o: Money): JsValue = Json.obj(
      "amount" -> o.amount,
      "currency" -> o.currency.getCurrencyCode
    )
    def reads(json: JsValue): JsResult[Money] = for {
      amount <- (json \ "amount").validate[BigDecimal]
      currencyCode <- (json \ "currency").validate[String]
    } yield Money(amount, Currency.getInstance(currencyCode))
  }
  implicit val idFormat: Format[Id] = new Format[Id] {
    override def writes(o: Id): JsValue = JsString(o.toString)

    override def reads(json: JsValue): JsResult[Id] = JsSuccess(Id.of(json.toString()))
  }


  implicit val eitherErrorIdFormat: Format[Either[iMadzError, Id]] = new Format[Either[iMadzError, Id]] {
    def reads(json: JsValue): JsResult[Either[iMadzError, Id]] = {
      (json \ "error").toOption match {
        case Some(errorJson) => iMadzErrorFormat.reads(errorJson).map(Left(_))
        case None => (json \ "id").toOption match {
          case Some(idJson) => idFormat.reads(idJson).map(Right(_))
          case None => JsError("Invalid format: neither error nor id found")
        }
      }
    }

    def writes(either: Either[iMadzError, Id]): JsValue = either match {
      case Left(error) => Json.obj("error" -> iMadzErrorFormat.writes(error))
      case Right(id) => Json.obj("id" -> idFormat.writes(id))
    }
  }
  def getBalance(userId: String): Action[AnyContent] = Action.async { implicit request =>
    getBalanceQuery.fetchBalanceByUserId(Id.of(userId)).map { balance =>
      Ok(Json.toJson(balance)) // Assuming `balance` has a proper `toString` method
    }.recover {
      case ex: Exception => InternalServerError(ex.getMessage)
    }
  }

  implicit val creditBalanceConfirmationFormat: OFormat[CreditBalanceConfirmation] = Json.format[CreditBalanceConfirmation]

  def deposit(userId: String, amount: Double): Action[AnyContent] = Action.async { implicit request =>
    depositService.requestDeposit(Id.of(userId), Money(amount, Currency.getInstance("CNY"))).map { confirmation =>
      Ok(Json.toJson(confirmation))
    }.recover {
      case ex: Exception => InternalServerError(ex.getMessage)
    }
  }

  def withdraw(userId: String, amount: Double): Action[AnyContent] = Action.async { implicit request =>
    withdrawService.requestWithdraw(Id.of(userId), Money(amount, Currency.getInstance("CNY"))).map { confirmation =>
      Ok(Json.toJson(confirmation)) // Assuming `balance` has a proper `toString` method
    }.recover {
      case ex: Exception => InternalServerError(ex.getMessage)
    }
  }

  implicit val idWriter: Writes[Id] = new Writes[Id] {
    override def writes(o: Id): JsValue = JsString(o.toString)
  }
  def transfer(fromUserId: String, toUserId: String, amount: Double): Action[AnyContent] = Action.async { implicit request =>
    moneyTransferService.transfer(Id.of(fromUserId), Id.of(toUserId), Money(amount, Currency.getInstance("CNY"))).map { confirmation =>
      Ok(Json.toJson(confirmation))
    }.recover {
      case ex: Exception => InternalServerError(ex.getMessage)
    }
  }
}



==================================================
文件路径: app\controllers\filter\LoggingFilter.scala
==================================================

package controllers.filter

import akka.stream.Materializer
import play.api.Logging
import play.api.mvc._

import javax.inject.Inject
import scala.concurrent.{ExecutionContext, Future}

class LoggingFilter @Inject()(implicit val mat: Materializer, ec: ExecutionContext) extends Filter with Logging {
  def apply(nextFilter: RequestHeader => Future[Result])(requestHeader: RequestHeader): Future[Result] = {
    val startTime = System.currentTimeMillis

    nextFilter(requestHeader).map { result =>
      val endTime     = System.currentTimeMillis
      val requestTime = endTime - startTime

      logger.info(
        s"${requestHeader.method} ${requestHeader.uri} took ${requestTime}ms and returned ${result.header.status}"
      )

      result.withHeaders("Request-Time" -> requestTime.toString)
    }
  }
}

==================================================
文件路径: app\net\imadz\application\aggregates\CreditBalanceAggregate.scala
==================================================

package net.imadz.application.aggregates

import akka.actor.typed.ActorRef
import akka.cluster.sharding.typed.scaladsl.EntityTypeKey
import akka.persistence.typed.scaladsl.Effect
import net.imadz.application.aggregates.behaviors.CreditBalanceBehaviors
import net.imadz.common.CborSerializable
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.domain.entities.CreditBalanceEntity.{CreditBalanceEvent, CreditBalanceState}
import net.imadz.domain.values.Money

object CreditBalanceAggregate {

  // Commands Section
  sealed trait CreditBalanceCommand extends CborSerializable
  case class AddInitial(initial: Money, replyTo: ActorRef[CreditBalanceConfirmation]) extends CreditBalanceCommand
  case class Deposit(change: Money, replyTo: ActorRef[CreditBalanceConfirmation]) extends CreditBalanceCommand
  case class Withdraw(change: Money, replyTo: ActorRef[CreditBalanceConfirmation]) extends CreditBalanceCommand
  case class GetBalance(replyTo: ActorRef[CreditBalanceConfirmation]) extends CreditBalanceCommand

  case class ReserveFunds(transferId: Id, amount: Money, replyTo: ActorRef[FundsReservationConfirmation]) extends CreditBalanceCommand
  case class DeductFunds(transferId: Id, replyTo: ActorRef[FundsDeductionConfirmation]) extends CreditBalanceCommand
  case class ReleaseReservedFunds(transferId: Id, replyTo: ActorRef[FundsReleaseConfirmation]) extends CreditBalanceCommand

  case class RecordIncomingCredits(transferId: Id, amount: Money, replyTo: ActorRef[RecordIncomingCreditsConfirmation]) extends CreditBalanceCommand
  case class CommitIncomingCredits(transferId: Id, replyTo: ActorRef[CommitIncomingCreditsConfirmation]) extends CreditBalanceCommand
  case class CancelIncomingCredit(transferId: Id, replyTo: ActorRef[CancelIncomingCreditConfirmation]) extends CreditBalanceCommand



  // Command Replies
  case class CreditBalanceConfirmation(error: Option[iMadzError], balances: List[Money]) extends CborSerializable
  case class FundsReservationConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class FundsDeductionConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class FundsReleaseConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class RecordIncomingCreditsConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class CommitIncomingCreditsConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class CancelIncomingCreditConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable

  case class TransferConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable

  // Command Handler
  type CreditBalanceCommandHandler = (CreditBalanceState, CreditBalanceCommand) => Effect[CreditBalanceEvent, CreditBalanceState]

  def commandHandler: CreditBalanceCommandHandler = CreditBalanceBehaviors.apply

  // Akka
  val CreditBalanceEntityTypeKey: EntityTypeKey[CreditBalanceCommand] = EntityTypeKey("CreditBalance")
  val tags: Vector[String] = Vector.tabulate(5)(i => s"credit-balance-$i")
}


==================================================
文件路径: app\net\imadz\application\aggregates\behaviors\CreditBalanceBehaviors.scala
==================================================

package net.imadz.application.aggregates.behaviors

import akka.persistence.typed.scaladsl.Effect
import net.imadz.application.aggregates.CreditBalanceAggregate._
import net.imadz.common.CommonTypes.iMadzError
import net.imadz.common.application.CommandHandlerReplyingBehavior.runReplyingPolicy
import net.imadz.domain.entities.CreditBalanceEntity._
import net.imadz.domain.policy.{AddInitialOnlyOncePolicy, DepositPolicy, WithdrawPolicy}
import net.imadz.domain.services.TransferDomainService
import net.imadz.domain.values.Money

object CreditBalanceBehaviors {

  def apply: CreditBalanceCommandHandler = (state, command) =>
    directBehaviors(state)
      .orElse(reserveBehaviors(state))
      .orElse(incomingCreditBehaviors(state))
      .apply(command)


  private def directBehaviors(state: CreditBalanceState): PartialFunction[CreditBalanceCommand, Effect[CreditBalanceEvent, CreditBalanceState]] = {
    case AddInitial(initial, replyTo) =>
      runReplyingPolicy(AddInitialOnlyOncePolicy)(state, initial)
        .replyWith(replyTo)(mkError, mkLatestBalance)
    case Withdraw(change, replyTo) =>
      runReplyingPolicy(WithdrawPolicy)(state, change)
        .replyWith(replyTo)(mkError, mkLatestBalance)
    case Deposit(change, replyTo) =>
      runReplyingPolicy(DepositPolicy)(state, change)
        .replyWith(replyTo)(mkError, mkLatestBalance)
    case GetBalance(replyTo) =>
      Effect.reply(replyTo)(mkLatestBalance(None)(state))

  }

  private def reserveBehaviors(state: CreditBalanceState): PartialFunction[CreditBalanceCommand, Effect[CreditBalanceEvent, CreditBalanceState]] = {
    case ReserveFunds(transferId, amount, replyTo) =>
      val currentBalance = state.accountBalance.getOrElse(amount.currency.getCurrencyCode, Money(BigDecimal(0), amount.currency))
      TransferDomainService.validateTransfer(transferId, state.reservedAmount, currentBalance, amount) match {
        case Right(_) =>
          Effect.persist(FundsReserved(transferId, amount))
            .thenReply(replyTo)(_ => FundsReservationConfirmation(transferId, None))
        case Left(iMadzError("60008", _)) =>
          Effect.reply(replyTo)(FundsReservationConfirmation(transferId, None))
        case Left(error) =>
          Effect.reply(replyTo)(FundsReservationConfirmation(transferId, Some(error)))
      }
    case DeductFunds(transferId, replyTo) =>
      state.reservedAmount.get(transferId) match {
        case Some(reservedAmount) =>
          Effect.persist(FundsDeducted(transferId, reservedAmount))
            .thenReply(replyTo)(_ => FundsDeductionConfirmation(transferId, None))
        case None =>
          Effect.reply(replyTo)(FundsDeductionConfirmation(transferId, Some(iMadzError("60006", "No reserved funds found for this transfer"))))
      }
    case ReleaseReservedFunds(transferId, replyTo) =>
      state.reservedAmount.get(transferId) match {
        case Some(reservedAmount) =>
          Effect.persist(ReservationReleased(transferId, reservedAmount))
            .thenReply(replyTo)(_ => FundsReleaseConfirmation(transferId, None))
        case None =>
          Effect.reply(replyTo)(FundsReleaseConfirmation(transferId, Some(iMadzError("60006", "No reserved funds found for this transfer"))))
      }
  }

  private def incomingCreditBehaviors(state: CreditBalanceState): PartialFunction[CreditBalanceCommand, Effect[CreditBalanceEvent, CreditBalanceState]] = {

    case RecordIncomingCredits(transferId, amount, replyTo) =>
      state.incomingCredits.get(transferId) match {
        case Some(_) =>
          Effect
            .reply(replyTo)(RecordIncomingCreditsConfirmation(transferId = transferId, error = Some(iMadzError("60007", "incoming credits already registered"))))
        case None =>
          Effect
            .persist(IncomingCreditsRecorded(transferId, amount))
            .thenReply(replyTo)(_ => RecordIncomingCreditsConfirmation(transferId, None))
      }
    case CommitIncomingCredits(transferId, replyTo) =>
      state.incomingCredits.get(transferId) match {
        case Some(_) =>
          Effect
            .persist(IncomingCreditsCommited(transferId))
            .thenReply(replyTo)(_ => CommitIncomingCreditsConfirmation(transferId, None))
        case None =>
          Effect.reply(replyTo)(CommitIncomingCreditsConfirmation(transferId, Some(iMadzError("60008", "incoming credits cannot be found or already be committed before"))))
      }
    case CancelIncomingCredit(transferId, replyTo) =>
      state.incomingCredits.get(transferId) match {
        case Some(_) =>
          Effect.persist(IncomingCreditsCanceled(transferId))
            .thenReply(replyTo)(_ => CancelIncomingCreditConfirmation(transferId, None))
        case None =>
          Effect
            .reply(replyTo)(CancelIncomingCreditConfirmation(transferId, Some(iMadzError("60009", "incoming credits cannot be found or already be canceled before"))))

      }
  }

  private def mkLatestBalance[Param](param: Param)(updatedState: CreditBalanceState) =
    CreditBalanceConfirmation(None, updatedState.accountBalance.values.toList)

  private def mkError[Param](param: Param)(error: iMadzError) =
    CreditBalanceConfirmation(Some(error), Nil)

}


==================================================
文件路径: app\net\imadz\application\aggregates\factories\CreditBalanceAggregateFactory.scala
==================================================

package net.imadz.application.aggregates.factories

import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, EntityRef}
import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate.{AddInitial, CreditBalanceCommand, CreditBalanceConfirmation, CreditBalanceEntityTypeKey}
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

case class CreditBalanceAggregateFactory @Inject()(clusterSharding: ClusterSharding) {
  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def createCreditBalanceWithoutBalance(userId: Id): EntityRef[CreditBalanceCommand] =
    clusterSharding.entityRefFor(CreditBalanceEntityTypeKey, userId.toString)

  def createCreditBalanceWithDefaultBalance(userId: Id, initial: Money): Future[Either[iMadzError, EntityRef[CreditBalanceCommand]]] = {
    val entityRef: EntityRef[CreditBalanceCommand] = clusterSharding
      .entityRefFor[CreditBalanceCommand](CreditBalanceEntityTypeKey, userId.toString)
    for {
      confirmation <- entityRef.ask[CreditBalanceConfirmation](AddInitial(initial, _))
    } yield {
      confirmation.error
        .map(Left.apply[iMadzError, EntityRef[CreditBalanceCommand]])
        .getOrElse(Right(entityRef))
    }
  }

}


==================================================
文件路径: app\net\imadz\application\aggregates\repository\CreditBalanceRepository.scala
==================================================

package net.imadz.application.aggregates.repository

import akka.cluster.sharding.typed.scaladsl.EntityRef
import com.google.inject.ImplementedBy
import net.imadz.application.aggregates.CreditBalanceAggregate.CreditBalanceCommand
import net.imadz.common.CommonTypes.Id
import net.imadz.infrastructure.repositories.aggregate.CreditBalanceRepositoryImpl

@ImplementedBy(classOf[CreditBalanceRepositoryImpl])
trait CreditBalanceRepository {

  def findCreditBalanceByUserId(userId: Id): EntityRef[CreditBalanceCommand]

}


==================================================
文件路径: app\net\imadz\application\projection\MonthlyIncomeAndExpenseSummaryProjection.scala
==================================================

package net.imadz.application.projection

import akka.actor.typed.ActorSystem
import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import akka.contrib.persistence.mongodb.MongoReadJournal
import akka.persistence.query.Offset
import akka.projection.eventsourced.EventEnvelope
import akka.projection.eventsourced.scaladsl.EventSourcedProvider
import akka.projection.jdbc.scaladsl.JdbcProjection
import akka.projection.scaladsl.{ExactlyOnceProjection, SourceProvider}
import akka.projection.{ProjectionId, eventsourced}
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.domain.entities.CreditBalanceEntity.CreditBalanceEvent
import net.imadz.infrastructure.proto.credits.CreditBalanceEventPO

object MonthlyIncomeAndExpenseSummaryProjection {

  val projectionName = "MonthlyIncomeAndExpenseSummary"


  def createProjection(system: ActorSystem[_], sharding: ClusterSharding, index: Int, repository: MonthlyIncomeAndExpenseSummaryRepository): ExactlyOnceProjection[Offset, EventEnvelope[CreditBalanceEventPO.Event]] = {
    val sourceProvider: SourceProvider[Offset, eventsourced.EventEnvelope[CreditBalanceEventPO.Event]] = EventSourcedProvider
      .eventsByTag(system = system,
        readJournalPluginId = MongoReadJournal.Identifier,
        tag = CreditBalanceAggregate.tags(index))

    JdbcProjection.exactlyOnce(
      projectionId = ProjectionId(projectionName, CreditBalanceAggregate.tags(index)),
      sourceProvider = sourceProvider,
      sessionFactory = () => new ScalikeJdbcSession(),
      handler = () => MonthlyIncomeAndExpenseSummaryProjectionHandler(sharding, repository)
    )(system)
  }
}


==================================================
文件路径: app\net\imadz\application\projection\MonthlyIncomeAndExpenseSummaryProjectionHandler.scala
==================================================

package net.imadz.application.projection

import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import akka.projection.eventsourced
import akka.projection.eventsourced.EventEnvelope
import akka.projection.jdbc.scaladsl.JdbcHandler
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.domain.entities.CreditBalanceEntity.BalanceChanged
import net.imadz.infrastructure.persistence.CreditBalanceEventAdapter
import net.imadz.infrastructure.proto.credits.{CreditBalanceEventPO => CreditEventPO}

import java.time.{Instant, LocalDateTime, ZoneId}

case class MonthlyIncomeAndExpenseSummaryProjectionHandler(sharding: ClusterSharding,
                                                           repository: MonthlyIncomeAndExpenseSummaryRepository) extends JdbcHandler[eventsourced.EventEnvelope[CreditEventPO.Event], ScalikeJdbcSession] {
  val adapter = new CreditBalanceEventAdapter

  override def process(session: ScalikeJdbcSession, envelope: EventEnvelope[CreditEventPO.Event]): Unit = {
    adapter.fromJournal(envelope.event, "").events.foreach {
      case BalanceChanged(update, timestamp) =>
        val (year, month, day) = getDateFromTimestamp(timestamp)
        val userId = envelope.persistenceId
        if (update.amount > 0)
          repository.updateIncome(userId, update.amount, year, month, day)
        else {
          repository.updateExpense(userId, -update.amount, year, month, day)
        }
      case _ =>
        ()
    }
  }

  private def getDateFromTimestamp(timestamp: Long): (Int, Int, Int) = {
    val instant = Instant.ofEpochMilli(timestamp)
    val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())
    val year = dateTime.getYear
    val month = dateTime.getMonthValue
    val day = dateTime.getDayOfMonth
    (year, month, day)
  }
}


==================================================
文件路径: app\net\imadz\application\projection\ScalikeJdbcSession.scala
==================================================

package net.imadz.application.projection

import akka.japi.function.Function
import akka.projection.jdbc.JdbcSession
import scalikejdbc.DB
import java.sql.Connection

object ScalikeJdbcSession {
  def withSession[R](f: ScalikeJdbcSession => R): R = {
    val session = new ScalikeJdbcSession()
    try {
      f(session)
    } finally {
      session.close()
    }
  }
}

/**
 * Provide database connections within a transaction to Akka Projections.
 */
final class ScalikeJdbcSession extends JdbcSession {
  val db: DB = DB.connect()
  db.autoClose(false)

  override def withConnection[Result](func: Function[Connection, Result]): Result = {
    db.begin()
    db.withinTxWithConnection(func(_))
  }

  override def commit(): Unit = db.commit()

  override def rollback(): Unit = db.rollback()

  override def close(): Unit = db.close()
}


==================================================
文件路径: app\net\imadz\application\projection\ScalikeJdbcSetup.scala
==================================================

package net.imadz.application.projection

import akka.actor.typed.ActorSystem
import com.typesafe.config.Config
import com.zaxxer.hikari.HikariDataSource
import scalikejdbc.config.{DBs, NoEnvPrefix, TypesafeConfig, TypesafeConfigReader}
import scalikejdbc.{ConnectionPool, DataSourceCloser, DataSourceConnectionPool}

object ScalikeJdbcSetup {

  /**
   * Initiate the ScalikeJDBC connection pool configuration and shutdown.
   * The DataSource is setup with ActorSystem's config.
   *
   * The connection pool will be closed when the actor system terminates.
   */
  def init(system: ActorSystem[_]): Unit = {
    initFromConfig(system.settings.config)
    system.whenTerminated.map { _ =>
      ConnectionPool.closeAll()
    }(scala.concurrent.ExecutionContext.Implicits.global)

  }

  /**
   * Builds a Hikari DataSource with values from jdbc-connection-settings.
   * The DataSource is then configured as the 'default' connection pool for ScalikeJDBC.
   */
  private def initFromConfig(config: Config): Unit = {

    val dbs = new DBsFromConfig(config)
    dbs.loadGlobalSettings()

    val dataSource = buildDataSource(
      config.getConfig("jdbc-connection-settings"))

    ConnectionPool.singleton(
      new DataSourceConnectionPool(
        dataSource = dataSource,
        closer = HikariCloser(dataSource)))
  }

  private def buildDataSource(config: Config): HikariDataSource = {
    val dataSource = new HikariDataSource()

    dataSource.setPoolName("read-side-connection-pool")
    dataSource.setMaximumPoolSize(
      config.getInt("connection-pool.max-pool-size"))

    val timeout = config.getDuration("connection-pool.timeout").toMillis
    dataSource.setConnectionTimeout(timeout)

    dataSource.setDriverClassName(config.getString("driver"))
    dataSource.setJdbcUrl(config.getString("url"))
    dataSource.setUsername(config.getString("user"))
    dataSource.setPassword(config.getString("password"))

    dataSource
  }

  /**
   * This is only needed to allow ScalikeJdbc to load its logging configurations from the passed Config
   */
  private class DBsFromConfig(val config: Config)
      extends DBs
      with TypesafeConfigReader
      with TypesafeConfig
      with NoEnvPrefix

  /**
   * ScalikeJdbc needs a closer for the DataSource to delegate the closing call.
   */
  private case class HikariCloser(dataSource: HikariDataSource)
      extends DataSourceCloser {
    override def close(): Unit = dataSource.close()
  }

}


==================================================
文件路径: app\net\imadz\application\projection\repository\MonthlyIncomeAndExpendsSummaryRepository.scala
==================================================

package net.imadz.application.projection.repository

import com.google.inject.ImplementedBy
import net.imadz.infrastructure.repositories.projection.MonthlyIncomeAndExpenseSummaryRepositoryImpl

import scala.concurrent.Future

object MonthlyIncomeAndExpenseSummaryTable {
  case class MonthlyIncomeAndExpenseSummary(userId: String, income: BigDecimal, expense: BigDecimal, year: Int, month: Int)
}

@ImplementedBy(classOf[MonthlyIncomeAndExpenseSummaryRepositoryImpl])
trait MonthlyIncomeAndExpenseSummaryRepository {

  import MonthlyIncomeAndExpenseSummaryTable._

  def filterByPeriodLCRO(userId: String, startFromYear: Int, startFromMonth: Int, untilYear: Int, untilMonth: Int): Future[List[MonthlyIncomeAndExpenseSummary]]

  def updateIncome(userId: String, amount: BigDecimal, year: Int, month: Int, day: Int): Unit

  def updateExpense(userId: String, amount: BigDecimal, year: Int, month: Int, day: Int): Unit

}

==================================================
文件路径: app\net\imadz\application\queries\GetBalanceQuery.scala
==================================================

package net.imadz.application.queries

import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate.GetBalance
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

class GetBalanceQuery @Inject()(creditBalanceRepository: CreditBalanceRepository) {

  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def fetchBalanceByUserId(userId: Id): Future[List[Money]] =
    creditBalanceRepository.findCreditBalanceByUserId(userId)
      .ask(GetBalance)
      .map(confirmation => confirmation.error.map(_ => Nil).getOrElse(confirmation.balances))

}


==================================================
文件路径: app\net\imadz\application\queries\GetRecent12MonthsIncomeAndExpenseReport.scala
==================================================

package net.imadz.application.queries

import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.application.queries.GetRecent12MonthsIncomeAndExpenseReport.{MonthlyIncomeAndExpense, Recent12MonthsIncomeAndExpenseReport}
import net.imadz.common.CommonTypes.{Id, ReadModel}

import java.time.{LocalDate, YearMonth}
import javax.inject.Inject
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

object GetRecent12MonthsIncomeAndExpenseReport {

  case class MonthlyIncomeAndExpense(year: Int, month: Int, incomeTotal: BigDecimal, expenseTotal: BigDecimal)

  case class Recent12MonthsIncomeAndExpenseReport(monthlySummaries: List[MonthlyIncomeAndExpense]) extends ReadModel
}

class GetRecent12MonthsIncomeAndExpenseReport @Inject()(repository: MonthlyIncomeAndExpenseSummaryRepository) {

  def fetchByUserId(userId: Id): Future[Recent12MonthsIncomeAndExpenseReport] = {
    val now = LocalDate.now()
    val untilYearMonth = YearMonth.from(now)
    val startFromYearMonth = untilYearMonth.minusMonths(11)

    val startFromYear = startFromYearMonth.getYear
    val startFromMonth = startFromYearMonth.getMonthValue
    val untilYear = untilYearMonth.getYear
    val untilMonth = untilYearMonth.getMonthValue

    repository.filterByPeriodLCRO(userId.toString, startFromYear, startFromMonth, untilYear, untilMonth)
      .map(xs => Recent12MonthsIncomeAndExpenseReport(
        xs.map(x => MonthlyIncomeAndExpense(x.year, x.month, x.income, x.expense))
      ))
  }
}


==================================================
文件路径: app\net\imadz\application\services\CreateCreditBalanceService.scala
==================================================

package net.imadz.application.services

import akka.cluster.sharding.typed.scaladsl.EntityRef
import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.CreditBalanceAggregate.GetBalance
import net.imadz.application.aggregates.factories.CreditBalanceAggregateFactory
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

class CreateCreditBalanceService @Inject()(factory: CreditBalanceAggregateFactory) {
  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def createCreditBalance(userId: Id): Future[Either[iMadzError, List[Money]]] = {
    val entityRef = factory.createCreditBalanceWithoutBalance(userId)
    fetchUserCreditBalance(entityRef)
  }

  def createCreditBalance(userId: Id, initial: Money): Future[Either[iMadzError, List[Money]]] = {
    factory.createCreditBalanceWithDefaultBalance(userId, initial)
      .flatMap(either => either.fold(
        err => Future.successful(Left(err)),
        fetchUserCreditBalance))
  }

  private def fetchUserCreditBalance(entityRef: EntityRef[CreditBalanceAggregate.CreditBalanceCommand]) = {
    entityRef
      .ask(GetBalance.apply)
      .map(confirmation =>
        confirmation.error
          .map(Left.apply[iMadzError, List[Money]])
          .getOrElse(Right(confirmation.balances)))
  }
}


==================================================
文件路径: app\net\imadz\application\services\DepositService.scala
==================================================

package net.imadz.application.services

import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.CreditBalanceAggregate.Deposit
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

class DepositService @Inject()(creditBalanceRepository: CreditBalanceRepository) {

  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def requestDeposit(userId: Id, amount: Money): Future[CreditBalanceAggregate.CreditBalanceConfirmation] =
    creditBalanceRepository.findCreditBalanceByUserId(userId)
      .ask(Deposit(amount, _))
}


==================================================
文件路径: app\net\imadz\application\services\MoneyTransferService.scala
==================================================

package net.imadz.application.services

import akka.actor.typed.scaladsl.AskPattern.Askable
import akka.actor.typed.{ActorRef, ActorSystem, Scheduler}
import akka.util.Timeout
import net.imadz.application.services.transactor.MoneyTransferSagaTransactor._
import net.imadz.application.services.transactor.MoneyTransferTransactionRepository
import net.imadz.common.CommonTypes.{ApplicationService, Id}
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.duration._
import scala.concurrent.{ExecutionContext, Future}


class MoneyTransferService @Inject()(system: ActorSystem[_], transactionRepository: MoneyTransferTransactionRepository) extends ApplicationService {
  private implicit val timeout: Timeout = 120.seconds
  private implicit val ec: ExecutionContext = system.executionContext
  implicit val scheduler: Scheduler = system.scheduler


  def transfer(fromUserId: Id, toUserId: Id, amount: Money): Future[TransactionResultConfirmation] = {
    val transactionId = java.util.UUID.randomUUID()
    for {
      completionResult <- initiateTransaction(fromUserId, toUserId, amount, transactionId)
    } yield completionResult
  }

  private def initiateTransaction(fromUserId: Id, toUserId: Id, amount: Money, transactionId: Id): Future[TransactionResultConfirmation] = {
    val transactionRef = getTransactionRef(transactionId)
    transactionRef.ask(ref => InitiateMoneyTransferTransaction(fromUserId, toUserId, amount, ref))
  }


  private def getTransactionRef(transactionId: Id): ActorRef[MoneyTransferTransactionCommand] = {
    transactionRepository.findTransactionById(transactionId)
  }
}

==================================================
文件路径: app\net\imadz\application\services\WithdrawService.scala
==================================================

package net.imadz.application.services

import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.CreditBalanceAggregate.Withdraw
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

class WithdrawService @Inject()(creditBalanceRepository: CreditBalanceRepository) {
  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def requestWithdraw(userId: Id, amount: Money): Future[CreditBalanceAggregate.CreditBalanceConfirmation] =
    creditBalanceRepository.findCreditBalanceByUserId(userId)
      .ask(Withdraw(amount, _))
}


==================================================
文件路径: app\net\imadz\application\services\transactor\MoneyTransferSagaTransactor.scala
==================================================

package net.imadz.application.services.transactor

import akka.actor.typed.ActorRef
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.common.{CborSerializable, Id}
import net.imadz.domain.values.Money
import net.imadz.infra.saga.SagaParticipant._
import net.imadz.infra.saga.SagaPhase.{CommitPhase, CompensatePhase, PreparePhase}
import net.imadz.infra.saga.SagaTransactionCoordinator.{TracingStep, TransactionResult}
import net.imadz.infra.saga.{SagaParticipant, SagaTransactionStep}
import play.api.libs.json.{Json, OWrites}

import scala.concurrent.ExecutionContext

object MoneyTransferSagaTransactor {
  // Commands
  sealed trait MoneyTransferTransactionCommand

  case class InitiateMoneyTransferTransaction(fromUserId: Id, toUserId: Id, amount: Money, replyTo: ActorRef[TransactionResultConfirmation]) extends MoneyTransferTransactionCommand

  case class UpdateMoneyTransferTransactionStatus(id: Id, newStatus: TransactionResult, replyTo: ActorRef[TransactionResultConfirmation]) extends MoneyTransferTransactionCommand

  // Command Replies
  case class TransactionResultConfirmation(transactionId: Id, error: Option[String], tracing: List[TracingStep]) extends CborSerializable

  object TransactionResultConfirmation {
    implicit val confirmationWrites: OWrites[TransactionResultConfirmation] = Json.writes[TransactionResultConfirmation]
  }

  // Transaction Steps
  def createTransactionSteps(fromUserId: Id, toUserId: Id, amount: Money, repository: CreditBalanceRepository)(implicit ec: ExecutionContext): List[SagaTransactionStep[iMadzError, String]] = {
    val fromAccountParticipant = new FromAccountParticipant(fromUserId: Id, amount: Money, repository)
    val toAccountParticipant = new ToAccountParticipant(toUserId: Id, amount: Money, repository)

    List(
      SagaTransactionStep("reserve-amount-from-account", PreparePhase, fromAccountParticipant, 5),
      SagaTransactionStep("record-incoming-amount-to-account", PreparePhase, toAccountParticipant, 5),
      SagaTransactionStep("commit-from-account", CommitPhase, fromAccountParticipant, 5),
      SagaTransactionStep("commit-to-account", CommitPhase, toAccountParticipant, 5),
      SagaTransactionStep("compensate-from-account", CompensatePhase, fromAccountParticipant, 5),
      SagaTransactionStep("compensate-to-account", CompensatePhase, toAccountParticipant, 5)
    )
  }

  // Participants

  import akka.util.Timeout
  import net.imadz.application.aggregates.CreditBalanceAggregate._

  import scala.concurrent.ExecutionContext
  import scala.concurrent.duration._

  case class FromAccountParticipant(fromUserId: Id, amount: Money, repo: CreditBalanceRepository)(implicit ec: ExecutionContext) extends SagaParticipant[iMadzError, String] {

    implicit val timeout: Timeout = 5.seconds
    private val fromAccountRef = repo.findCreditBalanceByUserId(fromUserId)

    override def doPrepare(transactionId: String): ParticipantEffect[iMadzError, String] = {
      fromAccountRef.ask(CreditBalanceAggregate.ReserveFunds(Id.of(transactionId), amount, _))
        .mapTo[FundsReservationConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override def doCommit(transactionId: String): ParticipantEffect[iMadzError, String] = {
      fromAccountRef.ask(CreditBalanceAggregate.DeductFunds(Id.of(transactionId), _))
        .mapTo[FundsDeductionConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override def doCompensate(transactionId: String): ParticipantEffect[iMadzError, String] = {
      fromAccountRef.ask(CreditBalanceAggregate.ReleaseReservedFunds(Id.of(transactionId), _))
        .mapTo[FundsReleaseConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override protected def customClassification: PartialFunction[Throwable, SagaParticipant.RetryableOrNotException] = {
      case iMadzError("60003", message) => NonRetryableFailure(message)
      case iMadzError("60004", message) => NonRetryableFailure(message)
      case iMadzError(code, message) => NonRetryableFailure(message)
    }
  }

  case class ToAccountParticipant(toUserId: Id, amount: Money, repo: CreditBalanceRepository)(implicit ec: ExecutionContext) extends SagaParticipant[iMadzError, String] {
    private val toAccountRef = repo.findCreditBalanceByUserId(toUserId)

    implicit val timeout: Timeout = 5.seconds

    override def doPrepare(transactionId: String): ParticipantEffect[iMadzError, String] = {
      toAccountRef.ask(CreditBalanceAggregate.RecordIncomingCredits(Id.of(transactionId), amount, _))
        .mapTo[RecordIncomingCreditsConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override def doCommit(transactionId: String): ParticipantEffect[iMadzError, String] = {
      toAccountRef.ask(CreditBalanceAggregate.CommitIncomingCredits(Id.of(transactionId), _))
        .mapTo[CommitIncomingCreditsConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override def doCompensate(transactionId: String): ParticipantEffect[iMadzError, String] = {
      toAccountRef.ask(CreditBalanceAggregate.CancelIncomingCredit(Id.of(transactionId), _))
        .mapTo[CancelIncomingCreditConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override protected def customClassification: PartialFunction[Throwable, SagaParticipant.RetryableOrNotException] = {
      case iMadzError("60003", message) => NonRetryableFailure(message)
      case iMadzError("60004", message) => NonRetryableFailure(message)
      case iMadzError(code, message) => NonRetryableFailure(message)
    }
  }


}

==================================================
文件路径: app\net\imadz\application\services\transactor\MoneyTransferSagaTransactorBehaviors.scala
==================================================

package net.imadz.application.services.transactor

import akka.actor.typed.scaladsl.{ActorContext, Behaviors}
import akka.actor.typed.{Behavior, Scheduler}
import akka.cluster.sharding.typed.scaladsl.EntityRef
import akka.util.Timeout
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.application.services.transactor.MoneyTransferSagaTransactor._
import net.imadz.common.CommonTypes.iMadzError
import net.imadz.common.Id
import net.imadz.infra.saga.SagaTransactionCoordinator
import net.imadz.infra.saga.SagaTransactionCoordinator.TransactionResult

import scala.concurrent.ExecutionContext
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

object MoneyTransferSagaTransactorBehaviors {
  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def apply(context: ActorContext[MoneyTransferTransactionCommand], coordinator: EntityRef[SagaTransactionCoordinator.Command], repository: CreditBalanceRepository)(implicit ec: ExecutionContext, scheduler: Scheduler): Behavior[MoneyTransferTransactionCommand] =
    Behaviors.receiveMessage {
      case InitiateMoneyTransferTransaction(fromUserId, toUserId, amount, replyTo) =>
        val transactionId = Id.gen.toString
        val steps = createTransactionSteps(fromUserId, toUserId, amount, repository)

        coordinator.ask[TransactionResult](intermediateReplyTo =>
          SagaTransactionCoordinator.StartTransaction[iMadzError, String](transactionId, steps, Some(intermediateReplyTo)))
          .mapTo[TransactionResult]
          .foreach(context.self ! UpdateMoneyTransferTransactionStatus(Id.of(transactionId), _, replyTo))

        Behaviors.same

      case UpdateMoneyTransferTransactionStatus(id, transactionResponse, replyTo) =>
        if (transactionResponse.successful) {
          replyTo ! TransactionResultConfirmation(id, None, transactionResponse.tracingSteps)
        } else {
          replyTo ! TransactionResultConfirmation(id, Some(transactionResponse.failReason), transactionResponse.tracingSteps)
        }
        Behaviors.stopped
    }
}

==================================================
文件路径: app\net\imadz\application\services\transactor\MoneyTransferTransactionRepository.scala
==================================================

package net.imadz.application.services.transactor

import akka.actor.typed.ActorRef
import com.google.inject.ImplementedBy
import net.imadz.common.CommonTypes.Id
import net.imadz.infrastructure.repositories.service.MoneyTransferTransactionRepositoryImpl

@ImplementedBy(classOf[MoneyTransferTransactionRepositoryImpl])
trait MoneyTransferTransactionRepository {

  def findTransactionById(transaction: Id): ActorRef[MoneyTransferSagaTransactor.MoneyTransferTransactionCommand]
}


==================================================
文件路径: app\net\imadz\common\CborSerializable.scala
==================================================

package net.imadz.common

trait CborSerializable {

}


==================================================
文件路径: app\net\imadz\common\CommonTypes.scala
==================================================

package net.imadz.common

import net.imadz.common.CommonTypes.Id

import java.util.UUID

object CommonTypes {

  type Id = UUID

  final case class iMadzError(code: String, message: String) extends Throwable with CborSerializable

  trait ReadModel

  trait DomainPolicy[Event, State, Param] {
    def apply(state: State, param: Param): Either[iMadzError, List[Event]]
  }

  trait DomainService

  trait ApplicationService
}

object Id {
  def of(value: String): Id = UUID.fromString(value)

  def gen: Id = java.util.UUID.randomUUID()
}

==================================================
文件路径: app\net\imadz\common\application\CommandHandlerReplyingBehavior.scala
==================================================

package net.imadz.common.application

import akka.actor.typed.ActorRef
import akka.persistence.typed.scaladsl.Effect
import net.imadz.common.CommonTypes.{DomainPolicy, iMadzError}

object CommandHandlerReplyingBehavior {

  case class AwaitingReplyToRunnablePolicy[Event, State, Param, ReplyMessage](policy: DomainPolicy[Event, State, Param], state: State, param: Param) {
    def replyWith(replyTo: ActorRef[ReplyMessage])(leftConfirmationFactory: Param => iMadzError => ReplyMessage, rightConfirmationFactory: Param => State => ReplyMessage): Effect[Event, State] =
      policy(state, param).fold(
        error => Effect.reply(replyTo)(leftConfirmationFactory(param)(error)),
        events => Effect.persist(events).thenReply(replyTo)(rightConfirmationFactory(param)))
  }

  def runReplyingPolicy[Event, State, Param, ReplyMessage](policy: DomainPolicy[Event, State, Param])(state: State, param: Param): AwaitingReplyToRunnablePolicy[Event, State, Param, ReplyMessage] =
    AwaitingReplyToRunnablePolicy(policy = policy, state = state, param = param)
}

==================================================
文件路径: app\net\imadz\common\serialization\ObjectIdOffsetSerializer.scala
==================================================

package net.imadz.common.serialization

import akka.contrib.persistence.mongodb.ObjectIdOffset
import akka.serialization.Serializer
import reactivemongo.api.bson.BSONObjectID

import java.math.BigInteger

class ObjectIdOffsetSerializer extends Serializer {
  override def identifier: Int = 20160728

  override def toBinary(o: AnyRef): Array[Byte] = o match {
    case ObjectIdOffset(hexString, _) =>
      new BigInteger(hexString, 16).toByteArray
    case _ => throw new IllegalArgumentException("Only for ObjectIdOffset")
  }

  override def includeManifest: Boolean = true

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef = {
    BSONObjectID.parse((new BigInteger(bytes)).toString(16))
      .map(id => ObjectIdOffset(id.stringify, id.time))
      .getOrElse(throw new IllegalStateException("Only for ObjectIdOffset"))
  }
}


==================================================
文件路径: app\net\imadz\domain\entities\CreditBalanceEntity.scala
==================================================

package net.imadz.domain.entities

import net.imadz.common.CommonTypes.Id
import net.imadz.domain.values.Money


object CreditBalanceEntity {

  // @formatter:off
  // State
  case class CreditBalanceState(userId: Id, accountBalance: Map[String, Money], reservedAmount: Map[Id, Money], incomingCredits: Map[Id, Money])

  def empty(userId: Id): CreditBalanceState = CreditBalanceState(userId, Map.empty, Map.empty, Map.empty)

  // Event
  sealed trait CreditBalanceEvent
  case class BalanceChanged(update: Money, timestamp: Long = System.currentTimeMillis()) extends CreditBalanceEvent
  case class FundsReserved(transferId: Id, amount: Money) extends CreditBalanceEvent
  case class FundsDeducted(transferId: Id, amount: Money) extends CreditBalanceEvent
  case class ReservationReleased(transferId: Id, amount: Money) extends CreditBalanceEvent
  case class IncomingCreditsRecorded(transferId: Id, amount: Money) extends CreditBalanceEvent
  case class IncomingCreditsCommited(transferId: Id) extends CreditBalanceEvent
  case class IncomingCreditsCanceled(transferId: Id) extends CreditBalanceEvent
  // @formatter:on

  // Event Handler Extension Point
  type CreditBalanceEventHandler = (CreditBalanceState, CreditBalanceEvent) => CreditBalanceState

}

==================================================
文件路径: app\net\imadz\domain\entities\behaviors\CreditBalanceEventHandler.scala
==================================================

package net.imadz.domain.entities.behaviors

import net.imadz.common.CommonTypes.Id
import net.imadz.domain.entities.CreditBalanceEntity.{BalanceChanged, CreditBalanceEventHandler, CreditBalanceState}
import net.imadz.domain.values.Money

import java.util.Currency
import net.imadz.domain.entities.CreditBalanceEntity._

object CreditBalanceEventHandler {
  def apply: CreditBalanceEventHandler = (state, event) => event match {
    case BalanceChanged(updateMoney@Money(_, currency), _) =>
      state.copy(accountBalance = updateAccountBalance(state, currency, updateMoney))

    case FundsReserved(transferId, reserveAmount@Money(_, currency)) =>
      state.copy(
        accountBalance = updateAccountBalance(state, currency, reserveAmount.copy(amount = -reserveAmount.amount)),
        reservedAmount = state.reservedAmount + (transferId -> reserveAmount)
      )
    case FundsDeducted(transferId: Id, amount: Money) =>
      state.copy(
        reservedAmount = state.reservedAmount - transferId
      )
    case ReservationReleased(transferId, releaseAmount@Money(_, currency)) =>
      state.copy(
        accountBalance = updateAccountBalance(state, currency, releaseAmount),
        reservedAmount = state.reservedAmount - transferId
      )

    case IncomingCreditsRecorded(transferId, amount) =>
      state.copy(
        incomingCredits = state.incomingCredits + (transferId -> amount)
      )
    case IncomingCreditsCommited(transferId) =>
      state.copy(
        accountBalance= updateAccountBalance(state, state.incomingCredits(transferId).currency, state.incomingCredits(transferId)),
        incomingCredits = state.incomingCredits - transferId
      )
    case IncomingCreditsCanceled(transferId) =>
      state.copy(
        incomingCredits = state.incomingCredits - transferId
      )

  }

  private def updateAccountBalance(state: CreditBalanceState, currency: Currency, updateMoney: Money): Map[String, Money] = {
    val currentBalance = state.accountBalance.getOrElse(currency.getCurrencyCode, Money(BigDecimal(0), currency))
    state.accountBalance + (currency.getCurrencyCode -> (currentBalance + updateMoney).getOrElse(Money(BigDecimal(0), currency)))
  }

  private def defaultMoney(currency: Currency) = {
    Money(BigDecimal(0), currency)
  }

  private def originalMoney(balanceMap: Map[String, Money], currency: Currency): Money = {
    balanceMap.getOrElse(currency.getCurrencyCode, defaultMoney(currency))
  }
}

==================================================
文件路径: app\net\imadz\domain\policy\AddInitialOnlyOncePolicy.scala
==================================================

package net.imadz.domain.policy

import net.imadz.common.CommonTypes.{DomainPolicy, iMadzError}
import net.imadz.domain.entities.CreditBalanceEntity.{BalanceChanged, CreditBalanceEvent, CreditBalanceState}
import net.imadz.domain.values.Money

object AddInitialOnlyOncePolicy extends DomainPolicy[CreditBalanceEvent, CreditBalanceState, Money] {

  private val InitialConditionNotMeet: iMadzError = iMadzError("60000", "不满足 Initial 条件")

  def apply(creditBalanceState: CreditBalanceState, initial: Money): Either[iMadzError, List[CreditBalanceEvent]] =
    if (creditBalanceState.accountBalance.values.exists(_.amount > 0)) Left(InitialConditionNotMeet)
    else Right(List(BalanceChanged(initial)))


}


==================================================
文件路径: app\net\imadz\domain\policy\DepositPolicy.scala
==================================================

package net.imadz.domain.policy

import net.imadz.common.CommonTypes.{DomainPolicy, iMadzError}
import net.imadz.domain.entities.CreditBalanceEntity.{BalanceChanged, CreditBalanceEvent, CreditBalanceState}
import net.imadz.domain.values.Money

object DepositPolicy extends DomainPolicy[CreditBalanceEvent, CreditBalanceState, Money] {
  private val ChangeShouldBePositive: iMadzError = iMadzError("60001", "change 需要为正数")

  def apply(state: CreditBalanceState, change: Money): Either[iMadzError, List[CreditBalanceEvent]] =
    if (change.amount <= 0) Left(ChangeShouldBePositive)
    else Right(List(BalanceChanged(change)))
}


==================================================
文件路径: app\net\imadz\domain\policy\WithdrawPolicy.scala
==================================================

package net.imadz.domain.policy

import net.imadz.common.CommonTypes.{DomainPolicy, iMadzError}
import net.imadz.domain.entities.CreditBalanceEntity.{BalanceChanged, CreditBalanceEvent, CreditBalanceState}
import net.imadz.domain.values.Money

object WithdrawPolicy extends DomainPolicy[CreditBalanceEvent, CreditBalanceState, Money] {

  private val NotEnoughBalance: iMadzError = iMadzError("60002", "balance 不足扣减 或 扣减值应该为正数")

  def apply(creditBalanceState: CreditBalanceState, withdrawAmount: Money): Either[iMadzError, List[CreditBalanceEvent]] =
    if (creditBalanceState.accountBalance
      .get(withdrawAmount.currency.getCurrencyCode)
      .flatMap(withdrawAmount <= _)
      .getOrElse(false)) Right(List(BalanceChanged(withdrawAmount.copy(amount = -withdrawAmount.amount))))
    else
      Left(NotEnoughBalance)

}


==================================================
文件路径: app\net\imadz\domain\services\TransferDomainService.scala
==================================================

package net.imadz.domain.services

import net.imadz.common.CommonTypes.{DomainService, Id, iMadzError}
import net.imadz.domain.values.Money

object TransferDomainService extends DomainService {
  def validateTransfer(transferId: Id, reservedAmount: Map[Id, Money], fromBalance: Money, transferAmount: Money): Either[iMadzError, Unit] = {
    if (reservedAmount.contains(transferId)) Left(iMadzError("60008", "Already reserved"))
    else if (fromBalance.amount < transferAmount.amount) {
      Left(iMadzError("60003", "Insufficient balance for transfer"))
    } else if (transferAmount.amount <= BigDecimal(0)) {
      Left(iMadzError("60004", "Transfer amount must be positive"))
    } else {
      Right(())
    }
  }
}

==================================================
文件路径: app\net\imadz\domain\values\Money.scala
==================================================

package net.imadz.domain.values

import java.util.Currency

// Value Object
case class Money(amount: BigDecimal, currency: Currency) {
  def -(other: Money): Option[Money] = {
    if (this.currency == other.currency) Some(copy(amount = this.amount - other.amount))
    else None
  }

  def +(other: Money): Option[Money] = {
    if (this.currency == other.currency) Some(copy(amount = this.amount + other.amount))
    else None
  }

  def <=(other: Money): Option[Boolean] = {
    if (this.currency == other.currency) Some(this.amount <= other.amount)
    else None
  }
}


==================================================
文件路径: app\net\imadz\infra\saga\ForSaga.scala
==================================================

package net.imadz.infra.saga

/**
 * Marker for indexing source code for grounding saga transaction
 */
trait ForSaga {

}


==================================================
文件路径: app\net\imadz\infra\saga\SagaParticipant.scala
==================================================

package net.imadz.infra.saga

import net.imadz.infra.saga.SagaParticipant._
import org.slf4j.{Logger, LoggerFactory}

import java.net.ConnectException
import java.sql.SQLTransientException
import scala.concurrent.{ExecutionContext, Future, TimeoutException}
import scala.util.{Failure, Success}

object SagaParticipant {
  case class SagaResult[T](
                            message: Option[String],
                            metadata: Map[String, String],
                            data: Option[T]
                          )

  object SagaResult {
    def empty[T](): SagaResult[T] = SagaResult[T](None, Map.empty[String, String], None)

    def apply[T](data: T): SagaResult[T] = SagaResult(None, Map.empty[String, String], Some(data))

    def apply[T](data: T, message: String): SagaResult[T] = SagaResult(Some(message), Map.empty[String, String], Some(data))
  }

  type ParticipantEffect[E, R] = Future[Either[E, SagaResult[R]]]

  sealed trait RetryableOrNotException {
    def message: String
  }

  case class RetryableFailure(message: String) extends RuntimeException(message) with RetryableOrNotException

  case class NonRetryableFailure(message: String) extends RuntimeException(message) with RetryableOrNotException

}

trait SagaParticipant[E, R] {

  protected def logger: Logger = LoggerFactory.getLogger(getClass)

  protected def doPrepare(transactionId: String): ParticipantEffect[E, R]

  protected def doCommit(transactionId: String): ParticipantEffect[E, R]

  protected def doCompensate(transactionId: String): ParticipantEffect[E, R]

  def prepare(transactionId: String)(implicit ec: ExecutionContext): ParticipantEffect[RetryableOrNotException, R] =
    executeWithRetryClassification(doPrepare(transactionId))

  def commit(transactionId: String)(implicit ec: ExecutionContext): ParticipantEffect[RetryableOrNotException, R] =
    executeWithRetryClassification(doCommit(transactionId))

  def compensate(transactionId: String)(implicit ec: ExecutionContext): ParticipantEffect[RetryableOrNotException, R] =
    executeWithRetryClassification(doCompensate(transactionId))

  private def executeWithRetryClassification(
                                              operation: => ParticipantEffect[E, R]
                                            )(implicit ec: ExecutionContext): ParticipantEffect[RetryableOrNotException, R] = {
    logger.debug("SagaParticipant is executing...")

    operation.transform {
      case Success(Right(r)) =>
        logger.info("SagaParticipant executed successfully with right result")
        Success(Right(r))
      case Success(Left(e@net.imadz.common.CommonTypes.iMadzError(code, message))) =>
        logger.warn(s"SagaParticipant executed failed with $e")
        Success(Left(classifyFailure(e)))
      case Success(Left(e)) =>
        logger.warn(s"SagaParticipant executed failed with $e")
        Success(Left(classifyFailure(new Exception("Operation failed"))))
      case Failure(e) =>
        logger.warn(s"SagaParticipant executed failed with $e")
        Success(Left(classifyFailure(e)))
    }
  }

  private def classifyFailure(e: Throwable): RetryableOrNotException = {
    val retryableOrNotException = defaultClassification
      .orElse(customClassification)
      .orElse(fallbackClassification)
      .apply(e)

    logger.warn(s"$e had been classified as $retryableOrNotException")

    retryableOrNotException
  }

  private def defaultClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case _: TimeoutException => RetryableFailure("Operation timed out")
    case _: ConnectException => RetryableFailure("Connection failed")
    case _: SQLTransientException => RetryableFailure("Transient database error")
    case _: IllegalArgumentException => NonRetryableFailure("Invalid argument")
  }

  protected def customClassification: PartialFunction[Throwable, RetryableOrNotException]

  private def fallbackClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case e => NonRetryableFailure("Unclassified error: " + e.getClass.getName + ":" + e.getMessage)
  }

}


==================================================
文件路径: app\net\imadz\infra\saga\SagaTransactionCoordinator.scala
==================================================

package net.imadz.infra.saga

import akka.actor.typed.scaladsl.{ActorContext, Behaviors}
import akka.actor.typed.{ActorRef, Behavior, Scheduler}
import akka.cluster.sharding.typed.scaladsl.EntityTypeKey
import akka.persistence.typed.PersistenceId
import akka.persistence.typed.scaladsl.{Effect, EventSourcedBehavior}
import akka.util.Timeout
import net.imadz.common.CborSerializable
import net.imadz.infra.saga.SagaParticipant.{NonRetryableFailure, RetryableFailure, RetryableOrNotException, SagaResult}
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.StepExecutor.{StepCompleted, StepFailed, StepResult}
import play.api.libs.json._

import scala.concurrent.{ExecutionContext, Future}
import scala.language.postfixOps

object SagaTransactionCoordinator {
  val tags: Vector[String] = Vector.tabulate(5)(i => s"SagaTransactionCoordinator-$i")
  val entityTypeKey: EntityTypeKey[Command] = EntityTypeKey("SagaTransactionCoordinator")


  // @formatter:off
  // Commands
  sealed trait Command extends CborSerializable
  case class StartTransaction[E, R](transactionId: String, steps: List[SagaTransactionStep[E, R]], replyTo: Option[ActorRef[TransactionResult]]) extends Command
  private case class PhaseCompleted(phase: TransactionPhase, results: List[Either[RetryableOrNotException, Any]], stepTraces: List[StepExecutor.State[_, _]], replyTo: Option[ActorRef[TransactionResult]]) extends Command
  private case class PhaseFailure(phase: TransactionPhase, error: RetryableOrNotException, stepTraces: List[StepExecutor.State[_, _]], replyTo: Option[ActorRef[TransactionResult]]) extends Command
  case class TracingStep(
                          stepNumber: Int,
                          stepId: String,
                          stepType: String,
                          phase: String,
                          participant: String,
                          status: String,
                          retries: Int,
                          maxRetries: Int,
                          timeoutInMillis: Long,
                          retryWhenRecoveredOngoing: Boolean,
                          circuitBreakerOpen: Boolean,
                          error: Option[ErrorInfo]
                        ) {
    override def toString: String = {
      val step = this
      s"""
         |Step Number: ${step.stepNumber}, Step Id: ${step.stepId}, Phase: ${step.phase}, Step Type: ${step.stepType},
         |Saga Participant: ${step.participant}, ${step.status},
         |Step Status: ${step.status}
         |Step Failure: ${step.error.map(e => "type: " + e.errorType +" , msg: " + e.message).getOrElse("")},
         |Retries/MaxRetries: ${step.retries}/${step.maxRetries},
         |RetryWhenRecoveredOngoing: ${step.retryWhenRecoveredOngoing},
         |Step Timeout: ${step.timeoutInMillis} millis,
         |CircuitBreakerOpen: ${step.circuitBreakerOpen}
         |
         |""".stripMargin.replaceAll("""\n""", "")
     }

  }
  object TracingStep {
    implicit val errorInfoFormat: OWrites[ErrorInfo] = Json.writes[ErrorInfo]

    implicit val tracingStepFormat: OWrites[TracingStep] = Json.writes[TracingStep]

    def fromStepExecutorState(state: StepExecutor.State[_, _], stepNumber: Int): TracingStep = {
      val step = state.step.getOrElse(throw new IllegalStateException(s"Step $stepNumber has no associated SagaTransactionStep"))
      TracingStep(
        stepNumber = stepNumber,
        stepId = step.stepId,
        stepType = step.getClass.getSimpleName,
        phase = step.phase.toString,
        participant = step.participant.getClass.getSimpleName,
        status = state.status.toString,
        retries = state.retries,
        maxRetries = step.maxRetries,
        timeoutInMillis = step.timeoutDuration.toMillis ,
        retryWhenRecoveredOngoing = step.retryWhenRecoveredOngoing,
        circuitBreakerOpen = state.circuitBreakerOpen,
        error = state.lastError.map(e => ErrorInfo(e.message, e.getClass.getSimpleName, e.isInstanceOf[RetryableFailure]))
      )
    }
  }
  case class ErrorInfo(
                        message: String,
                        errorType: String,
                        isRetryable: Boolean
                      )
  case class TransactionResult(successful: Boolean, state: State, stepTraces: List[StepExecutor.State[_, _]]){
    
    def orderedSteps: Seq[StepExecutor.State[_, _]]= stepTraces.reverse

    lazy val tracingSteps: List[TracingStep] = orderedSteps.zipWithIndex.map(step=> TracingStep.fromStepExecutorState(step._1, step._2)).toList
    def failReason: String = tracingSteps.filter(step => step.error.nonEmpty).map(_.toString).mkString(";")

  }

  // Events
  sealed trait Event extends CborSerializable
  case class TransactionStarted(transactionId: String, steps: List[SagaTransactionStep[_, _]]) extends Event
  case class PhaseSucceeded(phase: TransactionPhase) extends Event
  case class PhaseFailed(phase: TransactionPhase) extends Event
  case class TransactionCompleted(transactionId: String) extends Event
  case class TransactionFailed(transactionId: String, reason: String) extends Event

  // State
  case class State(
                    transactionId: Option[String] = None,
                    steps: List[SagaTransactionStep[_, _]] = List.empty,
                    currentPhase: TransactionPhase = PreparePhase,
                    status: Status = Created
                  )

  sealed trait Status
  case object Created extends Status
  case object InProgress extends Status
  case object Completed extends Status
  case object Failed extends Status

  // @formatter:on

  def apply(
             persistenceId: PersistenceId,
             stepExecutorFactory: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command]
           )(implicit ec: ExecutionContext, timeout: Timeout): Behavior[Command] = Behaviors.setup { context =>
    EventSourcedBehavior[Command, Event, State](
      persistenceId = persistenceId,
      emptyState = State(),
      commandHandler = commandHandler(context, stepExecutorFactory),
      eventHandler = eventHandler
    )
  }

  def commandHandler(
                      context: ActorContext[Command],
                      stepExecutorFactory: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command]
                    )(implicit ec: ExecutionContext, timeout: Timeout): (State, Command) => Effect[Event, State] = { (state, command) =>
    command match {
      case StartTransaction(transactionId, steps, replyTo) if state.status == Created =>
        Effect
          .persist(TransactionStarted(transactionId, steps))
          .thenRun { _ =>
            executePhase(context, State(Some(transactionId), steps, PreparePhase, InProgress), stepExecutorFactory, Nil, replyTo)
          }

      case PhaseCompleted(phase, results, trace, replyTo) =>
        handlePhaseCompletion(context, state, phase, results, trace, stepExecutorFactory, replyTo)

      case PhaseFailure(phase, error, trace, replyTo) =>
        handlePhaseFailure(context, state, phase, error, trace, stepExecutorFactory, replyTo)

      case _ => Effect.none
    }
  }

  private def handlePhaseCompletion(
                                     context: ActorContext[Command],
                                     state: State,
                                     phase: TransactionPhase,
                                     results: List[Either[RetryableOrNotException, Any]],
                                     trace: List[StepExecutor.State[_, _]],
                                     stepExecutorFactory: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command],
                                     replyTo: Option[ActorRef[TransactionResult]]
                                   )(implicit ec: ExecutionContext, timeout: Timeout): Effect[Event, State] = {
    if (results.forall(_.isRight)) {
      phase match {
        case PreparePhase =>
          Effect
            .persist(PhaseSucceeded(PreparePhase))
            .thenRun { _ => executePhase(context, state.copy(currentPhase = CommitPhase), stepExecutorFactory, trace, replyTo) }
        case CommitPhase =>
          Effect.persist(
            List(
              PhaseSucceeded(CommitPhase),
              TransactionCompleted(state.transactionId.get)
            )
          ).thenRun(stateNew => replyTo.foreach(_ ! TransactionResult(successful = true, stateNew, trace)))
        case CompensatePhase =>
          Effect.persist(
            List(
              PhaseSucceeded(CompensatePhase),
              TransactionFailed(state.transactionId.get, "transaction failed but compensated")
            )
          ).thenRun(stateNew => replyTo.foreach(_ ! TransactionResult(successful = false, stateNew, trace)))
      }
    } else {
      // If any step in the phase failed, start compensation
      Effect
        .persist(TransactionFailed(state.transactionId.get, s"Phase $phase failed"))
        .thenRun { _ => executePhase(context, state.copy(currentPhase = CompensatePhase), stepExecutorFactory, trace, replyTo) }
    }
  }

  private def handlePhaseFailure(
                                  context: ActorContext[Command],
                                  state: State,
                                  phase: TransactionPhase,
                                  error: RetryableOrNotException,
                                  trace: List[StepExecutor.State[_, _]],
                                  stepExecutorFactory: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command],
                                  replyTo: Option[ActorRef[TransactionResult]]
                                )(implicit ec: ExecutionContext, timeout: Timeout): Effect[Event, State] = {
    Effect
      .persist(PhaseFailed(phase), TransactionFailed(state.transactionId.get, s"Phase $phase failed with error: ${error.message}"))
      .thenRun { stateNew =>
        if (phase != CompensatePhase) {
          executePhase(context, state.copy(currentPhase = CompensatePhase), stepExecutorFactory, trace, replyTo)
        } else {
          replyTo.foreach(_ ! TransactionResult(successful = false, stateNew, trace))
        }
      }
  }

  private def executePhase[E, R](
                                  context: ActorContext[Command],
                                  state: State,
                                  stepExecutorFactory: (String, SagaTransactionStep[E, R]) => ActorRef[StepExecutor.Command],
                                  trace: List[StepExecutor.State[_, _]],
                                  replyTo: Option[ActorRef[TransactionResult]]
                                )(implicit ec: ExecutionContext, askTimeout: Timeout): Unit = {

    val stepsInPhase = state.steps.filter(_.phase == state.currentPhase)

    import akka.actor.typed.scaladsl.AskPattern._
    implicit val scheduler: Scheduler = context.system.scheduler

    val futureResults: Future[List[StepResult[E, R]]] = Future.sequence(
      stepsInPhase.map { step =>
        val stepExecutor = stepExecutorFactory(
          s"${state.transactionId.get}-${step.stepId}-${state.currentPhase}",
          step.asInstanceOf[SagaTransactionStep[E, R]]
        )
        stepExecutor.ask((ref: ActorRef[StepResult[E, R]]) => StepExecutor.Start[E, R](state.transactionId.get, step.asInstanceOf[SagaTransactionStep[E, R]], Some(ref)))(askTimeout, scheduler)
          .mapTo[StepResult[E, R]]
      }
    )

    futureResults.foreach(stepResults => {

      val stepStateTrace = stepResults.foldLeft(trace)((acc, result) => result match {
        case StepCompleted(tid, r, stepState) => stepState :: acc
        case StepFailed(tid, e, stepState) => stepState :: acc
      })

      val positiveResults = stepResults.foldLeft[List[Either[RetryableOrNotException, SagaResult[R]]]](Nil)((acc, result) => result match {
        case StepCompleted(tid, r, stepState) => Right(r) :: acc
        case StepFailed(tid, e: E, stepState) => Left(NonRetryableFailure(e.toString)) :: acc
      })

      stepResults.find(_.isInstanceOf[StepFailed[_, _]]).map(firstError => {
        context.self ! PhaseFailure(state.currentPhase, NonRetryableFailure(firstError.toString), stepStateTrace, replyTo)
      }).getOrElse({
        context.self ! PhaseCompleted(state.currentPhase, positiveResults, stepStateTrace, replyTo)
      })

    })
  }

  def eventHandler: (State, Event) => State = { (state, event) =>
    event match {
      case TransactionStarted(transactionId, steps) =>
        state.copy(transactionId = Some(transactionId), steps = steps, status = InProgress)
      case PhaseFailed(phase) =>
        phase match {
          case PreparePhase => state.copy(currentPhase = CompensatePhase, status = Failed)
          case CommitPhase => state.copy(currentPhase = CompensatePhase, status = Failed)
          case CompensatePhase => state.copy(status = Failed)
        }
      case PhaseSucceeded(phase) =>
        phase match {
          case PreparePhase => state.copy(currentPhase = CommitPhase)
          case CommitPhase => state.copy(status = Completed)
          case CompensatePhase => state
        }
      case TransactionCompleted(_) =>
        state.copy(status = Completed)
      case TransactionFailed(_, _) =>
        state.copy(status = Failed)
    }
  }
}

==================================================
文件路径: app\net\imadz\infra\saga\StepExecutor.scala
==================================================

package net.imadz.infra.saga

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ActorRef, Behavior}
import akka.pattern.CircuitBreaker
import akka.persistence.typed.scaladsl.EventSourcedBehavior
import akka.persistence.typed.{PersistenceId, RecoveryCompleted}
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CborSerializable
import net.imadz.infra.saga.SagaParticipant.{RetryableOrNotException, SagaResult}
import net.imadz.infra.saga.SagaPhase.TransactionPhase
import net.imadz.infra.saga.handlers.{StepExecutorCommandHandler, StepExecutorEventHandler, StepExecutorRecoveryHandler}
import net.imadz.infra.saga.serialization.AkkaSerializationWrapper
import net.imadz.infrastructure.persistence.StepExecutorEventAdapter

import scala.concurrent.duration._

object SagaPhase {
  // Value Object
  sealed trait TransactionPhase extends CborSerializable {
    val key: String = toString
  }

  case object PreparePhase extends TransactionPhase {
    override def toString: String = "prepare"
  }

  case object CommitPhase extends TransactionPhase {
    override def toString: String = "commit"
  }

  case object CompensatePhase extends TransactionPhase {
    override def toString: String = "compensate"
  }
}

case class SagaTransactionStep[E, R](
                                      stepId: String,
                                      phase: TransactionPhase,
                                      participant: SagaParticipant[E, R],
                                      maxRetries: Int = 0,
                                      timeoutDuration: FiniteDuration = 30.seconds,
                                      retryWhenRecoveredOngoing: Boolean = true
                                    )

object StepExecutor {
  // @formatter:off
  // Value Class
  case class CircuitBreakerSettings(maxFailures: Int, callTimeout: FiniteDuration, resetTimeout: FiniteDuration)

  // Command
  sealed trait Command extends CborSerializable
  case class Start[E, R](transactionId: String,  sagaStep: SagaTransactionStep[E, R], replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
  case class RecoverExecution[E, R](transactionId: String, sagaStep: SagaTransactionStep[E, R], replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
   case class OperationResponse[E, R](result: Either[RetryableOrNotException, R], replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
   case class RetryOperation[E, R](replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
   case class TimedOut[E, R](replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
  sealed trait StepResult[E, R] extends CborSerializable
  case class StepCompleted[E,R](transactionId: String, result: SagaResult[R], state: State[E, R]) extends StepResult[E, R]
  case class StepFailed[E, R](transactionId: String, error: E, state: State[E, R]) extends StepResult[E, R]

  // Events
  sealed trait Event
  case class ExecutionStarted[E, R](transactionId: String, transactionStep: SagaTransactionStep[E, R], replyToPath: String) extends Event
  case class OperationSucceeded[R](result: R) extends Event
  case class OperationFailed(error: RetryableOrNotException) extends Event
  case class RetryScheduled(retryCount: Int) extends Event

  // State
  case class State[E, R](
                          step: Option[SagaTransactionStep[E, R]] = None,
                          transactionId: Option[String] = None,
                          status: Status = Created,
                          retries: Int = 0,
                          lastError: Option[RetryableOrNotException] = None,
                          circuitBreakerOpen: Boolean = false,
                          replyTo: Option[String] = None
                        ) extends CborSerializable {
    def canRetry: Boolean = this.status == Ongoing

    def canScheduleRetryOnTimedOut(defaultMaxRetries: Int): Boolean = this.status == Ongoing && this.maxRetriesReached(defaultMaxRetries)

    def canScheduleRetryOnFailure(defaultMaxRetries: Int): Boolean = ((this.status == Ongoing || this.status == Failed)
      && !this.maxRetriesReached(defaultMaxRetries))

    def canStart: Boolean = this.status == Created

    def canRecover: Boolean = this.status == Ongoing && this.step.exists(_.retryWhenRecoveredOngoing)

    private def maxRetriesReached(defaultMaxRetries: Int): Boolean = {
      this.retries >= this.step.map(_.maxRetries).getOrElse(defaultMaxRetries)
    }
  }

  sealed trait Status extends CborSerializable
  case object Created extends Status
  case object Ongoing extends Status
  case object Succeed extends Status
  case object Failed extends Status

  // @formatter:on


  def apply[E, R](creditBalanceRepository: CreditBalanceRepository)(persistenceId: PersistenceId, defaultMaxRetries: Int, initialRetryDelay: FiniteDuration, circuitBreakerSettings: CircuitBreakerSettings): Behavior[Command] = {
    Behaviors.setup { context =>
      Behaviors.withTimers { timers =>

        val circuitBreaker: CircuitBreaker = CircuitBreaker(
          scheduler = context.system.classicSystem.scheduler,
          maxFailures = circuitBreakerSettings.maxFailures,
          callTimeout = circuitBreakerSettings.callTimeout,
          resetTimeout = circuitBreakerSettings.resetTimeout
        )
        val akkaSerialization = AkkaSerializationWrapper(context.system.classicSystem)
        val global = scala.concurrent.ExecutionContext.global

        EventSourcedBehavior[Command, Event, State[E, R]](
          persistenceId = persistenceId,
          emptyState = State[E, R](),
          commandHandler = StepExecutorCommandHandler.commandHandler[E, R](context, timers, defaultMaxRetries, initialRetryDelay, circuitBreaker),
          eventHandler = StepExecutorEventHandler.eventHandler[E, R]
        ).eventAdapter(StepExecutorEventAdapter(akkaSerialization, creditBalanceRepository, global))
          .receiveSignal {
            case (state, RecoveryCompleted) =>
              StepExecutorRecoveryHandler.onRecoveryCompleted[E, R](context, state)
          }
      }
    }
  }


  def apply[E, R](persistenceId: PersistenceId, defaultMaxRetries: Int, initialRetryDelay: FiniteDuration, circuitBreakerSettings: CircuitBreakerSettings): Behavior[Command] = {
    Behaviors.setup { context =>
      Behaviors.withTimers { timers =>

        val circuitBreaker: CircuitBreaker = CircuitBreaker(
          scheduler = context.system.classicSystem.scheduler,
          maxFailures = circuitBreakerSettings.maxFailures,
          callTimeout = circuitBreakerSettings.callTimeout,
          resetTimeout = circuitBreakerSettings.resetTimeout
        )
        val akkaSerialization = AkkaSerializationWrapper(context.system.classicSystem)
        val global = scala.concurrent.ExecutionContext.global

        EventSourcedBehavior[Command, Event, State[E, R]](
          persistenceId = persistenceId,
          emptyState = State[E, R](),
          commandHandler = StepExecutorCommandHandler.commandHandler[E, R](context, timers, defaultMaxRetries, initialRetryDelay, circuitBreaker),
          eventHandler = StepExecutorEventHandler.eventHandler[E, R]
        ).receiveSignal {
          case (state, RecoveryCompleted) =>
            StepExecutorRecoveryHandler.onRecoveryCompleted[E, R](context, state)
        }
      }
    }
  }
}

==================================================
文件路径: app\net\imadz\infra\saga\handlers\StepExecutorCommandHandler.scala
==================================================

package net.imadz.infra.saga.handlers
import akka.actor.typed.ActorRef
import akka.actor.typed.scaladsl.TimerScheduler
import akka.pattern.CircuitBreaker
import akka.persistence.typed.scaladsl.Effect
import net.imadz.infra.saga.SagaParticipant._
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.{SagaParticipant, SagaTransactionStep}
import net.imadz.infra.saga.StepExecutor._
import org.slf4j.LoggerFactory

import scala.concurrent.duration.FiniteDuration
object StepExecutorCommandHandler {
   def commandHandler[E, R](
                                    context: akka.actor.typed.scaladsl.ActorContext[Command],
                                    timers: TimerScheduler[Command],
                                    defaultMaxRetries: Int,
                                    initialRetryDelay: FiniteDuration,
                                    circuitBreaker: CircuitBreaker
                                  ): (State[E, R], Command) => Effect[Event, State[E, R]] = { (state, command) =>
    command match {
      case Start(transactionId, step, replyTo: Some[ActorRef[StepResult[E, R]]]) if state.canStart =>
        Effect
          .persist(ExecutionStarted(transactionId, step, serializeActorRef(replyTo)))
          .thenRun(_ => executeOperation(context, step.phase, step, transactionId, circuitBreaker, replyTo))

      case RecoverExecution(transactionId, step, replyTo) if state.canRecover =>

        Effect
          .persist(ExecutionStarted(transactionId, step, serializeActorRef(replyTo)))
          .thenRun(_ => executeOperation(context, step.phase, step, transactionId, circuitBreaker, replyTo))


      case OperationResponse(Right(result), replyTo: Option[ActorRef[StepResult[E, R]]]) if state.status == Ongoing =>
        Effect
          .persist(OperationSucceeded(result))
          .thenRun(updatedState => updatedState.status match {
            case Succeed => // Notify success
              replyTo.foreach(_ ! StepCompleted[E, R](state.transactionId.get, result.asInstanceOf[SagaResult[R]], updatedState))
            case _ => // Unexpected state
          })

      case OperationResponse(Left(error: RetryableFailure), replyTo) if state.canScheduleRetryOnFailure(defaultMaxRetries) =>

        val nextRetry = state.retries + 1
        val nextDelay = calculateBackoffDelay(initialRetryDelay, nextRetry)

        Effect
          .persist(List(OperationFailed(error), RetryScheduled(nextRetry)))
          .thenRun(_ => scheduleRetry(timers, nextDelay, replyTo))

      case OperationResponse(Left(error), replyTo: Option[ActorRef[StepResult[E, R]]]) =>
        Effect
          .persist(OperationFailed(error))
          .thenRun(stateUpdated => replyTo.foreach(_ ! StepFailed(state.transactionId.get, error, stateUpdated)))

      case TimedOut(replyTo) if state.canScheduleRetryOnTimedOut(defaultMaxRetries) =>
        context.log.warn(s"TimedOut found ${state.retries} times")

        val nextRetry = state.retries + 1
        val nextDelay = calculateBackoffDelay(initialRetryDelay, nextRetry)

        Effect
          .persist(List(OperationFailed(RetryableFailure("timed out")), RetryScheduled(nextRetry)))
          .thenRun(_ => scheduleRetry(timers, nextDelay, replyTo))

      case TimedOut(replyTo: Option[ActorRef[StepResult[E, R]]]) =>
        Effect
          .persist(OperationFailed(RetryableFailure("timed out")))
          .thenRun(stateUpdated => replyTo.foreach(_ ! StepFailed(state.transactionId.get, RetryableFailure("timed out"), stateUpdated)))

      case RetryOperation(replyTo: Option[ActorRef[StepResult[E, R]]]) if state.canRetry =>
        state.step.zip(state.transactionId).map {
          case (step, trxId) =>
            Effect.none[Event, State[E, R]]
              .thenRun(_ => executeOperation[E, R](context, step.phase, step, state.transactionId.get, circuitBreaker, replyTo))
        }.getOrElse(Effect.none)
      case msg =>
        context.log.warn(s"msg: $msg is not processed")
        Effect.none
    }
  }

  private val logger = LoggerFactory.getLogger(getClass)

  private def executeOperation[E, R](
                                      context: akka.actor.typed.scaladsl.ActorContext[Command],
                                      stepPhase: TransactionPhase,
                                      step: SagaTransactionStep[E, R],
                                      transactionId: String,
                                      circuitBreaker: CircuitBreaker,
                                      replyTo: Option[ActorRef[StepResult[E, R]]]
                                    ): Unit = {
    import context.executionContext

    context.scheduleOnce(step.timeoutDuration, context.self, TimedOut(replyTo))

    val eventualStepResult: SagaParticipant.ParticipantEffect[RetryableOrNotException, R] = stepPhase match {
      case PreparePhase =>
        step.participant.prepare(transactionId)
      case CommitPhase =>
        step.participant.commit(transactionId)
      case CompensatePhase =>
        step.participant.compensate(transactionId)
    }

    circuitBreaker.withCircuitBreaker(eventualStepResult).onComplete {
      case scala.util.Success(result: Either[RetryableOrNotException, R]) =>
        context.self ! OperationResponse(result, replyTo)
      case scala.util.Failure(exception) =>
        logger.warn(s"$exception found while processing ${step}")
        context.self ! OperationResponse(Left(NonRetryableFailure(exception.getMessage)), replyTo)
    }
  }

  private def scheduleRetry[E, R](timers: TimerScheduler[Command], delay: FiniteDuration, replyTo: Option[ActorRef[StepResult[E, R]]]): Unit = {
    timers.startSingleTimer(RetryOperation(replyTo), delay)
  }

  private def calculateBackoffDelay(initialDelay: FiniteDuration, retryCount: Int): FiniteDuration = {
    initialDelay * math.pow(2, retryCount - 1).toLong
  }


  private def serializeActorRef(replyTo: Option[ActorRef[_]]) = {
    replyTo.map(_.path.toSerializationFormat).getOrElse("")
  }

}


==================================================
文件路径: app\net\imadz\infra\saga\handlers\StepExecutorEventHandler.scala
==================================================

package net.imadz.infra.saga.handlers

import net.imadz.infra.saga.SagaTransactionStep
import net.imadz.infra.saga.StepExecutor._

object StepExecutorEventHandler {
  def eventHandler[E, R]: (State[E, R], Event) => State[E, R] = { (state, event) =>
    event match {
      case ExecutionStarted(transactionId, step, replyTo) =>
        state.copy(transactionId = Some(transactionId),
          step = Some(step.asInstanceOf[SagaTransactionStep[E, R]]), status = Ongoing,
          replyTo = Some(replyTo))
      case OperationSucceeded(_) =>
        state.copy(status = Succeed)
      case OperationFailed(error) =>
        state.copy(status = Failed, lastError = Some(error))
      case RetryScheduled(_) =>
        state.copy(retries = state.retries + 1, status = Ongoing)

    }
  }


}


==================================================
文件路径: app\net\imadz\infra\saga\handlers\StepExecutorRecoveryHandler.scala
==================================================

package net.imadz.infra.saga.handlers

import akka.actor.typed.ActorRef
import akka.actor.typed.scaladsl.ActorContext
import akka.actor.typed.scaladsl.adapter.ClassicActorRefOps
import net.imadz.infra.saga.StepExecutor._
import net.imadz.infra.saga.SagaParticipant._

import scala.concurrent.Await
import scala.concurrent.duration.DurationInt

object StepExecutorRecoveryHandler {
  def onRecoveryCompleted[E, R](context: ActorContext[Command], state: State[E, R]): Unit = {

    val replyTo = state
      .replyTo.map(context.system.classicSystem.actorSelection)
      .map(_.resolveOne(3.seconds))
      .map(futureRef => Await.result(futureRef, 3.seconds).toTyped.asInstanceOf[ActorRef[StepResult[E, R]]])

    context.log.info(s"SAGA Transaction Step is Recovered on ${state}")
    state.status match {
      case Created | Succeed =>
        state.step.foreach { step =>
          context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | No recovery action for durability on status: ${state.status}")
        }
        ()
      case Failed =>
        state.lastError.zip(state.step).foreach { case (error, step) => error match {

          case RetryableFailure(msg) if state.retries < step.maxRetries =>
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | Take RetryOperation on RetryableFailure(${msg})")
            context.self ! RetryOperation(replyTo)
          case RetryableFailure(msg) =>
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | No RetryOperation needed on RetryableFailure(${msg}) since max retries reached.")
            ()
          case NonRetryableFailure(msg) =>
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | No RetryOperation needed on NonRetryableFailure(${msg}).")
            ()
        }
        }
      case Ongoing =>
        state.step.zip(state.transactionId).foreach { case (step, trxId) =>
          if (step.retryWhenRecoveredOngoing) {
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | Take RetryOperation on Ongoing state")

            context.self ! RecoverExecution(trxId, step, replyTo)
          } else {
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | No need to take RetryOperation on Ongoing state while retryWhenRecoveredOngoing is ${step.retryWhenRecoveredOngoing}")
          }
        }
    }
  }

}


==================================================
文件路径: app\net\imadz\infra\saga\repository\SagaTransactionCoordinatorRepositoryImpl.scala
==================================================

package net.imadz.infra.saga.repository

import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, EntityRef}
import net.imadz.common.CommonTypes.Id
import net.imadz.infra.saga.SagaTransactionCoordinator

import javax.inject.Inject

case class SagaTransactionCoordinatorRepositoryImpl @Inject()(sharding: ClusterSharding) extends TransactionCoordinatorRepository {
  override def findSagaTransactionCoordinator(sagaTransactionId: Id): EntityRef[SagaTransactionCoordinator.Command] =
    sharding.entityRefFor(SagaTransactionCoordinator.entityTypeKey, sagaTransactionId.toString)
}


==================================================
文件路径: app\net\imadz\infra\saga\repository\TransactionCoordinatorRepository.scala
==================================================

package net.imadz.infra.saga.repository

import akka.cluster.sharding.typed.scaladsl.EntityRef
import com.google.inject.ImplementedBy
import net.imadz.common.CommonTypes.Id
import net.imadz.infra.saga.SagaTransactionCoordinator

@ImplementedBy(classOf[SagaTransactionCoordinatorRepositoryImpl])
trait TransactionCoordinatorRepository {

  def findSagaTransactionCoordinator(sagaTransactionId: Id): EntityRef[SagaTransactionCoordinator.Command]
}


==================================================
文件路径: app\net\imadz\infra\saga\serialization\AkkaSerializationWrapper.scala
==================================================

package net.imadz.infra.saga.serialization

import akka.actor.ActorSystem
import akka.serialization.{SerializationExtension, Serializers}

case class AkkaSerializationWrapper(system: ActorSystem) {
  private val serialization = SerializationExtension(system)

  def serialize(obj: AnyRef): (Array[Byte], String) = {
    val serializer = serialization.findSerializerFor(obj)
    val bytes = serializer.toBinary(obj)
    val manifest = Serializers.manifestFor(serializer, obj)
    (bytes, manifest)
  }

  def deserialize(bytes: Array[Byte], manifest: String): AnyRef = {
    val deserializer = serialization.serializerFor(Class.forName(manifest))
    deserializer.fromBinary(bytes, Class.forName(manifest)).asInstanceOf[AnyRef]
  }
}

==================================================
文件路径: app\net\imadz\infra\saga\serialization\SagaSerializer.scala
==================================================

package net.imadz.infra.saga.serialization

import akka.actor.ExtendedActorSystem
import akka.serialization.{SerializationExtension, SerializerWithStringManifest}
import com.google.protobuf.ByteString
import net.imadz.infra.saga.SagaParticipant
import net.imadz.infra.saga.StepExecutor.{OperationResponse, OperationSucceeded}
import net.imadz.infra.saga.proto.saga_v2.{OperationFailedCommandPO, OperationSucceedCommandPO, OperationSucceededPO, RetryableOrNotExceptionPO}

class SagaSerializer(system: ExtendedActorSystem) extends SerializerWithStringManifest {

  private lazy val serialization = SerializationExtension(system)

  override def identifier: Int = 1000

  override def manifest(o: AnyRef): String = o.getClass.getName

  override def toBinary(o: AnyRef): Array[Byte] = o match {
    case OperationResponse(result, replyTo) =>
      result match {
        case Left(SagaParticipant.RetryableFailure(message)) =>
          OperationFailedCommandPO(Some(RetryableOrNotExceptionPO(isRetryable = true, message))).toByteArray
        case Left(SagaParticipant.NonRetryableFailure(message)) =>
          OperationFailedCommandPO(Some(RetryableOrNotExceptionPO(isRetryable = false, message = message))).toByteArray
        case Right(positiveResult: AnyRef) =>
          val serializer = serialization.findSerializerFor(positiveResult)
          OperationSucceedCommandPO(
            successMessageType = positiveResult.getClass.getName,
            success = ByteString.copyFrom(serializer.toBinary(positiveResult))
          ).toByteArray
      }

    case OperationSucceeded(result: AnyRef) =>
      val serializer = serialization.findSerializerFor(result)
      OperationSucceededPO(resultType = result.getClass.getName, result = ByteString.copyFrom(serializer.toBinary(result))).toByteArray
    case _ => throw new IllegalArgumentException(s"Cannot serialize ${o.getClass}")
  }

  override def fromBinary(bytes: Array[Byte], manifest: String): AnyRef = {
    manifest match {
      case className if className == classOf[OperationResponse[_, _]].getName =>
        try {
          val failedCommand = OperationFailedCommandPO.parseFrom(bytes)
          failedCommand.error match {
            case Some(exception) if exception.isRetryable =>
              OperationResponse(Left(SagaParticipant.RetryableFailure(exception.message)), None)
            case Some(exception) =>
              OperationResponse(Left(SagaParticipant.NonRetryableFailure(exception.message)), None)
            case None =>
              throw new IllegalArgumentException("Invalid OperationFailedCommandPO: missing exception")
          }
        } catch {
          case _: com.google.protobuf.InvalidProtocolBufferException =>
            // If it's not a failure, it must be a success
            val successCommand = OperationSucceedCommandPO.parseFrom(bytes)
            val resultClass = system.dynamicAccess.getClassFor[AnyRef](successCommand.successMessageType)
              .getOrElse(throw new ClassNotFoundException(s"Cannot find class ${successCommand.successMessageType}"))
            val resultSerializer = serialization.serializerFor(resultClass)
            val result = resultSerializer.fromBinary(successCommand.success.toByteArray, resultClass)
            OperationResponse(Right(result), None) // Note: We cannot reconstruct the ActorRef here
        }

      case className if className == classOf[OperationSucceeded[_]].getName =>
        val protoMessage = OperationSucceededPO.parseFrom(bytes)
        val resultClass = system.dynamicAccess.getClassFor[AnyRef](protoMessage.resultType)
          .getOrElse(throw new ClassNotFoundException(s"Cannot find class ${protoMessage.resultType}"))
        val resultSerializer = serialization.serializerFor(resultClass)
        val result = resultSerializer.fromBinary(protoMessage.result.toByteArray, resultClass)
        OperationSucceeded(result)

      case _ => throw new IllegalArgumentException(s"Cannot deserialize class $manifest")
    }
  }
}


==================================================
文件路径: app\net\imadz\infra\saga\serialization\SagaTransactionStepSerializer.scala
==================================================

package net.imadz.infra.saga.serialization

import akka.serialization.Serializer
import net.imadz.application.services.transactor.MoneyTransferSagaTransactor.{FromAccountParticipant, ToAccountParticipant}
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.iMadzError
import net.imadz.common.Id
import net.imadz.domain.values.Money
import net.imadz.infra.saga.SagaPhase.{CommitPhase, CompensatePhase, PreparePhase}
import net.imadz.infra.saga.SagaTransactionStep
import net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO.Participant.{FromAccount, ToAccount}
import net.imadz.infra.saga.proto.saga_v2.{SagaParticipantPO, SagaTransactionStepPO, TransactionPhasePO}
import net.imadz.infrastructure.persistence.ParticipantAdapter
import net.imadz.infrastructure.proto.credits.MoneyPO
import net.imadz.infrastructure.proto.saga_participant.{FromAccountParticipantPO, ToAccountParticipantPO}

import java.util.Currency
import scala.concurrent.ExecutionContext
import scala.concurrent.duration.DurationLong
import scala.util.{Failure, Success, Try}

case class SagaTransactionStepSerializer(repository: CreditBalanceRepository, ec: ExecutionContext) extends Serializer with ParticipantAdapter {

  implicit val executionContext: ExecutionContext = ec

  override def identifier: Int = 1234

  override def toBinary(o: AnyRef): Array[Byte] = o match {
    case step: SagaTransactionStep[_, _] => serializeSagaTransactionStep(step).toByteArray
    case _ => throw new IllegalArgumentException(s"Cannot serialize object of type ${o.getClass}")
  }

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef = {
    Try(SagaTransactionStepPO.parseFrom(bytes)).map(deserializeSagaTransactionStep) match {
      case Success(step) => step
      case Failure(e) => throw new RuntimeException(s"Failed to deserialize SagaTransactionStep: ${e.getMessage}")
    }
  }

  override def includeManifest: Boolean = false

  def serializeSagaTransactionStep(step: SagaTransactionStep[_, _]): SagaTransactionStepPO = {
    val participantPO = step.participant match {
      case FromAccountParticipant(fromUserId, amount, _) =>
        FromAccount(FromAccountParticipantPO(fromUserId.toString, Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))))
      case ToAccountParticipant(toUserId, amount, _) =>
        ToAccount(ToAccountParticipantPO(toUserId.toString, Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))))
    }

    SagaTransactionStepPO(
      stepId = step.stepId,
      phase = step.phase match {
        case PreparePhase => TransactionPhasePO.PREPARE_PHASE
        case CommitPhase => TransactionPhasePO.COMMIT_PHASE
        case CompensatePhase => TransactionPhasePO.COMPENSATE_PHASE
      },
      participant = Some(SagaParticipantPO(participantPO)),
      maxRetries = step.maxRetries,
      timeoutDurationMillis = step.timeoutDuration.toMillis,
      retryWhenRecoveredOngoing = step.retryWhenRecoveredOngoing
    )
  }

  def deserializeSagaTransactionStep(stepPO: SagaTransactionStepPO): SagaTransactionStep[iMadzError, String] = {
    val participant = stepPO.participant match {
      case Some(SagaParticipantPO(FromAccount(
      FromAccountParticipantPO(fromUserId, Some(MoneyPO(amount, currencyCode, _)), _)), _)) =>
        FromAccountParticipant(Id.of(fromUserId), Money(BigDecimal(amount), Currency.getInstance(currencyCode)), repository)
      case Some(SagaParticipantPO(ToAccount(ToAccountParticipantPO(toUserId, Some(MoneyPO(value, currency, _)), _)), _)) =>
        ToAccountParticipant(Id.of(toUserId), Money(BigDecimal(value), Currency.getInstance(currency)), repository)
      case _ => throw new IllegalArgumentException("Invalid participant type in SagaTransactionStepPO")
    }

    SagaTransactionStep[iMadzError, String](
      stepId = stepPO.stepId,
      phase = stepPO.phase match {
        case TransactionPhasePO.PREPARE_PHASE => PreparePhase
        case TransactionPhasePO.COMMIT_PHASE => CommitPhase
        case TransactionPhasePO.COMPENSATE_PHASE => CompensatePhase
      },
      participant = participant,
      maxRetries = stepPO.maxRetries,
      timeoutDuration = stepPO.timeoutDurationMillis.millis,
      retryWhenRecoveredOngoing = stepPO.retryWhenRecoveredOngoing
    )
  }

}


==================================================
文件路径: app\net\imadz\infrastructure\SuffixCollectionNames.scala
==================================================

package net.imadz.infrastructure

import akka.contrib.persistence.mongodb.CanSuffixCollectionNames

class SuffixCollectionNames extends CanSuffixCollectionNames{
  override def getSuffixFromPersistenceId(persistenceId: String): String = persistenceId match {
    // in this example, we remove any leading "-test" string from persistenceId passed as parameter
    // otherwise, we do not suffix our collection
    case _ => ""
  }

  override def validateMongoCharacters(input: String): String = {
    // According to mongoDB documentation,
    // forbidden characters in mongoDB collection names (Unix) are /\. "$
    // Forbidden characters in mongoDB collection names (Windows) are /\. "$*<>:|?
    // in this example, we replace each forbidden character with an underscore character
    val forbidden = List('/', '\\', '.', ' ', '\"', '$', '*', '<', '>', ':', '|', '?')

    input.map { c => if (forbidden.contains(c)) '_' else c }
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\bootstrap\CreditBalanceBootstrap.scala
==================================================

package net.imadz.infrastructure.bootstrap

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{Behavior, LogOptions, SupervisorStrategy}
import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, Entity, EntityContext}
import akka.persistence.typed.PersistenceId
import akka.persistence.typed.scaladsl.{EventSourcedBehavior, RetentionCriteria}
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.CreditBalanceAggregate.{CreditBalanceCommand, CreditBalanceEntityTypeKey}
import net.imadz.application.aggregates.behaviors.CreditBalanceBehaviors
import net.imadz.common.CommonTypes.Id
import net.imadz.common.Id
import net.imadz.domain.entities.CreditBalanceEntity
import net.imadz.domain.entities.behaviors.CreditBalanceEventHandler
import net.imadz.infrastructure.persistence.{CreditBalanceEventAdapter, CreditBalanceSnapshotAdapter}
import org.slf4j.LoggerFactory
import org.slf4j.event.Level

import scala.concurrent.duration.DurationInt

trait CreditBalanceBootstrap {

  def initCreditBalanceAggregate(sharding: ClusterSharding): Unit = {
    val behaviorFactory: EntityContext[CreditBalanceCommand] => Behavior[CreditBalanceCommand] = { context =>
      val i = math.abs(context.entityId.hashCode % CreditBalanceAggregate.tags.size)
      val selectedTag = CreditBalanceAggregate.tags(i)
      apply(Id.of(context.entityId), selectedTag)
    }

    sharding.init(Entity(CreditBalanceAggregate.CreditBalanceEntityTypeKey)(behaviorFactory))
  }

  private def apply(userId: Id, tag: String): Behavior[CreditBalanceCommand] =
    Behaviors.logMessages(LogOptions().withLogger(LoggerFactory.getLogger("iMadz")).withLevel(Level.INFO),
      Behaviors
        .setup { actorContext =>
          EventSourcedBehavior(
            persistenceId = PersistenceId(CreditBalanceEntityTypeKey.name, userId.toString),
            emptyState = CreditBalanceEntity.empty(userId),
            commandHandler = CreditBalanceBehaviors.apply,
            eventHandler = CreditBalanceEventHandler.apply
          ).withTagger(_ => Set(tag))
            .withRetention(RetentionCriteria.snapshotEvery(numberOfEvents = 100, keepNSnapshots = 3))
            .onPersistFailure(SupervisorStrategy.restartWithBackoff(200.millis, 5.seconds, 0.1).withStashCapacity(100))
            .eventAdapter(new CreditBalanceEventAdapter)
            .snapshotAdapter(new CreditBalanceSnapshotAdapter)
        })
}


==================================================
文件路径: app\net\imadz\infrastructure\bootstrap\MonthlyIncomeAndExpenseBootstrap.scala
==================================================

package net.imadz.infrastructure.bootstrap

import akka.actor.typed.ActorSystem
import akka.cluster.sharding.typed.ShardedDaemonProcessSettings
import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, ShardedDaemonProcess}
import akka.projection.ProjectionBehavior
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.projection.MonthlyIncomeAndExpenseSummaryProjection.{createProjection, projectionName}
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository

trait MonthlyIncomeAndExpenseBootstrap {
  def initMonthlySummaryProjection(system: ActorSystem[_], sharding: ClusterSharding, repository: MonthlyIncomeAndExpenseSummaryRepository): Unit = {
    ShardedDaemonProcess(system).init(
      name = projectionName,
      numberOfInstances = CreditBalanceAggregate.tags.size,
      behaviorFactory = index => ProjectionBehavior(createProjection(system, sharding, index, repository)),
      settings = ShardedDaemonProcessSettings(system),
      stopMessage = Some(ProjectionBehavior.Stop)
    )
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\bootstrap\SagaTransactionCoordinatorBootstrap.scala
==================================================

package net.imadz.infrastructure.bootstrap

import akka.actor.typed.scaladsl.{ActorContext, Behaviors}
import akka.actor.typed.{Behavior, LogOptions, SupervisorStrategy}
import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, Entity, EntityContext}
import akka.persistence.typed.PersistenceId
import akka.persistence.typed.scaladsl.{EventSourcedBehavior, RetentionCriteria}
import akka.util.Timeout
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id
import net.imadz.common.Id
import net.imadz.infra.saga.SagaTransactionCoordinator.entityTypeKey
import net.imadz.infra.saga.{ForSaga, SagaTransactionCoordinator, StepExecutor}
import net.imadz.infrastructure.persistence.SagaTransactionCoordinatorEventAdapter
import org.slf4j.LoggerFactory
import org.slf4j.event.Level

import scala.concurrent.duration.DurationInt

trait SagaTransactionCoordinatorBootstrap extends ForSaga {

  import scala.concurrent.ExecutionContext.Implicits.global

  def initSagaTransactionCoordinatorAggregate(sharding: ClusterSharding, repository: CreditBalanceRepository): Unit = {
    val behaviorFactory: EntityContext[SagaTransactionCoordinator.Command] => Behavior[SagaTransactionCoordinator.Command] = { context =>
      val i = math.abs(context.entityId.hashCode % SagaTransactionCoordinator.tags.size)
      val selectedTag = SagaTransactionCoordinator.tags(i)
      apply(Id.of(context.entityId), selectedTag, repository)
    }

    sharding.init(Entity(SagaTransactionCoordinator.entityTypeKey)(behaviorFactory))
  }

  //TODO: Bad Smell
  private def apply(transactionId: Id, tag: String, repository: CreditBalanceRepository): Behavior[SagaTransactionCoordinator.Command] = {
    implicit val askTimeout: Timeout = Timeout(30.seconds)
    Behaviors.logMessages(LogOptions().withLogger(LoggerFactory.getLogger("iMadz")).withLevel(Level.INFO),
      Behaviors
        .setup { actorContext =>
          EventSourcedBehavior(
            persistenceId = PersistenceId(entityTypeKey.name, transactionId.toString),
            emptyState = SagaTransactionCoordinator.State.apply(),
            commandHandler = SagaTransactionCoordinator.commandHandler(actorContext, (key, step) => createStepExecutor(actorContext, key, repository)),
            eventHandler = SagaTransactionCoordinator.eventHandler
          ).withTagger(_ => Set(tag))
            .withRetention(RetentionCriteria.snapshotEvery(numberOfEvents = 100, keepNSnapshots = 3))
            .onPersistFailure(SupervisorStrategy.restartWithBackoff(200.millis, 5.seconds, 0.1).withStashCapacity(100))
            .eventAdapter(SagaTransactionCoordinatorEventAdapter(actorContext.system, repository, global))
        })
  }


  private def createStepExecutor(context: ActorContext[SagaTransactionCoordinator.Command], key: String, creditBalanceRepository: CreditBalanceRepository) = {
    context.spawn(StepExecutor[Any, Any](creditBalanceRepository)(
      PersistenceId.ofUniqueId(key),
      defaultMaxRetries = 5,
      initialRetryDelay = 100.millis,
      circuitBreakerSettings = StepExecutor.CircuitBreakerSettings(5, 30.seconds, 30.seconds)
    ), key)
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\persistence\CreditBalanceEventAdapter.scala
==================================================

package net.imadz.infrastructure.persistence

import akka.persistence.typed.{EventAdapter, EventSeq}
import net.imadz.common.Id
import net.imadz.domain.entities.CreditBalanceEntity._
import net.imadz.domain.values.Money
import net.imadz.infrastructure.proto.credits.{CreditBalanceEventPO => CreditEventPO, MoneyPO}

import java.util.Currency

class CreditBalanceEventAdapter extends EventAdapter[CreditBalanceEvent, CreditEventPO.Event] {

  override def toJournal(e: CreditBalanceEvent): CreditEventPO.Event =
    e match {
      case BalanceChanged(update, timestamp) =>
        CreditEventPO.Event.BalanceChanged(
          net.imadz.infrastructure.proto.credits.BalanceChanged(
            Some(MoneyPO(update.amount.doubleValue, update.currency.getCurrencyCode)),
            timestamp
          )
        )
      case FundsReserved(transferId, amount) =>
        CreditEventPO.Event.FundsReserved(
          net.imadz.infrastructure.proto.credits.FundsReserved(
            transferId.toString,
            Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
          )
        )
      case FundsDeducted(transferId, amount) =>
        CreditEventPO.Event.FundsDeducted(
          net.imadz.infrastructure.proto.credits.FundsDeducted(
            transferId.toString,
            Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
          )
        )
      case ReservationReleased(transferId, amount) =>
        CreditEventPO.Event.ReservationReleased(
          net.imadz.infrastructure.proto.credits.ReservationReleased(
            transferId.toString,
            Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
          )
        )
      case IncomingCreditsRecorded(transferId, amount) =>
        CreditEventPO.Event.IncomingCreditsRecorded(
          net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded(
            transferId.toString,
            Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
          )
        )
      case IncomingCreditsCommited(transferId) =>
        CreditEventPO.Event.IncomingCreditsCommited(
          net.imadz.infrastructure.proto.credits.IncomingCreditsCommited(
            transferId.toString
          )
        )
      case IncomingCreditsCanceled(transferId) =>
        CreditEventPO.Event.IncomingCreditsCanceled(
          net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled(
            transferId.toString
          )
        )
    }

  override def manifest(event: CreditBalanceEvent): String = event.getClass.getName

  override def fromJournal(p: CreditEventPO.Event, manifest: String): EventSeq[CreditBalanceEvent] =
    p match {
      case CreditEventPO.Event.BalanceChanged(po) =>
        EventSeq.single(BalanceChanged(
          po.update.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get, po.timestamp)
        )
      case CreditEventPO.Event.FundsReserved(po) =>
        EventSeq.single(FundsReserved(
          Id.of(po.transferId),
          po.amount.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get
        ))
      case CreditEventPO.Event.FundsDeducted(po) =>
        EventSeq.single(FundsDeducted(
          Id.of(po.transferId),
          po.amount.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get
        ))
      case CreditEventPO.Event.ReservationReleased(po) =>
        EventSeq.single(ReservationReleased(
          Id.of(po.transferId),
          po.amount.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get
        ))
      case CreditEventPO.Event.IncomingCreditsRecorded(po) =>
        EventSeq.single(IncomingCreditsRecorded(
          Id.of(po.transferId),
          po.amount.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get
        ))
      case CreditEventPO.Event.IncomingCreditsCommited(po) =>
        EventSeq.single(IncomingCreditsCommited(
          Id.of(po.transferId)
        ))
      case CreditEventPO.Event.IncomingCreditsCanceled(po) =>
        EventSeq.single(IncomingCreditsCanceled(
          Id.of(po.transferId)
        ))
      case _ =>
        EventSeq.empty
    }
}

==================================================
文件路径: app\net\imadz\infrastructure\persistence\CreditBalanceSnapshotAdapter.scala
==================================================

package net.imadz.infrastructure.persistence

import akka.persistence.typed.SnapshotAdapter
import net.imadz.common.Id
import net.imadz.domain.entities.CreditBalanceEntity._
import net.imadz.domain.values.Money
import net.imadz.infrastructure.proto.credits._

import java.util.{Currency, UUID}

class CreditBalanceSnapshotAdapter extends SnapshotAdapter[CreditBalanceState] {

  override def toJournal(state: CreditBalanceState): Any = {
    val accountBalance = state.accountBalance.map { case (k, v) =>
      k -> MoneyPO(v.amount.doubleValue, v.currency.getCurrencyCode)
    }
    val reservedAmount = state.reservedAmount.map { case (k, v) =>
      k.toString -> MoneyPO(v.amount.doubleValue, v.currency.getCurrencyCode)
    }
    val incomingCredits = state.incomingCredits.map { case (k, v) =>
      k.toString -> MoneyPO(v.amount.doubleValue, v.currency.getCurrencyCode)
    }
    CreditBalanceStatePO(
      userId = state.userId.toString,
      accountBalance = accountBalance,
      reservedAmount = reservedAmount,
      incomingCredits = incomingCredits
    )
  }

  override def fromJournal(from: Any): CreditBalanceState = from match {
    case po: CreditBalanceStatePO =>
      val accountBalance = po.accountBalance.map { case (k, v) =>
        k -> Money(v.amount, Currency.getInstance(v.currency))
      }
      val reservedAmount = po.reservedAmount.map { case (k, v) =>
        Id.of(k) -> Money(v.amount, Currency.getInstance(v.currency))
      }
      val incomingCredits = po.incomingCredits.map { case (k, v) =>
        Id.of(k) -> Money(v.amount, Currency.getInstance(v.currency))
      }
      CreditBalanceState(
        userId = UUID.fromString(po.userId),
        accountBalance = accountBalance,
        reservedAmount = reservedAmount,
        incomingCredits = incomingCredits
      )
    case unknown => throw new IllegalStateException(s"Unknown journal type: ${unknown.getClass.getName}")
  }
}

==================================================
文件路径: app\net\imadz\infrastructure\persistence\ParticipantAdapter.scala
==================================================

package net.imadz.infrastructure.persistence

import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.application.services.transactor.MoneyTransferSagaTransactor.{FromAccountParticipant, ToAccountParticipant}
import net.imadz.common.CommonTypes.iMadzError
import net.imadz.common.Id
import net.imadz.domain.values.Money
import net.imadz.infra.saga.proto.saga_v2.{SagaParticipantPO => ParticipantPO}
import net.imadz.infra.saga.{ForSaga, SagaParticipant}
import net.imadz.infrastructure.proto.credits.MoneyPO
import net.imadz.infrastructure.proto.saga_participant.{FromAccountParticipantPO, ToAccountParticipantPO}

import java.util.Currency
import scala.concurrent.ExecutionContext

trait ParticipantAdapter extends ForSaga {
  def repository: CreditBalanceRepository

  def ec: ExecutionContext

  def deserializeParticipant(participantPO: ParticipantPO): SagaParticipant[iMadzError, String] = participantPO.participant match {
    case ParticipantPO.Participant.FromAccount(fromAccountPO) =>
      FromAccountParticipant(
        fromUserId = Id.of(fromAccountPO.fromUserId),
        amount = Money(
          amount = BigDecimal(fromAccountPO.amount.get.amount),
          currency = Currency.getInstance(fromAccountPO.amount.get.currency)
        ),
        repo = repository)(ec)

    case ParticipantPO.Participant.ToAccount(fromAccountPO) =>
      ToAccountParticipant(
        toUserId = Id.of(fromAccountPO.toUserId),
        amount = Money(
          amount = BigDecimal(fromAccountPO.amount.get.amount),
          currency = Currency.getInstance(fromAccountPO.amount.get.currency)
        ),
        repo = repository)(ec)
  }

  def serializeParticipant(participant: SagaParticipant[iMadzError, String]): Option[ParticipantPO] = participant match {
    case FromAccountParticipant(fromUserId, amount, _) =>
      Some(ParticipantPO(
        participant = ParticipantPO.Participant.FromAccount(
          FromAccountParticipantPO(
            fromUserId = fromUserId.toString,
            amount = Some(MoneyPO(
              amount = amount.amount.longValue,
              currency = amount.currency.getCurrencyCode
            ))
          )
        )
      ))

    case ToAccountParticipant(toUserId, amount, _) =>
      Some(ParticipantPO(
        participant = ParticipantPO.Participant.ToAccount(
          ToAccountParticipantPO(
            toUserId = toUserId.toString,
            amount = Some(MoneyPO(
              amount = amount.amount.longValue,
              currency = amount.currency.getCurrencyCode
            ))
          )
        )
      ))

    case _ => None
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\persistence\SagaTransactionCoordinatorEventAdapter.scala
==================================================

package net.imadz.infrastructure.persistence

import akka.actor.typed.ActorSystem
import akka.persistence.typed.{EventAdapter, EventSeq}
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.infra.saga.SagaPhase.{CommitPhase, CompensatePhase, PreparePhase}
import net.imadz.infra.saga.proto.saga_v2._
import net.imadz.infra.saga.serialization.SagaTransactionStepSerializer
import net.imadz.infra.saga.{ForSaga, SagaPhase, SagaTransactionCoordinator, serialization}

import scala.concurrent.ExecutionContext

case class SagaTransactionCoordinatorEventAdapter(system: ActorSystem[Nothing], repository: CreditBalanceRepository, ec: ExecutionContext)
  extends EventAdapter[SagaTransactionCoordinator.Event, SagaTransactionCoordinatorEventPO.Event]
  with ForSaga {
  private val stepSerializer: SagaTransactionStepSerializer = serialization.SagaTransactionStepSerializer(repository = repository, ec = ec)

  override def toJournal(e: SagaTransactionCoordinator.Event): SagaTransactionCoordinatorEventPO.Event = e match {
    case SagaTransactionCoordinator.TransactionStarted(transactionId, steps) => SagaTransactionCoordinatorEventPO.Event.Started(TransactionStartedPO(transactionId = transactionId, steps = steps.map(stepSerializer.serializeSagaTransactionStep)))
    case SagaTransactionCoordinator.PhaseSucceeded(phase) => SagaTransactionCoordinatorEventPO.Event.PhaseSucceeded(PhaseSucceededPO(serializePhase(phase)))
    case SagaTransactionCoordinator.PhaseFailed(phase) => SagaTransactionCoordinatorEventPO.Event.PhaseFailed(PhaseFailedPO(serializePhase(phase)))
    case SagaTransactionCoordinator.TransactionCompleted(transactionId) => SagaTransactionCoordinatorEventPO.Event.TransactionCompleted(TransactionCompletedPO(transactionId))
    case SagaTransactionCoordinator.TransactionFailed(transactionId, reason) => SagaTransactionCoordinatorEventPO.Event.TransactionFailed(TransactionFailedPO(transactionId, reason))
  }


  private def serializePhase(phase: SagaPhase.TransactionPhase) = {
    phase match {
      case PreparePhase => TransactionPhasePO.PREPARE_PHASE
      case CommitPhase => TransactionPhasePO.COMMIT_PHASE
      case CompensatePhase => TransactionPhasePO.COMPENSATE_PHASE
    }
  }

  private def deserializePhase(phase: TransactionPhasePO) = phase match {
    case TransactionPhasePO.PREPARE_PHASE => SagaPhase.PreparePhase
    case TransactionPhasePO.COMMIT_PHASE => SagaPhase.CommitPhase
    case TransactionPhasePO.COMPENSATE_PHASE => SagaPhase.CompensatePhase
    case TransactionPhasePO.Unrecognized(_) =>
      throw new IllegalArgumentException(s"Unrecognized transaction phase: $phase")
  }

  override def manifest(event: SagaTransactionCoordinator.Event): String = event.getClass.getName

  override def fromJournal(p: SagaTransactionCoordinatorEventPO.Event, manifest: String): EventSeq[SagaTransactionCoordinator.Event] = {
    val event = p match {
      case SagaTransactionCoordinatorEventPO.Event.Started(TransactionStartedPO(transactionId, steps, _)) =>
        SagaTransactionCoordinator.TransactionStarted(
          transactionId,
          steps.map(stepSerializer.deserializeSagaTransactionStep).toList
        )
      case SagaTransactionCoordinatorEventPO.Event.PhaseSucceeded(PhaseSucceededPO(phase, _)) =>
        SagaTransactionCoordinator.PhaseSucceeded(deserializePhase(phase))
      case SagaTransactionCoordinatorEventPO.Event.PhaseFailed(PhaseFailedPO(phase, _)) =>
        SagaTransactionCoordinator.PhaseFailed(deserializePhase(phase))
      case SagaTransactionCoordinatorEventPO.Event.TransactionCompleted(TransactionCompletedPO(transactionId, _)) =>
        SagaTransactionCoordinator.TransactionCompleted(transactionId)
      case SagaTransactionCoordinatorEventPO.Event.TransactionFailed(TransactionFailedPO(transactionId, reason, _)) =>
        SagaTransactionCoordinator.TransactionFailed(transactionId, reason)
      case _ =>
        throw new IllegalArgumentException(s"Unrecognized event: $p")
    }
    EventSeq.single(event)
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\persistence\StepExecutorEventAdapter.scala
==================================================

package net.imadz.infrastructure.persistence

import akka.persistence.typed.{EventAdapter, EventSeq}
import com.google.protobuf.ByteString
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.infra.saga.SagaParticipant._
import net.imadz.infra.saga.SagaPhase.{CommitPhase, CompensatePhase, PreparePhase}
import net.imadz.infra.saga._
import net.imadz.infra.saga.proto.saga_v2._
import net.imadz.infra.saga.serialization.{AkkaSerializationWrapper, SagaTransactionStepSerializer}

import scala.concurrent.ExecutionContext
import scala.concurrent.duration.DurationLong

case class StepExecutorEventAdapter(serialization: AkkaSerializationWrapper, repository: CreditBalanceRepository, ec: ExecutionContext)
  extends EventAdapter[StepExecutor.Event, StepExecutorEventPO.Event]
  with ForSaga {
  private val stepSerializer: SagaTransactionStepSerializer = SagaTransactionStepSerializer(repository = repository, ec = ec)

  override def manifest(event: StepExecutor.Event): String = event.getClass.getName

  override def toJournal(e: StepExecutor.Event): StepExecutorEventPO.Event = e match {
    case StepExecutor.ExecutionStarted(transactionId, step, replyToPath) =>
      val stepPO = stepSerializer.serializeSagaTransactionStep(step)
      StepExecutorEventPO.Event.Started(ExecutionStartedPO(transactionId, Some(stepPO), replyToPath))

    case StepExecutor.OperationSucceeded(result) =>
      // TODO FIX
      val (bytes, manifest) = serialization.serialize(result.asInstanceOf[AnyRef])
      StepExecutorEventPO.Event.Succeed(OperationSucceededPO(result.getClass.getName, ByteString.copyFrom(bytes)))

    case StepExecutor.OperationFailed(error) =>
      val errorPO = RetryableOrNotExceptionPO(error.isInstanceOf[RetryableFailure], error.message)
      StepExecutorEventPO.Event.Failed(OperationFailedPO(Some(errorPO)))

    case StepExecutor.RetryScheduled(retryCount) =>
      StepExecutorEventPO.Event.Rescheduled(RetryScheduledPO(retryCount))
  }

  override def fromJournal(p: StepExecutorEventPO.Event, manifest: String): EventSeq[StepExecutor.Event] = {
    val event = p match {
      case StepExecutorEventPO.Event.Started(started) =>
        val step = started.transactionStep.map { stepPO =>
          SagaTransactionStep(
            stepId = stepPO.stepId,
            phase = stepPO.phase match {
              case TransactionPhasePO.PREPARE_PHASE => PreparePhase
              case TransactionPhasePO.COMMIT_PHASE => CommitPhase
              case TransactionPhasePO.COMPENSATE_PHASE => CompensatePhase
              case _ => throw new IllegalArgumentException(s"Unknown phase: ${stepPO.phase}")
            },
            participant = stepSerializer.deserializeSagaTransactionStep(stepPO).asInstanceOf[SagaParticipant[_, _]],
            maxRetries = stepPO.maxRetries,
            timeoutDuration = stepPO.timeoutDurationMillis.milliseconds,
            retryWhenRecoveredOngoing = stepPO.retryWhenRecoveredOngoing
          )
        }.getOrElse(throw new IllegalArgumentException("TransactionStep is missing"))
        StepExecutor.ExecutionStarted(started.transactionId, step, started.replyToPath)

      case StepExecutorEventPO.Event.Succeed(OperationSucceededPO(resultType, resultBytes, _)) =>
        val result = serialization.deserialize(resultBytes.toByteArray, resultType)
        StepExecutor.OperationSucceeded(result)

      case StepExecutorEventPO.Event.Failed(failed) =>
        val error = failed.error.map { errorPO =>
          if (errorPO.isRetryable) RetryableFailure(errorPO.message)
          else NonRetryableFailure(errorPO.message)
        }.getOrElse(throw new IllegalArgumentException("Error is missing"))
        StepExecutor.OperationFailed(error)

      case StepExecutorEventPO.Event.Rescheduled(rescheduled) =>
        StepExecutor.RetryScheduled(rescheduled.retryCount)
    }
    EventSeq.single(event)
  }
}

==================================================
文件路径: app\net\imadz\infrastructure\repositories\aggregate\CreditBalanceRepositoryImpl.scala
==================================================

package net.imadz.infrastructure.repositories.aggregate

import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, EntityRef}
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id

import javax.inject.Inject

case class CreditBalanceRepositoryImpl @Inject()(sharding: ClusterSharding) extends CreditBalanceRepository {

  override def findCreditBalanceByUserId(userId: Id): EntityRef[CreditBalanceAggregate.CreditBalanceCommand] =
    sharding.entityRefFor(CreditBalanceAggregate.CreditBalanceEntityTypeKey, userId.toString)
}


==================================================
文件路径: app\net\imadz\infrastructure\repositories\projection\MonthlyIncomeAndExpenseSummaryRepositoryImpl.scala
==================================================

package net.imadz.infrastructure.repositories.projection

import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryTable.MonthlyIncomeAndExpenseSummary
import scalikejdbc._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future


class MonthlyIncomeAndExpenseSummaryRepositoryImpl extends MonthlyIncomeAndExpenseSummaryRepository {

  override def filterByPeriodLCRO(userId: String, startFromYear: Int, startFromMonth: Int, untilYear: Int, untilMonth: Int): Future[List[MonthlyIncomeAndExpenseSummary]] = Future {
    DB readOnly { implicit session =>
      sql"""
        SELECT user_id, income, expense, year, month
        FROM monthly_income_and_expense_summary
        WHERE user_id = ${userId}
          AND ((year > ${startFromYear}) OR (year = ${startFromYear} AND month >= ${startFromMonth}))
          AND ((year < ${untilYear}) OR (year = ${untilYear} AND month <= ${untilMonth}))
        ORDER BY year, month
      """
        .map(rs => MonthlyIncomeAndExpenseSummary(
          userId = rs.string("user_id"),
          income = rs.bigDecimal("income"),
          expense = rs.bigDecimal("expense"),
          year = rs.int("year"),
          month = rs.int("month")
        )).list.apply()
    }
  }

  override def updateIncome(userId: String, amount: BigDecimal, year: Int, month: Int, day: Int): Unit = {
    DB localTx { implicit session =>
      sql"""
        INSERT INTO monthly_income_and_expense_summary (user_id, income, year, month, day)
        VALUES (${userId}, ${amount}, ${year}, ${month}, ${day})
        ON DUPLICATE KEY UPDATE
        income = income + VALUES(income)
      """.update.apply()
    }
  }

  override def updateExpense(userId: String, amount: BigDecimal, year: Int, month: Int, day: Int): Unit = {
    DB localTx { implicit session =>
      sql"""
        INSERT INTO monthly_income_and_expense_summary (user_id, expense, year, month, day)
        VALUES (${userId}, ${amount}, ${year}, ${month}, ${day})
        ON DUPLICATE KEY UPDATE
        expense = expense + VALUES(expense)
      """.update.apply()
    }
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\repositories\service\MoneyTransferTransactionRepositoryImpl.scala
==================================================

package net.imadz.infrastructure.repositories.service

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.scaladsl.adapter.ClassicActorSystemOps
import akka.actor.typed.{ActorRef, ActorSystem, Scheduler}
import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.application.services.transactor.MoneyTransferSagaTransactor.MoneyTransferTransactionCommand
import net.imadz.application.services.transactor.{MoneyTransferSagaTransactor, MoneyTransferSagaTransactorBehaviors, MoneyTransferTransactionRepository}
import net.imadz.common.CommonTypes.Id
import net.imadz.infra.saga.SagaTransactionCoordinator
import play.api.Application

import javax.inject.Inject
import scala.concurrent.ExecutionContext

class MoneyTransferTransactionRepositoryImpl @Inject()(sharding: ClusterSharding, app: Application,
                                                       repository: CreditBalanceRepository) extends MoneyTransferTransactionRepository {
  val system: ActorSystem[Nothing] = app.actorSystem.toTyped
  implicit val ec: ExecutionContext = system.executionContext
  implicit val scheduler: Scheduler = system.scheduler

  override def findTransactionById(transactionId: Id): ActorRef[MoneyTransferSagaTransactor.MoneyTransferTransactionCommand] = {
    val coordinator = sharding.entityRefFor(SagaTransactionCoordinator.entityTypeKey, transactionId.toString)
    system.systemActorOf(
      Behaviors.setup[MoneyTransferTransactionCommand] { context =>
        MoneyTransferSagaTransactorBehaviors.apply(context,
          coordinator, repository)
      },
      s"moneyTransferActor-$transactionId"
    )
  }
}

==================================================
文件路径: app\protobuf\credits.proto
==================================================

syntax = "proto3";

package net.imadz.infrastructure.proto;

// Define the Money type
message MoneyPO {
  double amount = 1;
  string currency = 2;
}

// Define the BalanceChanged event
message BalanceChanged {
  MoneyPO update = 1;
  int64 timestamp = 2;
}

// Define the FundsReserved event
message FundsReserved {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the FundsDeducted event
message FundsDeducted {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the ReservationReleased event
message ReservationReleased {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the IncomingCreditsRecorded event
message IncomingCreditsRecorded {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the IncomingCreditsCommited event
message IncomingCreditsCommited {
  string transferId = 1;
}

// Define the IncomingCreditsCanceled event
message IncomingCreditsCanceled {
  string transferId = 1;
}

// Define the CreditBalanceEvent union
message CreditBalanceEventPO {
  oneof event {
    BalanceChanged balanceChanged = 1;
    FundsReserved fundsReserved = 2;
    FundsDeducted fundsDeducted = 3;
    ReservationReleased reservationReleased = 4;
    IncomingCreditsRecorded incomingCreditsRecorded = 5;
    IncomingCreditsCommited incomingCreditsCommited = 6;
    IncomingCreditsCanceled incomingCreditsCanceled = 7;
  }
}

// Define the CreditBalanceState snapshot
message CreditBalanceStatePO {
  string userId = 1; // UUID can be represented as a string
  map<string, MoneyPO> accountBalance = 2;
  map<string, MoneyPO> reservedAmount = 3;
  map<string, MoneyPO> incomingCredits = 4;
}

==================================================
文件路径: app\protobuf\saga_participant.proto
==================================================

syntax = "proto3";
import "credits.proto";

package net.imadz.infrastructure.proto;

// Represents a participant that handles the from account in a transaction
message FromAccountParticipantPO {
  string from_user_id = 1;
  net.imadz.infrastructure.proto.MoneyPO amount = 2;
}

message ToAccountParticipantPO {
  string to_user_id = 1;
  net.imadz.infrastructure.proto.MoneyPO amount = 2;
}

==================================================
文件路径: app\protobuf\saga_v2.proto
==================================================

syntax = "proto3";

import "saga_participant.proto";

package net.imadz.infra.saga;

option java_multiple_files = true;
option java_package = "net.imadz.infra.saga.proto";

// Enums
enum TransactionPhasePO {
  PREPARE_PHASE = 0;
  COMMIT_PHASE = 1;
  COMPENSATE_PHASE = 2;
}

enum StepStatusPO {
  CREATED = 0;
  ONGOING = 1;
  SUCCEED = 2;
  FAILED = 3;
}

message SagaParticipantPO {
   oneof participant {
      net.imadz.infrastructure.proto.FromAccountParticipantPO fromAccount = 1;
      net.imadz.infrastructure.proto.ToAccountParticipantPO toAccount = 2;
   }
}

// Messages
message SagaTransactionStepPO {
  string step_id = 1;
  TransactionPhasePO phase = 2;
  int32 max_retries = 3;
  int64 timeout_duration_millis = 4;
  bool retry_when_recovered_ongoing = 5;
  SagaParticipantPO participant = 6;
  string participant_type = 7;// This will be used to identify the participant implementation
}

message StepStatePO {
  SagaTransactionStepPO step = 1;
  string transaction_id = 2;
  StepStatusPO status = 3;
  int32 retries = 4;
  RetryableOrNotExceptionPO last_error = 5;
  bool circuit_breaker_open = 6;
  string replyToPath = 7;
}

message RetryableOrNotExceptionPO {
  bool is_retryable = 1;
  string message = 2;
}

// Events
message ExecutionStartedPO {
  string transaction_id = 1;
  SagaTransactionStepPO transaction_step = 2;
  string replyToPath = 3;
}

message OperationSucceededPO {
  string resultType = 1;
  bytes result = 2; // Use bytes to store serialized result
}

message OperationFailedPO {
  RetryableOrNotExceptionPO error = 1;
}

message RetryScheduledPO {
  int32 retry_count = 1;
}

message StepExecutorEventPO {
  oneof event {
    ExecutionStartedPO started = 1;
    OperationSucceededPO succeed = 2;
    OperationFailedPO failed = 3;
    RetryScheduledPO rescheduled = 4;
  }
}

// Commands
message StartCommandPO {
  string transaction_id = 1;
  SagaTransactionStepPO saga_step = 2;
  string replyToPath = 3;
}

message RecoverExecutionCommandPO {
  string transaction_id = 1;
  SagaTransactionStepPO saga_step = 2;
}

message OperationSucceedCommandPO {
    string successMessageType = 1;
    bytes success = 2;
}

message OperationFailedCommandPO {
   RetryableOrNotExceptionPO error = 1;
}

message OperationResponseCommandPO {
  oneof result {
    OperationSucceedCommandPO succeed = 1;
    OperationFailedCommandPO error = 2;
  }
}

message RetryOperationCommandPO {}

message TimedOutCommandPO {}

// Coordinator's Proto

enum CoordinatorStatusPO {
  TRANSACTION_CREATED = 0;
  TRANSACTION_IN_PROGRESS = 1;
  TRANSACTION_COMPLETED = 2;
  TRANSACTION_FAILED = 3;
}

// Commands
message StartTransactionPO {
  string transaction_id = 1;
  repeated SagaTransactionStepPO steps = 2;
}

message PhaseCompletedPO {
  TransactionPhasePO phase = 1;
  repeated PhaseResultPO results = 2;
}

message PhaseFailurePO {
  TransactionPhasePO phase = 1;
  string error_message = 2;
  bool is_retryable = 3;
}

message PhaseResultPO {
  oneof result {
    string error = 1;
    bytes success = 2;
  }
}

// Events
message TransactionStartedPO {
  string transaction_id = 1;
  repeated SagaTransactionStepPO steps = 2;
}

message PhaseSucceededPO {
  TransactionPhasePO phase = 1;
}

message PhaseFailedPO {
  TransactionPhasePO phase = 1;
}

message TransactionCompletedPO {
  string transaction_id = 1;
}

message TransactionFailedPO {
  string transaction_id = 1;
  string reason = 2;
}

message SagaTransactionCoordinatorEventPO {
  oneof event {
    TransactionStartedPO started = 1;
    PhaseSucceededPO phaseSucceeded = 2;
    PhaseFailedPO phaseFailed = 3;
    TransactionCompletedPO transactionCompleted = 4;
    TransactionFailedPO transactionFailed = 5;
  }
}

// State
message CoordinatorStatePO {
  string transaction_id = 1;
  repeated SagaTransactionStepPO steps = 2;
  TransactionPhasePO current_phase = 3;
  CoordinatorStatusPO status = 4;
}

==================================================
文件路径: app\protobuf\saga_v2_test.proto
==================================================

syntax = "proto3";

package net.imadz.infra.saga;

option java_multiple_files = true;
option java_package = "net.imadz.infra.saga.proto";

// Participant definitions for testing
message SuccessfulParticipant {}

message RetryingParticipant {
  int32 succeed_after = 1;
}

message TimeoutParticipant {}

message AlwaysFailingParticipant {}

message NonRetryableFailingParticipant {}



==================================================
文件路径: app\protobuf\transactions.proto
==================================================

syntax = "proto3";
import "credits.proto";

package net.imadz.infrastructure.proto;

// Define the Id type
message string {
  string value = 1;
}

// Define the Money type


// Define the TransactionStatus enum
enum TransactionStatusPO {
  UNKNOWN = 0;
  NEW = 1;
  INITIATED = 2;
  PREPARED = 3;
  COMPLETED = 4;
  FAILED = 5;
}

// Define the Failed status message
message FailedStatusPO {
  string reason = 1;
}

// Define the TransactionStatus union
message TransactionStatusMessagePO {
  TransactionStatusPO status = 1;
  oneof details {
    FailedStatusPO failed = 2;
  }
}

// Define the TransactionState message
message TransactionStatePO {
  string id = 1;
  string fromUserId = 2;
  string toUserId = 3;
  MoneyPO amount = 4;
  TransactionStatusMessagePO status = 5;
}

// Define the TransactionEvent union
message TransactionEventPO {
  oneof event {
    TransactionInitiatedPO initiated = 1;
    TransactionPreparedPO prepared = 2;
    TransactionCompletedPO completed = 3;
    TransactionFailedPO failed = 4;
  }
}

// Define the TransactionInitiated event
message TransactionInitiatedPO {
  string fromUserId = 1;
  string toUserId = 2;
  MoneyPO amount = 3;
}

// Define the TransactionPrepared event
message TransactionPreparedPO {
  string id = 1;
}

// Define the TransactionCompleted event
message TransactionCompletedPO {
  string id = 1;
}

// Define the TransactionFailed event
message TransactionFailedPO {
  string id = 1;
  string reason = 2;
}

==================================================
文件路径: conf\application.conf
==================================================

# https://www.playframework.com/documentation/latest/Configuration
include "projection.conf"
include "persistence.conf"
include "serialization.conf"
include "cluster.conf"

akka {
  loglevel = DEBUG
}

play.modules.enabled += "scalikejdbc.PlayModule"
# scalikejdbc.PlayModule doesn't depend on Play's DBModule
play.modules.disabled += "play.api.db.DBModule"
play.filters.enabled=[controllers.filter.LoggingFilter]
play.server.websocket.periodic-keep-alive-max-idle = 10 seconds

play.temporaryFile {
  reaper {
    enabled = true
    initialDelay = "5 minutes"
    interval = "30 seconds"
    olderThan = "30 minutes"
  }
}



==================================================
文件路径: conf\cluster.conf
==================================================

akka {

   actor {
     provider = cluster
   }

   min-nr-of-member = 1

   remote.artery {
       canonical {
         hostname = ${clustering.ip}
         port = ${clustering.port}
       }
       bind {
         hostname = ${clustering.ip}
         port = ${clustering.port}
       }
     }
   cluster {
     seed-nodes = ["akka://application@"${clustering.seed-ip}":"${clustering.seed-port}]
     downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
     shutdown-after-unsuccessful-join-seed-nodes = 120s

     sharding {
       least-shard-allocation-strategy.rebalance-absolute-limit = 20
       passivation {
         strategy = custom-lru-strategy
         custom-lru-strategy {
           active-entity-limit = 1000000
           replacement.policy = least-recently-used
         }
       }
     }
   }
}

clustering {
 ip = "127.0.0.1"
 ip = ${?CLUSTER_IP}
 port = 2551
 port = ${?CLUSTER_PORT}
 seed-ip = "127.0.0.1"
 seed-ip = ${?SEED_IP}
 seed-ip = ${?SEED_PORT_1600_TCP_ADDR}
 seed-port = 2551
 seed-port = ${?SEED_PORT_1600_TCP_PORT}
 cluster.name = application
}

==================================================
文件路径: conf\persistence.conf
==================================================

akka {
  persistence {
    journal.plugin = "akka-contrib-mongodb-persistence-journal"
	snapshot-store.plugin = "akka-contrib-mongodb-persistence-snapshot"
  }
  contrib.persistence.mongodb.mongo.mongouri = "mongodb://127.0.0.1:27017/cqrs-demo-journal?maxPoolSize=20&w=majority&authSource=admin"
  contrib.persistence.mongodb.mongo.suffix-builder.separator = "_"
  contrib.persistence.mongodb.mongo.suffix-builder.class = "net.imadz.infrastructure.SuffixCollectionNames"
}

==================================================
文件路径: conf\projection.conf
==================================================

akka {

   projection {
     jdbc.blocking-jdbc-dispatcher.thread-pool-executor.fixed-pool-size = 10
     jdbc.dialect = mysql-dialect
   }

}

jdbc-connection-settings {
  driver = "com.mysql.jdbc.Driver"
  url = "jdbc:mysql://127.0.0.1:3308/cqrs_jdbc_demo?allowPublicKeyRetrieval=true&noAccessToProcedureBodies=true&createDatabaseIfNotExist=true&m=yes&characterEncoding=UTF-8&connectTimeout=300000&useSSL=false&serverTimezone=UTC&socketTimeout=30000&autoReconnect=true&maxReconnects=10&initialTimeout=10"
  user = "root"
  password = "1q2w3e4r5t"

    # the following properties are used to configure the
    # Hikari connection pool used on the read-side (akka-projections)
    connection-pool {
      # How many connections should be available to from the pool?
      # it's recommended to use the same value used by the blocking-jdbc-dispatcher (see above)
      max-pool-size = ${akka.projection.jdbc.blocking-jdbc-dispatcher.thread-pool-executor.fixed-pool-size}

      # How long should we wait (in millis) before it times out?
      # In a normal scenario, we should always be able to get a connection
      # If we got a thread from the blocking-jdbc-dispatcher, we should be able to get a connection.
      # If for some reason the pool can't provide a connection, it's better to let it crash and liberate the current thread.
      # Hence the low timout (note, 250 is lowest value hikari accepts)
      timeout = 250ms
    }
}

scalikejdbc.global {
  loggingSQLAndTime.enabled=false
  loggingSQLAndTime.singleLineMode=false
  loggingSQLAndTime.logLevel=debug
  loggingSQLAndTime.warningEnabled=true
  loggingSQLAndTime.warningThresholdMillis=5
  loggingSQLAndTime.warningLogLevel=warn
}

==================================================
文件路径: conf\serialization.conf
==================================================

akka {
   actor {
     serializers {
        jackson-json = "akka.serialization.jackson.JacksonJsonSerializer"
        jackson-cbor = "akka.serialization.jackson.JacksonCborSerializer"
        object-id-offset = "net.imadz.common.serialization.ObjectIdOffsetSerializer"
        proto = "akka.remote.serialization.ProtobufSerializer"
        saga-serializer = "net.imadz.infra.saga.serialization.SagaSerializer"
     }
     serialization-bindings {
       "akka.contrib.persistence.mongodb.ObjectIdOffset" = object-id-offset
       "com.google.protobuf.Message" = proto
       "scalapb.GeneratedMessage" = proto
       "net.imadz.common.CborSerializable" = jackson-cbor
       "net.imadz.infra.saga.StepExecutor$OperationResponse" =  saga-serializer
       "net.imadz.infra.saga.StepExecutor$OperationSucceeded" =  saga-serializer
     }
     allow-java-serialization = on
     warn-about-java-serializer-usage = off
   }

}

==================================================
文件路径: test\net\imadz\infra\saga\SagaTransactionCoordinatorSpec.scala
==================================================

package net.imadz.infra.saga

import akka.actor.testkit.typed.scaladsl.{LogCapturing, ScalaTestWithActorTestKit}
import akka.actor.typed.ActorRef
import akka.actor.typed.scaladsl.Behaviors
import akka.persistence.testkit.scaladsl.EventSourcedBehaviorTestKit
import akka.persistence.typed.PersistenceId
import com.typesafe.config.ConfigFactory
import net.imadz.infra.saga.SagaParticipant.{NonRetryableFailure, SagaResult}
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.SagaTransactionCoordinator.TransactionResult
import net.imadz.infra.saga.StepExecutor.StepResult
import org.scalatest.BeforeAndAfterEach
import org.scalatest.wordspec.AnyWordSpecLike

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.DurationInt

class SagaTransactionCoordinatorSpec extends ScalaTestWithActorTestKit(
  ConfigFactory.parseString(
    """
      |akka {
      |  actor {
      |    serializers {
      |      proto = "akka.remote.serialization.ProtobufSerializer"
      |      saga-transaction-step = "net.imadz.infra.saga.SagaTransactionStepSerializerForTest"
      |    }
      |    serialization-bindings {
      |      "com.google.protobuf.Message" = proto
      |      "net.imadz.infra.saga.SagaTransactionStep" = saga-transaction-step
      |    }
      |    allow-java-serialization = on
      |    warn-about-java-serializer-usage = off
      |  }
      |}
      |# In-memory database configuration for unit testing
      |       database {
      |         url = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"
      |         driver = org.h2.Driver
      |         connectionPool = disabled
      |         keepAliveConnection = true
      |       }
      |akka.test.single-expect-default = 100s
      |akka.actor.testkit.typed.single-expect-default = 100s
      |""".stripMargin
  ).withFallback(EventSourcedBehaviorTestKit.config)
) with AnyWordSpecLike with BeforeAndAfterEach with LogCapturing {

  private def createEventSourcedTestKit(stepExecutorCreator: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command]) = {
    EventSourcedBehaviorTestKit[
      SagaTransactionCoordinator.Command,
      SagaTransactionCoordinator.Event,
      SagaTransactionCoordinator.State
    ](
      system,
      SagaTransactionCoordinator(
        PersistenceId.ofUniqueId("test-saga-coordinator"),
        stepExecutorCreator
      )
    )
  }

  private def createSuccessfulStepExecutor[E, R](): ActorRef[StepExecutor.Command] = {
    spawn(Behaviors.receiveMessage[StepExecutor.Command] {
      case StepExecutor.Start(transactionId, step, replyTo: Option[ActorRef[StepResult[E, R]]]) =>
        replyTo.foreach(_ ! StepExecutor.StepCompleted[E, R](step.stepId, SagaResult.empty[R](), StepExecutor.State()))
        Behaviors.same
    })
  }

  private def createFailingStepExecutor(): ActorRef[StepExecutor.Command] = {
    spawn(Behaviors.receiveMessage[StepExecutor.Command] {
      case StepExecutor.Start(transactionId, step, replyTo) =>
        replyTo.foreach(_ ! StepExecutor.StepFailed(transactionId, Left(NonRetryableFailure("Test failure")), StepExecutor.State()))
        Behaviors.same
    })
  }

  "SagaTransactionCoordinator" should {
    "successfully complete a transaction" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, _) => createSuccessfulStepExecutor())
      val transactionId = "test-transaction"
      val steps = List(
        SagaTransactionStep("step1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("step2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("step3", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("step4", CommitPhase, SuccessfulParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = true,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CommitPhase,
          status = SagaTransactionCoordinator.Completed,
        ),
        stepTraces = List.fill(4)(StepExecutor.State())
      )
    }

    "handle failure during PreparePhase and initiate compensation" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        if (step.phase == PreparePhase) createFailingStepExecutor()
        else createSuccessfulStepExecutor()
      )
      val transactionId = "failed-transaction"
      val steps = List(
        SagaTransactionStep("step1", PreparePhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("step2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = false,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CompensatePhase,
          status = SagaTransactionCoordinator.Failed,
        ),
        stepTraces = List(StepExecutor.State(), StepExecutor.State())
      )
    }

    "handle non-retryable failure during CommitPhase" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        if (step.phase == CommitPhase) createFailingStepExecutor()
        else createSuccessfulStepExecutor()
      )
      val transactionId = "commit-failed-transaction"
      val steps = List(
        SagaTransactionStep("step1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("step2", CommitPhase, AlwaysFailingParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = false,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CompensatePhase,
          status = SagaTransactionCoordinator.Failed,
        ),
        stepTraces = List(StepExecutor.State(), StepExecutor.State())
      )
    }
    "handle failure during CommitPhase and successfully compensate" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        if (step.stepId == "commit1") createFailingStepExecutor()
        else createSuccessfulStepExecutor()
      )
      val transactionId = "commit-fail-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = false,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CompensatePhase,
          status = SagaTransactionCoordinator.Failed,
        ),
        stepTraces = List.fill(6)(StepExecutor.State())
      )
    }

    "handle partial failure during CompensatePhase" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        if (step.stepId == "commit2" || step.stepId == "compensate1") createFailingStepExecutor()
        else createSuccessfulStepExecutor()
      )
      val transactionId = "compensate-partial-fail-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = false,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CompensatePhase,
          status = SagaTransactionCoordinator.Failed,
        ),
        stepTraces = List.fill(6)(StepExecutor.State())
      )
    }

  }
}

==================================================
文件路径: test\net\imadz\infra\saga\SagaTransactionStepSerializerForTest.scala
==================================================

package net.imadz.infra.saga

import akka.serialization.Serializer
import net.imadz.infra.saga.SagaPhase._

import scala.concurrent.duration.DurationLong

class SagaTransactionStepSerializerForTest extends Serializer {
  override def identifier: Int = 1234 // Unique identifier for this serializer

  override def toBinary(o: AnyRef): Array[Byte] = o match {
    case step: SagaTransactionStep[_, _] =>
      proto.saga_v2.SagaTransactionStepPO(
        stepId = step.stepId,
        phase = step.phase match {
          case PreparePhase => proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
          case CommitPhase => proto.saga_v2.TransactionPhasePO.COMMIT_PHASE
          case CompensatePhase => proto.saga_v2.TransactionPhasePO.COMPENSATE_PHASE
        },
        maxRetries = step.maxRetries,
        timeoutDurationMillis = step.timeoutDuration.toMillis,
        retryWhenRecoveredOngoing = step.retryWhenRecoveredOngoing,
        participant = None,
        participantType = step.participant.getClass.getName
      ).toByteArray
    case _ => throw new IllegalArgumentException(s"Cannot serialize object of type ${o.getClass}")
  }

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef = {
    val protoStep = proto.saga_v2.SagaTransactionStepPO.parseFrom(bytes)
    SagaTransactionStep(
      stepId = protoStep.stepId,
      phase = protoStep.phase match {
        case proto.saga_v2.TransactionPhasePO.PREPARE_PHASE => PreparePhase
        case proto.saga_v2.TransactionPhasePO.COMMIT_PHASE => CommitPhase
        case proto.saga_v2.TransactionPhasePO.COMPENSATE_PHASE => CompensatePhase
        case _ => throw new IllegalArgumentException(s"Unknown phase: ${protoStep.phase}")
      },
      participant = createParticipant(protoStep.participantType),
      maxRetries = protoStep.maxRetries,
      timeoutDuration = protoStep.timeoutDurationMillis.millis,
      retryWhenRecoveredOngoing = protoStep.retryWhenRecoveredOngoing
    )
  }

  private def createParticipant(participantType: String): SagaParticipant[_, _] = {
    // This method should create and return the appropriate SagaParticipant based on the type
    // You'll need to implement this based on your specific participants
    participantType match {
      case "net.imadz.infra.saga.SuccessfulParticipant" => SuccessfulParticipant
      case "net.imadz.infra.saga.RetryingParticipant" => RetryingParticipant() // Default value, adjust as needed
      case "net.imadz.infra.saga.TimeoutParticipant" => TimeoutParticipant
      case "net.imadz.infra.saga.AlwaysFailingParticipant" => AlwaysFailingParticipant
      case "net.imadz.infra.saga.NonRetryableFailingParticipant" => NonRetryableFailingParticipant

      case name =>
        println(name)
        throw new IllegalArgumentException(s"Unknown participant type: $participantType")
    }
  }

  override def includeManifest: Boolean = false
}

// Implement similar serializers for other classes (State, RetryableOrNotException, etc.)

==================================================
文件路径: test\net\imadz\infra\saga\StepExecutorSagaCoordinatorIntegrationSpec.scala
==================================================

package net.imadz.infra.saga

import akka.actor.testkit.typed.scaladsl.{LogCapturing, ScalaTestWithActorTestKit}
import akka.actor.typed.ActorRef
import akka.persistence.testkit.scaladsl.EventSourcedBehaviorTestKit
import akka.persistence.typed.PersistenceId
import com.typesafe.config.ConfigFactory
import net.imadz.infra.saga.SagaParticipant.RetryableFailure
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.SagaTransactionCoordinator.TransactionResult
import net.imadz.infra.saga.StepExecutor.CircuitBreakerSettings
import org.scalatest.BeforeAndAfterEach
import org.scalatest.wordspec.AnyWordSpecLike

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._

class StepExecutorSagaCoordinatorIntegrationSpec extends ScalaTestWithActorTestKit(
  ConfigFactory.parseString(
    """
      |akka {
      |  actor {
      |    serializers {
      |      proto = "akka.remote.serialization.ProtobufSerializer"
      |      saga-transaction-step = "net.imadz.infra.saga.SagaTransactionStepSerializerForTest"
      |    }
      |    serialization-bindings {
      |      "com.google.protobuf.Message" = proto
      |      "net.imadz.infra.saga.SagaTransactionStep" = saga-transaction-step
      |    }
      |    allow-java-serialization = on
      |    warn-about-java-serializer-usage = off
      |  }
      |}
      |# In-memory database configuration for unit testing
      |database {
      |  url = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"
      |  driver = org.h2.Driver
      |  connectionPool = disabled
      |  keepAliveConnection = true
      |}
      |akka.test.single-expect-default = 100s
      |akka.actor.testkit.typed.single-expect-default = 100s
      |""".stripMargin
  ).withFallback(EventSourcedBehaviorTestKit.config)
) with AnyWordSpecLike with BeforeAndAfterEach with LogCapturing {

  private def createEventSourcedTestKit(stepExecutorCreator: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command]) = {
    EventSourcedBehaviorTestKit[
      SagaTransactionCoordinator.Command,
      SagaTransactionCoordinator.Event,
      SagaTransactionCoordinator.State
    ](
      system,
      SagaTransactionCoordinator(
        PersistenceId.ofUniqueId("test-saga-coordinator"),
        stepExecutorCreator
      )
    )
  }

  "StepExecutor and SagaTransactionCoordinator Integration" should {

    "successfully complete a transaction with multiple steps across different phases" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, _) => createStepExecutor())
      val transactionId = "multi-phase-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe true
      result.state.status shouldBe SagaTransactionCoordinator.Completed
      result.state.currentPhase shouldBe CommitPhase
      result.stepTraces should have length 4
    }

    "handle failure in Prepare phase and initiate compensation" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "prepare-fail-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.state.currentPhase shouldBe CompensatePhase
      result.stepTraces should have length 4 // prepare1, prepare2 (failed), compensate1, compensate2
    }

    "handle failure in Commit phase and compensate all steps" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "commit-fail-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.state.currentPhase shouldBe CompensatePhase
      result.stepTraces should have length 6 // prepare1, prepare2, commit1 (failed), compensate1, compensate2
    }

    "retry a step with temporary failure" in {
      val retryingParticipant = new RetryingParticipant()
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "retry-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, retryingParticipant, 5),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      println(result)

      result.successful shouldBe true
      result.state.status shouldBe SagaTransactionCoordinator.Completed
      result.orderedSteps.head.retries should be > 0
    }

    // Add more test cases here...

    "handle circuit breaker behavior" in {
      val circuitBreakerParticipant = new CircuitBreakerParticipant()
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "circuit-breaker-transaction"
      val steps = List(
        SagaTransactionStep("circuit-breaker-step", PreparePhase, circuitBreakerParticipant, 10, 1.seconds))
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(15.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.orderedSteps.head.retries should be >= 3
    }


    "handle timeout in a step" in {
      val timeoutParticipant = new TimeoutParticipant()
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "timeout-transaction"
      val steps = List(
        SagaTransactionStep("timeout-step", PreparePhase, timeoutParticipant, 2, timeoutDuration = 500.millis),
        SagaTransactionStep("compensate-step", CompensatePhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.state.currentPhase shouldBe CompensatePhase
      result.orderedSteps.head.lastError.get shouldBe a[RetryableFailure]
    }

    "handle partial compensation" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) => createStepExecutor())
      val transactionId = "partial-compensate-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.state.currentPhase shouldBe CompensatePhase
      result.stepTraces should have length 6 // prepare1, prepare2, commit1, commit2 (failed), compensate1 (failed), compensate2
      result.stepTraces.count(_.status == StepExecutor.Failed) shouldBe 2
    }
  }

  private def createStepExecutor(circuitBreakerSettings: CircuitBreakerSettings = CircuitBreakerSettings(5, 30.seconds, 30.seconds)) = {
    spawn(StepExecutor[Any, Any](
      PersistenceId.ofUniqueId(s"step-executor-${java.util.UUID.randomUUID()}"),
      defaultMaxRetries = 5,
      initialRetryDelay = 100.millis,
      circuitBreakerSettings = circuitBreakerSettings
    ))
  }


}


==================================================
文件路径: test\net\imadz\infra\saga\StepExecutorSpec.scala
==================================================

package net.imadz.infra.saga

import akka.actor.testkit.typed.scaladsl.{LogCapturing, ScalaTestWithActorTestKit}
import akka.persistence.testkit.scaladsl.EventSourcedBehaviorTestKit
import akka.persistence.typed.PersistenceId
import com.typesafe.config.ConfigFactory
import net.imadz.common.CborSerializable
import net.imadz.infra.saga.SagaParticipant._
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.StepExecutor._
import org.scalatest.BeforeAndAfterEach
import org.scalatest.wordspec.AnyWordSpecLike
import org.slf4j.LoggerFactory

import scala.concurrent.Future
import scala.concurrent.duration._

class StepExecutorSpec extends ScalaTestWithActorTestKit(
  ConfigFactory.parseString(
    """
akka {
       actor {
         serializers {

            proto = "akka.remote.serialization.ProtobufSerializer"
            saga-transaction-step = "net.imadz.infra.saga.SagaTransactionStepSerializerForTest"

         }
         serialization-bindings {
           "com.google.protobuf.Message" = proto
           "net.imadz.infra.saga.SagaTransactionStep" = saga-transaction-step

         }
         allow-java-serialization = on
         warn-about-java-serializer-usage = off
       }

    }
    # In-memory database configuration for unit testing
       database {
         url = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"
         driver = org.h2.Driver
         connectionPool = disabled
         keepAliveConnection = true
       }
""".stripMargin
  ).withFallback(EventSourcedBehaviorTestKit.config)
)
  with AnyWordSpecLike
  with BeforeAndAfterEach
  with LogCapturing {

  val logger = LoggerFactory.getLogger(getClass)

  private def createTestKit[E, R](id: String, defaultMaxRetries: Int = 5, initialRetryDelay: FiniteDuration = 2.seconds, circuitBreakerSettings: CircuitBreakerSettings = CircuitBreakerSettings(5, 30.seconds, 30.seconds)): EventSourcedBehaviorTestKit[Command, Event, State[E, R]] =
    EventSourcedBehaviorTestKit[
      StepExecutor.Command,
      StepExecutor.Event,
      StepExecutor.State[E, R]](
      system,
      StepExecutor(persistenceId = PersistenceId.ofUniqueId(id),
        defaultMaxRetries = defaultMaxRetries,
        initialRetryDelay = initialRetryDelay,
        circuitBreakerSettings = circuitBreakerSettings
      )
    )

  val participant = SuccessfulParticipant
  val eventSourcedTestKit: EventSourcedBehaviorTestKit[Command, Event, State[String, String]] = createTestKit("test-1")

  override protected def beforeEach(): Unit = {
    super.beforeEach()
    eventSourcedTestKit.clear()
  }


  "StepExecutor" should {

    "successfully execute Start command" in {
      val probe = createTestProbe[StepResult[String, String]]()

      val reserveFromAccount = SagaTransactionStep[String, String](
        "from-account-reservation", PreparePhase, SuccessfulParticipant
      )
      val result = eventSourcedTestKit.runCommand(Start[String, String]("trx1", reserveFromAccount, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx1", reserveFromAccount, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx1")
      result.state.step shouldBe Some(reserveFromAccount)
      result.state.status shouldBe Ongoing

      probe.expectMessage(3.seconds, StepCompleted[String, String](
        transactionId = "trx1",
        result = SagaResult("Prepared"),
        state = StepExecutor.State(step = Some(reserveFromAccount), transactionId = Some("trx1"), status = Succeed,
          replyTo = Some(probe.ref.path.toSerializationFormat))
      ))

    }

    "successfully execute Start command for PreparePhase" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val eventSourcedTestKit = createTestKit("test-prepare")

      val prepareStep = SagaTransactionStep[String, String](
        "prepare-step", PreparePhase, SuccessfulParticipant
      )
      val result = eventSourcedTestKit.runCommand(Start("trx1", prepareStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx1", prepareStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx1")
      result.state.step shouldBe Some(prepareStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(5.seconds, StepCompleted[String, String](
        transactionId = "trx1",
        result = SagaResult("Prepared"),
        state = StepExecutor.State(step = Some(prepareStep), transactionId = Some("trx1"), status = Succeed
          , replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "successfully execute Start command for CommitPhase" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val eventSourcedTestKit = createTestKit("test-commit")

      val commitStep = SagaTransactionStep[String, String](
        "commit-step", CommitPhase, SuccessfulParticipant
      )
      val result = eventSourcedTestKit.runCommand(Start("trx2", commitStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx2", commitStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx2")
      result.state.step shouldBe Some(commitStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(5.seconds, StepCompleted[String, String](
        transactionId = "trx2",
        result = SagaResult("Committed"),
        state = StepExecutor.State(step = Some(commitStep), transactionId = Some("trx2"), status = Succeed
          , replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "successfully execute Start command for CompensatePhase" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val eventSourcedTestKit = createTestKit("test-compensate")

      val compensateStep = SagaTransactionStep[String, String](
        "compensate-step", CompensatePhase, SuccessfulParticipant
      )
      val result = eventSourcedTestKit.runCommand(Start("trx3", compensateStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx3", compensateStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx3")
      result.state.step shouldBe Some(compensateStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(5.seconds, StepCompleted[String, String](
        transactionId = "trx3",
        result = SagaResult("Compensated"),
        state = StepExecutor.State(step = Some(compensateStep), transactionId = Some("trx3"), status = Succeed, replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "retry on retryable failure" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val retryingParticipant = RetryingParticipant()
      val eventSourcedTestKit = createTestKit("test-retry")

      val retryStep = SagaTransactionStep[String, String](
        "retry-step", PreparePhase, retryingParticipant, maxRetries = 5
      )
      val result = eventSourcedTestKit.runCommand(Start("trx4", retryStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx4", retryStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx4")
      result.state.step shouldBe Some(retryStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(10.seconds, StepCompleted[String, String](
        transactionId = "trx4",
        result = SagaResult("Success after retry"),
        state = StepExecutor.State(step = Some(retryStep), transactionId = Some("trx4"), status = Succeed,
          retries = 2,
          lastError = Some(RetryableFailure("Retry needed")),
          replyTo = Some(probe.ref.path.toSerializationFormat)
        )
      ))
    }

    "fail after max retries" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val alwaysFailingParticipant = AlwaysFailingParticipant
      val eventSourcedTestKit = createTestKit("test-max-retries")

      val failingStep = SagaTransactionStep[String, String](
        "failing-step", PreparePhase, alwaysFailingParticipant, maxRetries = 2
      )
      val result = eventSourcedTestKit.runCommand(Start("trx5", failingStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx5", failingStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx5")
      result.state.step shouldBe Some(failingStep)
      result.state.status shouldBe Ongoing

      probe.expectMessageType[StepFailed[String, String]](10.seconds)
    }

    "fail immediately on non-retryable failure" in {
      val probe = createTestProbe[StepResult[RetryableOrNotException, String]]()
      val nonRetryableFailingParticipant = NonRetryableFailingParticipant
      val eventSourcedTestKit = createTestKit("test-non-retryable")

      val nonRetryableStep = SagaTransactionStep[RetryableOrNotException, String](
        "non-retryable-step", PreparePhase, nonRetryableFailingParticipant, maxRetries = 5
      )
      val result = eventSourcedTestKit.runCommand(Start("trx6", nonRetryableStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx6", nonRetryableStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx6")
      result.state.step shouldBe Some(nonRetryableStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(5.seconds, StepFailed[RetryableOrNotException, String](
        transactionId = "trx6",
        error = NonRetryableFailure("Critical error"),
        state = StepExecutor.State(
          step = Some(nonRetryableStep),
          transactionId = Some("trx6"),
          status = Failed,
          lastError = Some(NonRetryableFailure("Critical error")),
          replyTo = Some(probe.ref.path.toSerializationFormat)
        )
      ))
    }

    "timeout on long-running operation" in {
      val probe = createTestProbe[StepResult[RetryableOrNotException, String]]()
      val timeoutParticipant = TimeoutParticipant
      val eventSourcedTestKit = createTestKit("test-timeout")

      val timeoutStep = SagaTransactionStep[RetryableOrNotException, String](
        "timeout-step", PreparePhase, timeoutParticipant, timeoutDuration = 1.seconds, maxRetries = 2
      )
      val result = eventSourcedTestKit.runCommand(Start("trx7", timeoutStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx7", timeoutStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx7")
      result.state.step shouldBe Some(timeoutStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(1000.seconds, StepFailed[RetryableOrNotException, String](
        transactionId = "trx7",
        error = RetryableFailure("timed out"),
        state = StepExecutor.State(step = Some(timeoutStep), transactionId = Some("trx7"), status = Failed,
          lastError = Some(RetryableFailure("timed out")),
          replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "recover execution and retry when in Ongoing state" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val retryingParticipant = RetryingParticipant()
      val eventSourcedTestKit = createTestKit("test-recover")

      val recoverStep = SagaTransactionStep[String, String](
        "recover-step", PreparePhase, retryingParticipant, maxRetries = 5, retryWhenRecoveredOngoing = true
      )

      // Simulate a crash after starting execution
      eventSourcedTestKit.runCommand(Start("trx-recover", recoverStep, Some(probe.ref)))
      try {
        Thread.sleep(500L)
      } catch {
        case ignored: Throwable => ()
      }
      eventSourcedTestKit.restart()
      logger.info("restarting executor")

      // The actor should automatically retry the operation
      probe.expectMessage(10.seconds, StepCompleted[String, String](
        transactionId = "trx-recover",
        result = SagaResult("Success after retry"),
        state = StepExecutor.State(step = Some(recoverStep),
          transactionId = Some("trx-recover"),
          status = Succeed,
          retries = 2,
          lastError = Some(RetryableFailure("Retry needed")),
          replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "persist events and recover state" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val participant = SuccessfulParticipant
      val eventSourcedTestKit = createTestKit("test-persist")

      val step = SagaTransactionStep[String, String](
        "persist-step", PreparePhase, participant
      )

      eventSourcedTestKit.runCommand(Start("trx-persist", step, Some(probe.ref)))

      // Verify persisted events
      val persistedEvents = eventSourcedTestKit.persistenceTestKit.persistedInStorage("test-persist")
      persistedEvents should contain(ExecutionStarted("trx-persist", step, probe.ref.path.toSerializationFormat))
      persistedEvents should contain(OperationSucceeded(SagaResult("Prepared")))

      // Simulate restart and verify recovered state
      eventSourcedTestKit.restart()
      val recoveredState = eventSourcedTestKit.getState()
      recoveredState.status shouldBe Succeed
      recoveredState.transactionId shouldBe Some("trx-persist")
    }
  }
}

case object SuccessfulParticipant extends SagaParticipant[String, String] with CborSerializable {
  override def doPrepare(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Prepared")))

  override def doCommit(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => NonRetryableFailure("never retry")
  }
}

case class RetryingParticipant() extends SagaParticipant[String, String] with CborSerializable {
  private var attempts = 0
  private val succeedAfter = 3

  override def doPrepare(transactionId: String) = {
    attempts += 1
    try {
      Thread.sleep(500L)
    } catch {
      case ignored: Throwable => ()
    }
    logger.warn(s"RetryingParticipant is doing prepare $attempts times")
    if (attempts < succeedAfter) Future.failed(RetryableFailure("Retry needed"))
    else Future.successful(Right[String, SagaResult[String]](SagaResult("Success after retry")))
  }

  override def doCommit(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => NonRetryableFailure("never retry")
  }
}


case object TimeoutParticipant extends SagaParticipant[RetryableOrNotException, String] {
  override def doPrepare(transactionId: String) = Future.never // Simulating a long-running operation

  override def doCommit(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => NonRetryableFailure("never retry")
  }
}

case object AlwaysFailingParticipant extends SagaParticipant[String, String] {
  override def doPrepare(transactionId: String) = {
    logger.warn(s"AlwaysFailingParticipant is failing after 5 seconds")
    try {
      Thread.sleep(1000L)
    } catch {
      case ignored: Throwable => ()
    }
    Future.failed(RetryableFailure("Always fails"))
  }

  override def doCommit(transactionId: String) =     Future.failed(RetryableFailure("Always fails"))


  override def doCompensate(transactionId: String) =     Future.failed(RetryableFailure("Always fails"))


  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => NonRetryableFailure("never retry")
  }
}

case object NonRetryableFailingParticipant extends SagaParticipant[RetryableOrNotException, String] {
  override def doPrepare(transactionId: String) = Future.failed(new RuntimeException())

  override def doCommit(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Compensated")))


  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case _ => NonRetryableFailure("Critical error")
  }
}

case class CircuitBreakerParticipant() extends SagaParticipant[RetryableOrNotException, String] {
  private var attempts = 0

  override def doPrepare(transactionId: String) = {
    attempts += 1
    Future.failed(RetryableFailure(s"Failure attempt $attempts"))
  }

  override def doCommit(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => RetryableFailure("Retry needed")
  }
}

case class TimeoutParticipant() extends SagaParticipant[String, String] {
  override def doPrepare(transactionId: String) = {
    Thread.sleep(1000) // Simulate long-running operation
    Future.successful(Right[String, SagaResult[String]](SagaResult("Prepared")))
  }

  override def doCommit(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => RetryableFailure("Retry needed")
  }
}
