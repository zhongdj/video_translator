
==================================================
文件路径: .g8\form\app\controllers\$model__Camel$Controller.scala
==================================================

package controllers

import javax.inject._
import play.api.mvc._

import play.api.data._
import play.api.data.Forms._

case class $model;format="Camel"$Data(name: String, age: Int)
object $model;format="Camel"$Data {
  def unapply(data: $model;format="Camel"$Data): Option[(String, Int)] = Some((data.name, data.age))
}

// NOTE: Add the following to conf/routes to enable compilation of this class:
/*
GET     /$model;format="camel"$        controllers.$model;format="Camel"$Controller.$model;format="camel"$Get()
POST    /$model;format="camel"$        controllers.$model;format="Camel"$Controller.$model;format="camel"$Post()
*/

/**
 * $model;format="Camel"$ form controller for Play Scala
 */
class $model;format="Camel"$Controller @Inject()(mcc: MessagesControllerComponents) extends MessagesAbstractController(mcc) {

  val $model;format="camel"$Form = Form(
    mapping(
      "name" -> text,
      "age" -> number
    )($model;format="Camel"$Data.apply)($model;format="Camel"$Data.unapply)
  )

  def $model;format="camel"$Get() = Action { implicit request: MessagesRequest[AnyContent] =>
    Ok(views.html.$model;format="camel"$.form($model;format="camel"$Form))
  }

  def $model;format="camel"$Post() = Action { implicit request: MessagesRequest[AnyContent] =>
    $model;format="camel"$Form.bindFromRequest().fold(
      formWithErrors => {
        // binding failure, you retrieve the form containing errors:
        BadRequest(views.html.$model;format="camel"$.form(formWithErrors))
      },
      $model;format="camel"$Data => {
        /* binding success, you get the actual value. */       
        /* flashing uses a short lived cookie */ 
        Redirect(routes.$model;format="Camel"$Controller.$model;format="camel"$Get()).flashing("success" -> ("Successful " + $model;format="camel"$Data.toString))
      }
    )
  }
}


==================================================
文件路径: .g8\form\test\controllers\$model__Camel$ControllerSpec.scala
==================================================

package controllers

import play.api.mvc._
import play.api.i18n._
import org.scalatestplus.play._
import org.scalatestplus.play.guice.GuiceOneAppPerTest
import play.api.http.FileMimeTypes
import play.api.test._
import play.api.test.Helpers._
import play.api.test.CSRFTokenHelper._

import scala.concurrent.ExecutionContext

/**
 * $model;format="Camel"$ form controller specs
 */
class $model;format="Camel"$ControllerSpec extends PlaySpec with GuiceOneAppPerTest with Injecting {

  // Provide stubs for components based off Helpers.stubControllerComponents()
  class StubComponents(cc:ControllerComponents = stubControllerComponents()) extends MessagesControllerComponents {
    override val parsers: PlayBodyParsers = cc.parsers
    override val messagesApi: MessagesApi = cc.messagesApi
    override val langs: Langs = cc.langs
    override val fileMimeTypes: FileMimeTypes = cc.fileMimeTypes
    override val executionContext: ExecutionContext = cc.executionContext
    override val actionBuilder: ActionBuilder[Request, AnyContent] = cc.actionBuilder
    override val messagesActionBuilder: MessagesActionBuilder = new DefaultMessagesActionBuilderImpl(parsers.default, messagesApi)(executionContext)
  }

  "$model;format="Camel"$Controller GET" should {

    "render the index page from a new instance of controller" in {
      val controller = new $model;format="Camel"$Controller(new StubComponents())
      val request = FakeRequest().withCSRFToken
      val home = controller.$model;format="camel"$Get().apply(request)

      status(home) mustBe OK
      contentType(home) mustBe Some("text/html")
    }

    "render the index page from the application" in {
      val controller = inject[$model;format="Camel"$Controller]
      val request = FakeRequest().withCSRFToken
      val home = controller.$model;format="camel"$Get().apply(request)

      status(home) mustBe OK
      contentType(home) mustBe Some("text/html")
    }

    "render the index page from the router" in {
      val request = CSRFTokenHelper.addCSRFToken(FakeRequest(GET, "/$model;format="camel"$"))
      val home = route(app, request).get

      status(home) mustBe OK
      contentType(home) mustBe Some("text/html")
    }
  }

  "$model;format="Camel"$Controller POST" should {
    "process form" in {
      val request = {
        FakeRequest(POST, "/$model;format="camel"$")
          .withFormUrlEncodedBody("name" -> "play", "age" -> "4")
      }
      val home = route(app, request).get

      status(home) mustBe SEE_OTHER
    }
  }

}


==================================================
文件路径: app\controllers\HomeController.scala
==================================================

package controllers

import akka.actor.typed.Scheduler
import akka.actor.typed.javadsl.Adapter
import akka.actor.typed.scaladsl.adapter.ClassicActorSystemOps
import akka.actor.{ActorSystem, typed}
import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import net.imadz.application.aggregates.CreditBalanceAggregate.CreditBalanceConfirmation
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.application.projection.ScalikeJdbcSetup
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.application.queries.{GetBalanceQuery, GetRecent12MonthsIncomeAndExpenseReport}
import net.imadz.application.services.transactor.MoneyTransferTransactionRepository
import net.imadz.application.services.{CreateCreditBalanceService, DepositService, MoneyTransferService, WithdrawService}
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.common.Id
import net.imadz.domain.values.Money
import net.imadz.infra.saga.repository.TransactionCoordinatorRepository
import net.imadz.infrastructure.bootstrap._
import play.api.libs.json._
import play.api.mvc._

import java.util.Currency
import javax.inject._
import scala.concurrent.ExecutionContext

/**
 * This controller creates an `Action` to handle HTTP requests to the
 * application's home page.
 */
@Singleton
class HomeController @Inject()(
                                val system: ActorSystem,
                                val sharding: ClusterSharding,
                                val monthlyQuery: GetRecent12MonthsIncomeAndExpenseReport,
                                val monthlyRepository: MonthlyIncomeAndExpenseSummaryRepository,
                                val creditBalanceRepository: CreditBalanceRepository,
                                val transactionRepository: MoneyTransferTransactionRepository,
                                val coordinatorRepository: TransactionCoordinatorRepository,
                                val getBalanceQuery: GetBalanceQuery,
                                val createService: CreateCreditBalanceService,
                                val depositService: DepositService,
                                val withdrawService: WithdrawService,
                                val controllerComponents: ControllerComponents
                              )(implicit executionContext: ExecutionContext) extends BaseController
  with MonthlyIncomeAndExpenseBootstrap
  with CreditBalanceBootstrap
//  with TransactionBootstrap
  with SagaTransactionCoordinatorBootstrap {
  val typedSystem: typed.ActorSystem[Nothing] = system.toTyped
  ScalikeJdbcSetup.init(Adapter.toTyped(system))

  implicit val scheduler: Scheduler = typedSystem.scheduler
  val moneyTransferService: MoneyTransferService = new MoneyTransferService(system.toTyped, transactionRepository)

  initMonthlySummaryProjection(Adapter.toTyped(system), sharding, monthlyRepository)
  initCreditBalanceAggregate(sharding)
  initSagaTransactionCoordinatorAggregate(sharding, creditBalanceRepository)
//  initTransactionAggregate(sharding, coordinatorRepository, creditBalanceRepository)

  /**
   * Create an Action to render an HTML page.
   *
   * The configuration in the `routes` file means that this method
   * will be called when the application receives a `GET` request with
   * a path of `/`.
   */
  def index() = Action { implicit request: Request[AnyContent] =>
    Ok(views.html.index())
  }
  implicit val iMadzErrorFormat: OFormat[iMadzError] = Json.format[iMadzError]
  implicit val moneyFormat: Format[Money] = new Format[Money] {
    def writes(o: Money): JsValue = Json.obj(
      "amount" -> o.amount,
      "currency" -> o.currency.getCurrencyCode
    )
    def reads(json: JsValue): JsResult[Money] = for {
      amount <- (json \ "amount").validate[BigDecimal]
      currencyCode <- (json \ "currency").validate[String]
    } yield Money(amount, Currency.getInstance(currencyCode))
  }
  implicit val idFormat: Format[Id] = new Format[Id] {
    override def writes(o: Id): JsValue = JsString(o.toString)

    override def reads(json: JsValue): JsResult[Id] = JsSuccess(Id.of(json.toString()))
  }


  implicit val eitherErrorIdFormat: Format[Either[iMadzError, Id]] = new Format[Either[iMadzError, Id]] {
    def reads(json: JsValue): JsResult[Either[iMadzError, Id]] = {
      (json \ "error").toOption match {
        case Some(errorJson) => iMadzErrorFormat.reads(errorJson).map(Left(_))
        case None => (json \ "id").toOption match {
          case Some(idJson) => idFormat.reads(idJson).map(Right(_))
          case None => JsError("Invalid format: neither error nor id found")
        }
      }
    }

    def writes(either: Either[iMadzError, Id]): JsValue = either match {
      case Left(error) => Json.obj("error" -> iMadzErrorFormat.writes(error))
      case Right(id) => Json.obj("id" -> idFormat.writes(id))
    }
  }
  def getBalance(userId: String): Action[AnyContent] = Action.async { implicit request =>
    getBalanceQuery.fetchBalanceByUserId(Id.of(userId)).map { balance =>
      Ok(Json.toJson(balance)) // Assuming `balance` has a proper `toString` method
    }.recover {
      case ex: Exception => InternalServerError(ex.getMessage)
    }
  }

  implicit val creditBalanceConfirmationFormat: OFormat[CreditBalanceConfirmation] = Json.format[CreditBalanceConfirmation]

  def deposit(userId: String, amount: Double): Action[AnyContent] = Action.async { implicit request =>
    depositService.requestDeposit(Id.of(userId), Money(amount, Currency.getInstance("CNY"))).map { confirmation =>
      Ok(Json.toJson(confirmation))
    }.recover {
      case ex: Exception => InternalServerError(ex.getMessage)
    }
  }

  def withdraw(userId: String, amount: Double): Action[AnyContent] = Action.async { implicit request =>
    withdrawService.requestWithdraw(Id.of(userId), Money(amount, Currency.getInstance("CNY"))).map { confirmation =>
      Ok(Json.toJson(confirmation)) // Assuming `balance` has a proper `toString` method
    }.recover {
      case ex: Exception => InternalServerError(ex.getMessage)
    }
  }

  implicit val idWriter: Writes[Id] = new Writes[Id] {
    override def writes(o: Id): JsValue = JsString(o.toString)
  }
  def transfer(fromUserId: String, toUserId: String, amount: Double): Action[AnyContent] = Action.async { implicit request =>
    moneyTransferService.transfer(Id.of(fromUserId), Id.of(toUserId), Money(amount, Currency.getInstance("CNY"))).map { confirmation =>
      Ok(Json.toJson(confirmation))
    }.recover {
      case ex: Exception => InternalServerError(ex.getMessage)
    }
  }
}



==================================================
文件路径: app\controllers\filter\LoggingFilter.scala
==================================================

package controllers.filter

import akka.stream.Materializer
import play.api.Logging
import play.api.mvc._

import javax.inject.Inject
import scala.concurrent.{ExecutionContext, Future}

class LoggingFilter @Inject()(implicit val mat: Materializer, ec: ExecutionContext) extends Filter with Logging {
  def apply(nextFilter: RequestHeader => Future[Result])(requestHeader: RequestHeader): Future[Result] = {
    val startTime = System.currentTimeMillis

    nextFilter(requestHeader).map { result =>
      val endTime     = System.currentTimeMillis
      val requestTime = endTime - startTime

      logger.info(
        s"${requestHeader.method} ${requestHeader.uri} took ${requestTime}ms and returned ${result.header.status}"
      )

      result.withHeaders("Request-Time" -> requestTime.toString)
    }
  }
}

==================================================
文件路径: app\net\imadz\application\aggregates\CreditBalanceAggregate.scala
==================================================

package net.imadz.application.aggregates

import akka.actor.typed.ActorRef
import akka.cluster.sharding.typed.scaladsl.EntityTypeKey
import akka.persistence.typed.scaladsl.Effect
import net.imadz.application.aggregates.behaviors.CreditBalanceBehaviors
import net.imadz.common.CborSerializable
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.domain.entities.CreditBalanceEntity.{CreditBalanceEvent, CreditBalanceState}
import net.imadz.domain.values.Money

object CreditBalanceAggregate {

  // Commands Section
  sealed trait CreditBalanceCommand extends CborSerializable
  case class AddInitial(initial: Money, replyTo: ActorRef[CreditBalanceConfirmation]) extends CreditBalanceCommand
  case class Deposit(change: Money, replyTo: ActorRef[CreditBalanceConfirmation]) extends CreditBalanceCommand
  case class Withdraw(change: Money, replyTo: ActorRef[CreditBalanceConfirmation]) extends CreditBalanceCommand
  case class GetBalance(replyTo: ActorRef[CreditBalanceConfirmation]) extends CreditBalanceCommand

  case class ReserveFunds(transferId: Id, amount: Money, replyTo: ActorRef[FundsReservationConfirmation]) extends CreditBalanceCommand
  case class DeductFunds(transferId: Id, replyTo: ActorRef[FundsDeductionConfirmation]) extends CreditBalanceCommand
  case class ReleaseReservedFunds(transferId: Id, replyTo: ActorRef[FundsReleaseConfirmation]) extends CreditBalanceCommand

  case class RecordIncomingCredits(transferId: Id, amount: Money, replyTo: ActorRef[RecordIncomingCreditsConfirmation]) extends CreditBalanceCommand
  case class CommitIncomingCredits(transferId: Id, replyTo: ActorRef[CommitIncomingCreditsConfirmation]) extends CreditBalanceCommand
  case class CancelIncomingCredit(transferId: Id, replyTo: ActorRef[CancelIncomingCreditConfirmation]) extends CreditBalanceCommand



  // Command Replies
  case class CreditBalanceConfirmation(error: Option[iMadzError], balances: List[Money]) extends CborSerializable
  case class FundsReservationConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class FundsDeductionConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class FundsReleaseConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class RecordIncomingCreditsConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class CommitIncomingCreditsConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable
  case class CancelIncomingCreditConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable

  case class TransferConfirmation(transferId: Id, error: Option[iMadzError]) extends CborSerializable

  // Command Handler
  type CreditBalanceCommandHandler = (CreditBalanceState, CreditBalanceCommand) => Effect[CreditBalanceEvent, CreditBalanceState]

  def commandHandler: CreditBalanceCommandHandler = CreditBalanceBehaviors.apply

  // Akka
  val CreditBalanceEntityTypeKey: EntityTypeKey[CreditBalanceCommand] = EntityTypeKey("CreditBalance")
  val tags: Vector[String] = Vector.tabulate(5)(i => s"credit-balance-$i")
}


==================================================
文件路径: app\net\imadz\application\aggregates\behaviors\CreditBalanceBehaviors.scala
==================================================

package net.imadz.application.aggregates.behaviors

import akka.persistence.typed.scaladsl.Effect
import net.imadz.application.aggregates.CreditBalanceAggregate._
import net.imadz.common.CommonTypes.iMadzError
import net.imadz.common.application.CommandHandlerReplyingBehavior.runReplyingPolicy
import net.imadz.domain.entities.CreditBalanceEntity._
import net.imadz.domain.policy.{AddInitialOnlyOncePolicy, DepositPolicy, WithdrawPolicy}
import net.imadz.domain.services.TransferDomainService
import net.imadz.domain.values.Money

object CreditBalanceBehaviors {

  def apply: CreditBalanceCommandHandler = (state, command) =>
    directBehaviors(state)
      .orElse(reserveBehaviors(state))
      .orElse(incomingCreditBehaviors(state))
      .apply(command)


  private def directBehaviors(state: CreditBalanceState): PartialFunction[CreditBalanceCommand, Effect[CreditBalanceEvent, CreditBalanceState]] = {
    case AddInitial(initial, replyTo) =>
      runReplyingPolicy(AddInitialOnlyOncePolicy)(state, initial)
        .replyWith(replyTo)(mkError, mkLatestBalance)
    case Withdraw(change, replyTo) =>
      runReplyingPolicy(WithdrawPolicy)(state, change)
        .replyWith(replyTo)(mkError, mkLatestBalance)
    case Deposit(change, replyTo) =>
      runReplyingPolicy(DepositPolicy)(state, change)
        .replyWith(replyTo)(mkError, mkLatestBalance)
    case GetBalance(replyTo) =>
      Effect.reply(replyTo)(mkLatestBalance(None)(state))

  }

  private def reserveBehaviors(state: CreditBalanceState): PartialFunction[CreditBalanceCommand, Effect[CreditBalanceEvent, CreditBalanceState]] = {
    case ReserveFunds(transferId, amount, replyTo) =>
      val currentBalance = state.accountBalance.getOrElse(amount.currency.getCurrencyCode, Money(BigDecimal(0), amount.currency))
      TransferDomainService.validateTransfer(transferId, state.reservedAmount, currentBalance, amount) match {
        case Right(_) =>
          Effect.persist(FundsReserved(transferId, amount))
            .thenReply(replyTo)(_ => FundsReservationConfirmation(transferId, None))
        case Left(iMadzError("60008", _)) =>
          Effect.reply(replyTo)(FundsReservationConfirmation(transferId, None))
        case Left(error) =>
          Effect.reply(replyTo)(FundsReservationConfirmation(transferId, Some(error)))
      }
    case DeductFunds(transferId, replyTo) =>
      state.reservedAmount.get(transferId) match {
        case Some(reservedAmount) =>
          Effect.persist(FundsDeducted(transferId, reservedAmount))
            .thenReply(replyTo)(_ => FundsDeductionConfirmation(transferId, None))
        case None =>
          Effect.reply(replyTo)(FundsDeductionConfirmation(transferId, Some(iMadzError("60006", "No reserved funds found for this transfer"))))
      }
    case ReleaseReservedFunds(transferId, replyTo) =>
      state.reservedAmount.get(transferId) match {
        case Some(reservedAmount) =>
          Effect.persist(ReservationReleased(transferId, reservedAmount))
            .thenReply(replyTo)(_ => FundsReleaseConfirmation(transferId, None))
        case None =>
          Effect.reply(replyTo)(FundsReleaseConfirmation(transferId, Some(iMadzError("60006", "No reserved funds found for this transfer"))))
      }
  }

  private def incomingCreditBehaviors(state: CreditBalanceState): PartialFunction[CreditBalanceCommand, Effect[CreditBalanceEvent, CreditBalanceState]] = {

    case RecordIncomingCredits(transferId, amount, replyTo) =>
      state.incomingCredits.get(transferId) match {
        case Some(_) =>
          Effect
            .reply(replyTo)(RecordIncomingCreditsConfirmation(transferId = transferId, error = Some(iMadzError("60007", "incoming credits already registered"))))
        case None =>
          Effect
            .persist(IncomingCreditsRecorded(transferId, amount))
            .thenReply(replyTo)(_ => RecordIncomingCreditsConfirmation(transferId, None))
      }
    case CommitIncomingCredits(transferId, replyTo) =>
      state.incomingCredits.get(transferId) match {
        case Some(_) =>
          Effect
            .persist(IncomingCreditsCommited(transferId))
            .thenReply(replyTo)(_ => CommitIncomingCreditsConfirmation(transferId, None))
        case None =>
          Effect.reply(replyTo)(CommitIncomingCreditsConfirmation(transferId, Some(iMadzError("60008", "incoming credits cannot be found or already be committed before"))))
      }
    case CancelIncomingCredit(transferId, replyTo) =>
      state.incomingCredits.get(transferId) match {
        case Some(_) =>
          Effect.persist(IncomingCreditsCanceled(transferId))
            .thenReply(replyTo)(_ => CancelIncomingCreditConfirmation(transferId, None))
        case None =>
          Effect
            .reply(replyTo)(CancelIncomingCreditConfirmation(transferId, Some(iMadzError("60009", "incoming credits cannot be found or already be canceled before"))))

      }
  }

  private def mkLatestBalance[Param](param: Param)(updatedState: CreditBalanceState) =
    CreditBalanceConfirmation(None, updatedState.accountBalance.values.toList)

  private def mkError[Param](param: Param)(error: iMadzError) =
    CreditBalanceConfirmation(Some(error), Nil)

}


==================================================
文件路径: app\net\imadz\application\aggregates\factories\CreditBalanceAggregateFactory.scala
==================================================

package net.imadz.application.aggregates.factories

import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, EntityRef}
import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate.{AddInitial, CreditBalanceCommand, CreditBalanceConfirmation, CreditBalanceEntityTypeKey}
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

case class CreditBalanceAggregateFactory @Inject()(clusterSharding: ClusterSharding) {
  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def createCreditBalanceWithoutBalance(userId: Id): EntityRef[CreditBalanceCommand] =
    clusterSharding.entityRefFor(CreditBalanceEntityTypeKey, userId.toString)

  def createCreditBalanceWithDefaultBalance(userId: Id, initial: Money): Future[Either[iMadzError, EntityRef[CreditBalanceCommand]]] = {
    val entityRef: EntityRef[CreditBalanceCommand] = clusterSharding
      .entityRefFor[CreditBalanceCommand](CreditBalanceEntityTypeKey, userId.toString)
    for {
      confirmation <- entityRef.ask[CreditBalanceConfirmation](AddInitial(initial, _))
    } yield {
      confirmation.error
        .map(Left.apply[iMadzError, EntityRef[CreditBalanceCommand]])
        .getOrElse(Right(entityRef))
    }
  }

}


==================================================
文件路径: app\net\imadz\application\aggregates\repository\CreditBalanceRepository.scala
==================================================

package net.imadz.application.aggregates.repository

import akka.cluster.sharding.typed.scaladsl.EntityRef
import com.google.inject.ImplementedBy
import net.imadz.application.aggregates.CreditBalanceAggregate.CreditBalanceCommand
import net.imadz.common.CommonTypes.Id
import net.imadz.infrastructure.repositories.aggregate.CreditBalanceRepositoryImpl

@ImplementedBy(classOf[CreditBalanceRepositoryImpl])
trait CreditBalanceRepository {

  def findCreditBalanceByUserId(userId: Id): EntityRef[CreditBalanceCommand]

}


==================================================
文件路径: app\net\imadz\application\projection\MonthlyIncomeAndExpenseSummaryProjection.scala
==================================================

package net.imadz.application.projection

import akka.actor.typed.ActorSystem
import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import akka.contrib.persistence.mongodb.MongoReadJournal
import akka.persistence.query.Offset
import akka.projection.eventsourced.EventEnvelope
import akka.projection.eventsourced.scaladsl.EventSourcedProvider
import akka.projection.jdbc.scaladsl.JdbcProjection
import akka.projection.scaladsl.{ExactlyOnceProjection, SourceProvider}
import akka.projection.{ProjectionId, eventsourced}
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.domain.entities.CreditBalanceEntity.CreditBalanceEvent
import net.imadz.infrastructure.proto.credits.CreditBalanceEventPO

object MonthlyIncomeAndExpenseSummaryProjection {

  val projectionName = "MonthlyIncomeAndExpenseSummary"


  def createProjection(system: ActorSystem[_], sharding: ClusterSharding, index: Int, repository: MonthlyIncomeAndExpenseSummaryRepository): ExactlyOnceProjection[Offset, EventEnvelope[CreditBalanceEventPO.Event]] = {
    val sourceProvider: SourceProvider[Offset, eventsourced.EventEnvelope[CreditBalanceEventPO.Event]] = EventSourcedProvider
      .eventsByTag(system = system,
        readJournalPluginId = MongoReadJournal.Identifier,
        tag = CreditBalanceAggregate.tags(index))

    JdbcProjection.exactlyOnce(
      projectionId = ProjectionId(projectionName, CreditBalanceAggregate.tags(index)),
      sourceProvider = sourceProvider,
      sessionFactory = () => new ScalikeJdbcSession(),
      handler = () => MonthlyIncomeAndExpenseSummaryProjectionHandler(sharding, repository)
    )(system)
  }
}


==================================================
文件路径: app\net\imadz\application\projection\MonthlyIncomeAndExpenseSummaryProjectionHandler.scala
==================================================

package net.imadz.application.projection

import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import akka.projection.eventsourced
import akka.projection.eventsourced.EventEnvelope
import akka.projection.jdbc.scaladsl.JdbcHandler
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.domain.entities.CreditBalanceEntity.BalanceChanged
import net.imadz.infrastructure.persistence.CreditBalanceEventAdapter
import net.imadz.infrastructure.proto.credits.{CreditBalanceEventPO => CreditEventPO}

import java.time.{Instant, LocalDateTime, ZoneId}

case class MonthlyIncomeAndExpenseSummaryProjectionHandler(sharding: ClusterSharding,
                                                           repository: MonthlyIncomeAndExpenseSummaryRepository) extends JdbcHandler[eventsourced.EventEnvelope[CreditEventPO.Event], ScalikeJdbcSession] {
  val adapter = new CreditBalanceEventAdapter

  override def process(session: ScalikeJdbcSession, envelope: EventEnvelope[CreditEventPO.Event]): Unit = {
    adapter.fromJournal(envelope.event, "").events.foreach {
      case BalanceChanged(update, timestamp) =>
        val (year, month, day) = getDateFromTimestamp(timestamp)
        val userId = envelope.persistenceId
        if (update.amount > 0)
          repository.updateIncome(userId, update.amount, year, month, day)
        else {
          repository.updateExpense(userId, -update.amount, year, month, day)
        }
      case _ =>
        ()
    }
  }

  private def getDateFromTimestamp(timestamp: Long): (Int, Int, Int) = {
    val instant = Instant.ofEpochMilli(timestamp)
    val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())
    val year = dateTime.getYear
    val month = dateTime.getMonthValue
    val day = dateTime.getDayOfMonth
    (year, month, day)
  }
}


==================================================
文件路径: app\net\imadz\application\projection\ScalikeJdbcSession.scala
==================================================

package net.imadz.application.projection

import akka.japi.function.Function
import akka.projection.jdbc.JdbcSession
import scalikejdbc.DB
import java.sql.Connection

object ScalikeJdbcSession {
  def withSession[R](f: ScalikeJdbcSession => R): R = {
    val session = new ScalikeJdbcSession()
    try {
      f(session)
    } finally {
      session.close()
    }
  }
}

/**
 * Provide database connections within a transaction to Akka Projections.
 */
final class ScalikeJdbcSession extends JdbcSession {
  val db: DB = DB.connect()
  db.autoClose(false)

  override def withConnection[Result](func: Function[Connection, Result]): Result = {
    db.begin()
    db.withinTxWithConnection(func(_))
  }

  override def commit(): Unit = db.commit()

  override def rollback(): Unit = db.rollback()

  override def close(): Unit = db.close()
}


==================================================
文件路径: app\net\imadz\application\projection\ScalikeJdbcSetup.scala
==================================================

package net.imadz.application.projection

import akka.actor.typed.ActorSystem
import com.typesafe.config.Config
import com.zaxxer.hikari.HikariDataSource
import scalikejdbc.config.{DBs, NoEnvPrefix, TypesafeConfig, TypesafeConfigReader}
import scalikejdbc.{ConnectionPool, DataSourceCloser, DataSourceConnectionPool}

object ScalikeJdbcSetup {

  /**
   * Initiate the ScalikeJDBC connection pool configuration and shutdown.
   * The DataSource is setup with ActorSystem's config.
   *
   * The connection pool will be closed when the actor system terminates.
   */
  def init(system: ActorSystem[_]): Unit = {
    initFromConfig(system.settings.config)
    system.whenTerminated.map { _ =>
      ConnectionPool.closeAll()
    }(scala.concurrent.ExecutionContext.Implicits.global)

  }

  /**
   * Builds a Hikari DataSource with values from jdbc-connection-settings.
   * The DataSource is then configured as the 'default' connection pool for ScalikeJDBC.
   */
  private def initFromConfig(config: Config): Unit = {

    val dbs = new DBsFromConfig(config)
    dbs.loadGlobalSettings()

    val dataSource = buildDataSource(
      config.getConfig("jdbc-connection-settings"))

    ConnectionPool.singleton(
      new DataSourceConnectionPool(
        dataSource = dataSource,
        closer = HikariCloser(dataSource)))
  }

  private def buildDataSource(config: Config): HikariDataSource = {
    val dataSource = new HikariDataSource()

    dataSource.setPoolName("read-side-connection-pool")
    dataSource.setMaximumPoolSize(
      config.getInt("connection-pool.max-pool-size"))

    val timeout = config.getDuration("connection-pool.timeout").toMillis
    dataSource.setConnectionTimeout(timeout)

    dataSource.setDriverClassName(config.getString("driver"))
    dataSource.setJdbcUrl(config.getString("url"))
    dataSource.setUsername(config.getString("user"))
    dataSource.setPassword(config.getString("password"))

    dataSource
  }

  /**
   * This is only needed to allow ScalikeJdbc to load its logging configurations from the passed Config
   */
  private class DBsFromConfig(val config: Config)
      extends DBs
      with TypesafeConfigReader
      with TypesafeConfig
      with NoEnvPrefix

  /**
   * ScalikeJdbc needs a closer for the DataSource to delegate the closing call.
   */
  private case class HikariCloser(dataSource: HikariDataSource)
      extends DataSourceCloser {
    override def close(): Unit = dataSource.close()
  }

}


==================================================
文件路径: app\net\imadz\application\projection\repository\MonthlyIncomeAndExpendsSummaryRepository.scala
==================================================

package net.imadz.application.projection.repository

import com.google.inject.ImplementedBy
import net.imadz.infrastructure.repositories.projection.MonthlyIncomeAndExpenseSummaryRepositoryImpl

import scala.concurrent.Future

object MonthlyIncomeAndExpenseSummaryTable {
  case class MonthlyIncomeAndExpenseSummary(userId: String, income: BigDecimal, expense: BigDecimal, year: Int, month: Int)
}

@ImplementedBy(classOf[MonthlyIncomeAndExpenseSummaryRepositoryImpl])
trait MonthlyIncomeAndExpenseSummaryRepository {

  import MonthlyIncomeAndExpenseSummaryTable._

  def filterByPeriodLCRO(userId: String, startFromYear: Int, startFromMonth: Int, untilYear: Int, untilMonth: Int): Future[List[MonthlyIncomeAndExpenseSummary]]

  def updateIncome(userId: String, amount: BigDecimal, year: Int, month: Int, day: Int): Unit

  def updateExpense(userId: String, amount: BigDecimal, year: Int, month: Int, day: Int): Unit

}

==================================================
文件路径: app\net\imadz\application\queries\GetBalanceQuery.scala
==================================================

package net.imadz.application.queries

import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate.GetBalance
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

class GetBalanceQuery @Inject()(creditBalanceRepository: CreditBalanceRepository) {

  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def fetchBalanceByUserId(userId: Id): Future[List[Money]] =
    creditBalanceRepository.findCreditBalanceByUserId(userId)
      .ask(GetBalance)
      .map(confirmation => confirmation.error.map(_ => Nil).getOrElse(confirmation.balances))

}


==================================================
文件路径: app\net\imadz\application\queries\GetRecent12MonthsIncomeAndExpenseReport.scala
==================================================

package net.imadz.application.queries

import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.application.queries.GetRecent12MonthsIncomeAndExpenseReport.{MonthlyIncomeAndExpense, Recent12MonthsIncomeAndExpenseReport}
import net.imadz.common.CommonTypes.{Id, ReadModel}

import java.time.{LocalDate, YearMonth}
import javax.inject.Inject
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

object GetRecent12MonthsIncomeAndExpenseReport {

  case class MonthlyIncomeAndExpense(year: Int, month: Int, incomeTotal: BigDecimal, expenseTotal: BigDecimal)

  case class Recent12MonthsIncomeAndExpenseReport(monthlySummaries: List[MonthlyIncomeAndExpense]) extends ReadModel
}

class GetRecent12MonthsIncomeAndExpenseReport @Inject()(repository: MonthlyIncomeAndExpenseSummaryRepository) {

  def fetchByUserId(userId: Id): Future[Recent12MonthsIncomeAndExpenseReport] = {
    val now = LocalDate.now()
    val untilYearMonth = YearMonth.from(now)
    val startFromYearMonth = untilYearMonth.minusMonths(11)

    val startFromYear = startFromYearMonth.getYear
    val startFromMonth = startFromYearMonth.getMonthValue
    val untilYear = untilYearMonth.getYear
    val untilMonth = untilYearMonth.getMonthValue

    repository.filterByPeriodLCRO(userId.toString, startFromYear, startFromMonth, untilYear, untilMonth)
      .map(xs => Recent12MonthsIncomeAndExpenseReport(
        xs.map(x => MonthlyIncomeAndExpense(x.year, x.month, x.income, x.expense))
      ))
  }
}


==================================================
文件路径: app\net\imadz\application\services\CreateCreditBalanceService.scala
==================================================

package net.imadz.application.services

import akka.cluster.sharding.typed.scaladsl.EntityRef
import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.CreditBalanceAggregate.GetBalance
import net.imadz.application.aggregates.factories.CreditBalanceAggregateFactory
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

class CreateCreditBalanceService @Inject()(factory: CreditBalanceAggregateFactory) {
  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def createCreditBalance(userId: Id): Future[Either[iMadzError, List[Money]]] = {
    val entityRef = factory.createCreditBalanceWithoutBalance(userId)
    fetchUserCreditBalance(entityRef)
  }

  def createCreditBalance(userId: Id, initial: Money): Future[Either[iMadzError, List[Money]]] = {
    factory.createCreditBalanceWithDefaultBalance(userId, initial)
      .flatMap(either => either.fold(
        err => Future.successful(Left(err)),
        fetchUserCreditBalance))
  }

  private def fetchUserCreditBalance(entityRef: EntityRef[CreditBalanceAggregate.CreditBalanceCommand]) = {
    entityRef
      .ask(GetBalance.apply)
      .map(confirmation =>
        confirmation.error
          .map(Left.apply[iMadzError, List[Money]])
          .getOrElse(Right(confirmation.balances)))
  }
}


==================================================
文件路径: app\net\imadz\application\services\DepositService.scala
==================================================

package net.imadz.application.services

import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.CreditBalanceAggregate.Deposit
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

class DepositService @Inject()(creditBalanceRepository: CreditBalanceRepository) {

  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def requestDeposit(userId: Id, amount: Money): Future[CreditBalanceAggregate.CreditBalanceConfirmation] =
    creditBalanceRepository.findCreditBalanceByUserId(userId)
      .ask(Deposit(amount, _))
}


==================================================
文件路径: app\net\imadz\application\services\MoneyTransferService.scala
==================================================

package net.imadz.application.services

import akka.actor.typed.scaladsl.AskPattern.Askable
import akka.actor.typed.{ActorRef, ActorSystem, Scheduler}
import akka.util.Timeout
import net.imadz.application.services.transactor.MoneyTransferSagaTransactor._
import net.imadz.application.services.transactor.MoneyTransferTransactionRepository
import net.imadz.common.CommonTypes.{ApplicationService, Id}
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.duration._
import scala.concurrent.{ExecutionContext, Future}


class MoneyTransferService @Inject()(system: ActorSystem[_], transactionRepository: MoneyTransferTransactionRepository) extends ApplicationService {
  private implicit val timeout: Timeout = 120.seconds
  private implicit val ec: ExecutionContext = system.executionContext
  implicit val scheduler: Scheduler = system.scheduler


  def transfer(fromUserId: Id, toUserId: Id, amount: Money): Future[TransactionResultConfirmation] = {
    val transactionId = java.util.UUID.randomUUID()
    for {
      completionResult <- initiateTransaction(fromUserId, toUserId, amount, transactionId)
    } yield completionResult
  }

  private def initiateTransaction(fromUserId: Id, toUserId: Id, amount: Money, transactionId: Id): Future[TransactionResultConfirmation] = {
    val transactionRef = getTransactionRef(transactionId)
    transactionRef.ask(ref => InitiateMoneyTransferTransaction(fromUserId, toUserId, amount, ref))
  }


  private def getTransactionRef(transactionId: Id): ActorRef[MoneyTransferTransactionCommand] = {
    transactionRepository.findTransactionById(transactionId)
  }
}

==================================================
文件路径: app\net\imadz\application\services\WithdrawService.scala
==================================================

package net.imadz.application.services

import akka.util.Timeout
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.CreditBalanceAggregate.Withdraw
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id
import net.imadz.domain.values.Money

import javax.inject.Inject
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

class WithdrawService @Inject()(creditBalanceRepository: CreditBalanceRepository) {
  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def requestWithdraw(userId: Id, amount: Money): Future[CreditBalanceAggregate.CreditBalanceConfirmation] =
    creditBalanceRepository.findCreditBalanceByUserId(userId)
      .ask(Withdraw(amount, _))
}


==================================================
文件路径: app\net\imadz\application\services\transactor\MoneyTransferSagaTransactor.scala
==================================================

package net.imadz.application.services.transactor

import akka.actor.typed.ActorRef
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.{Id, iMadzError}
import net.imadz.common.{CborSerializable, Id}
import net.imadz.domain.values.Money
import net.imadz.infra.saga.SagaParticipant._
import net.imadz.infra.saga.SagaPhase.{CommitPhase, CompensatePhase, PreparePhase}
import net.imadz.infra.saga.SagaTransactionCoordinator.{TracingStep, TransactionResult}
import net.imadz.infra.saga.{SagaParticipant, SagaTransactionStep}
import play.api.libs.json.{Json, OWrites}

import scala.concurrent.ExecutionContext

object MoneyTransferSagaTransactor {
  // Commands
  sealed trait MoneyTransferTransactionCommand

  case class InitiateMoneyTransferTransaction(fromUserId: Id, toUserId: Id, amount: Money, replyTo: ActorRef[TransactionResultConfirmation]) extends MoneyTransferTransactionCommand

  case class UpdateMoneyTransferTransactionStatus(id: Id, newStatus: TransactionResult, replyTo: ActorRef[TransactionResultConfirmation]) extends MoneyTransferTransactionCommand

  // Command Replies
  case class TransactionResultConfirmation(transactionId: Id, error: Option[String], tracing: List[TracingStep]) extends CborSerializable

  object TransactionResultConfirmation {
    implicit val confirmationWrites: OWrites[TransactionResultConfirmation] = Json.writes[TransactionResultConfirmation]
  }

  // Transaction Steps
  def createTransactionSteps(fromUserId: Id, toUserId: Id, amount: Money, repository: CreditBalanceRepository)(implicit ec: ExecutionContext): List[SagaTransactionStep[iMadzError, String]] = {
    val fromAccountParticipant = new FromAccountParticipant(fromUserId: Id, amount: Money, repository)
    val toAccountParticipant = new ToAccountParticipant(toUserId: Id, amount: Money, repository)

    List(
      SagaTransactionStep("reserve-amount-from-account", PreparePhase, fromAccountParticipant, 5),
      SagaTransactionStep("record-incoming-amount-to-account", PreparePhase, toAccountParticipant, 5),
      SagaTransactionStep("commit-from-account", CommitPhase, fromAccountParticipant, 5),
      SagaTransactionStep("commit-to-account", CommitPhase, toAccountParticipant, 5),
      SagaTransactionStep("compensate-from-account", CompensatePhase, fromAccountParticipant, 5),
      SagaTransactionStep("compensate-to-account", CompensatePhase, toAccountParticipant, 5)
    )
  }

  // Participants

  import akka.util.Timeout
  import net.imadz.application.aggregates.CreditBalanceAggregate._

  import scala.concurrent.ExecutionContext
  import scala.concurrent.duration._

  case class FromAccountParticipant(fromUserId: Id, amount: Money, repo: CreditBalanceRepository)(implicit ec: ExecutionContext) extends SagaParticipant[iMadzError, String] {

    implicit val timeout: Timeout = 5.seconds
    private val fromAccountRef = repo.findCreditBalanceByUserId(fromUserId)

    override def doPrepare(transactionId: String): ParticipantEffect[iMadzError, String] = {
      fromAccountRef.ask(CreditBalanceAggregate.ReserveFunds(Id.of(transactionId), amount, _))
        .mapTo[FundsReservationConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override def doCommit(transactionId: String): ParticipantEffect[iMadzError, String] = {
      fromAccountRef.ask(CreditBalanceAggregate.DeductFunds(Id.of(transactionId), _))
        .mapTo[FundsDeductionConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override def doCompensate(transactionId: String): ParticipantEffect[iMadzError, String] = {
      fromAccountRef.ask(CreditBalanceAggregate.ReleaseReservedFunds(Id.of(transactionId), _))
        .mapTo[FundsReleaseConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override protected def customClassification: PartialFunction[Throwable, SagaParticipant.RetryableOrNotException] = {
      case iMadzError("60003", message) => NonRetryableFailure(message)
      case iMadzError("60004", message) => NonRetryableFailure(message)
      case iMadzError(code, message) => NonRetryableFailure(message)
    }
  }

  case class ToAccountParticipant(toUserId: Id, amount: Money, repo: CreditBalanceRepository)(implicit ec: ExecutionContext) extends SagaParticipant[iMadzError, String] {
    private val toAccountRef = repo.findCreditBalanceByUserId(toUserId)

    implicit val timeout: Timeout = 5.seconds

    override def doPrepare(transactionId: String): ParticipantEffect[iMadzError, String] = {
      toAccountRef.ask(CreditBalanceAggregate.RecordIncomingCredits(Id.of(transactionId), amount, _))
        .mapTo[RecordIncomingCreditsConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override def doCommit(transactionId: String): ParticipantEffect[iMadzError, String] = {
      toAccountRef.ask(CreditBalanceAggregate.CommitIncomingCredits(Id.of(transactionId), _))
        .mapTo[CommitIncomingCreditsConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override def doCompensate(transactionId: String): ParticipantEffect[iMadzError, String] = {
      toAccountRef.ask(CreditBalanceAggregate.CancelIncomingCredit(Id.of(transactionId), _))
        .mapTo[CancelIncomingCreditConfirmation]
        .map(confirmation => {
          confirmation.error.map(Left.apply)
            .getOrElse(Right(SagaResult(confirmation.transferId.toString)))
        })
    }

    override protected def customClassification: PartialFunction[Throwable, SagaParticipant.RetryableOrNotException] = {
      case iMadzError("60003", message) => NonRetryableFailure(message)
      case iMadzError("60004", message) => NonRetryableFailure(message)
      case iMadzError(code, message) => NonRetryableFailure(message)
    }
  }


}

==================================================
文件路径: app\net\imadz\application\services\transactor\MoneyTransferSagaTransactorBehaviors.scala
==================================================

package net.imadz.application.services.transactor

import akka.actor.typed.scaladsl.{ActorContext, Behaviors}
import akka.actor.typed.{Behavior, Scheduler}
import akka.cluster.sharding.typed.scaladsl.EntityRef
import akka.util.Timeout
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.application.services.transactor.MoneyTransferSagaTransactor._
import net.imadz.common.CommonTypes.iMadzError
import net.imadz.common.Id
import net.imadz.infra.saga.SagaTransactionCoordinator
import net.imadz.infra.saga.SagaTransactionCoordinator.TransactionResult

import scala.concurrent.ExecutionContext
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps

object MoneyTransferSagaTransactorBehaviors {
  implicit val askTimeout: Timeout = Timeout(30 seconds)

  def apply(context: ActorContext[MoneyTransferTransactionCommand], coordinator: EntityRef[SagaTransactionCoordinator.Command], repository: CreditBalanceRepository)(implicit ec: ExecutionContext, scheduler: Scheduler): Behavior[MoneyTransferTransactionCommand] =
    Behaviors.receiveMessage {
      case InitiateMoneyTransferTransaction(fromUserId, toUserId, amount, replyTo) =>
        val transactionId = Id.gen.toString
        val steps = createTransactionSteps(fromUserId, toUserId, amount, repository)

        coordinator.ask[TransactionResult](intermediateReplyTo =>
          SagaTransactionCoordinator.StartTransaction[iMadzError, String](transactionId, steps, Some(intermediateReplyTo)))
          .mapTo[TransactionResult]
          .foreach(context.self ! UpdateMoneyTransferTransactionStatus(Id.of(transactionId), _, replyTo))

        Behaviors.same

      case UpdateMoneyTransferTransactionStatus(id, transactionResponse, replyTo) =>
        if (transactionResponse.successful) {
          replyTo ! TransactionResultConfirmation(id, None, transactionResponse.tracingSteps)
        } else {
          replyTo ! TransactionResultConfirmation(id, Some(transactionResponse.failReason), transactionResponse.tracingSteps)
        }
        Behaviors.stopped
    }
}

==================================================
文件路径: app\net\imadz\application\services\transactor\MoneyTransferTransactionRepository.scala
==================================================

package net.imadz.application.services.transactor

import akka.actor.typed.ActorRef
import com.google.inject.ImplementedBy
import net.imadz.common.CommonTypes.Id
import net.imadz.infrastructure.repositories.service.MoneyTransferTransactionRepositoryImpl

@ImplementedBy(classOf[MoneyTransferTransactionRepositoryImpl])
trait MoneyTransferTransactionRepository {

  def findTransactionById(transaction: Id): ActorRef[MoneyTransferSagaTransactor.MoneyTransferTransactionCommand]
}


==================================================
文件路径: app\net\imadz\common\CborSerializable.scala
==================================================

package net.imadz.common

trait CborSerializable {

}


==================================================
文件路径: app\net\imadz\common\CommonTypes.scala
==================================================

package net.imadz.common

import net.imadz.common.CommonTypes.Id

import java.util.UUID

object CommonTypes {

  type Id = UUID

  final case class iMadzError(code: String, message: String) extends Throwable with CborSerializable

  trait ReadModel

  trait DomainPolicy[Event, State, Param] {
    def apply(state: State, param: Param): Either[iMadzError, List[Event]]
  }

  trait DomainService

  trait ApplicationService
}

object Id {
  def of(value: String): Id = UUID.fromString(value)

  def gen: Id = java.util.UUID.randomUUID()
}

==================================================
文件路径: app\net\imadz\common\application\CommandHandlerReplyingBehavior.scala
==================================================

package net.imadz.common.application

import akka.actor.typed.ActorRef
import akka.persistence.typed.scaladsl.Effect
import net.imadz.common.CommonTypes.{DomainPolicy, iMadzError}

object CommandHandlerReplyingBehavior {

  case class AwaitingReplyToRunnablePolicy[Event, State, Param, ReplyMessage](policy: DomainPolicy[Event, State, Param], state: State, param: Param) {
    def replyWith(replyTo: ActorRef[ReplyMessage])(leftConfirmationFactory: Param => iMadzError => ReplyMessage, rightConfirmationFactory: Param => State => ReplyMessage): Effect[Event, State] =
      policy(state, param).fold(
        error => Effect.reply(replyTo)(leftConfirmationFactory(param)(error)),
        events => Effect.persist(events).thenReply(replyTo)(rightConfirmationFactory(param)))
  }

  def runReplyingPolicy[Event, State, Param, ReplyMessage](policy: DomainPolicy[Event, State, Param])(state: State, param: Param): AwaitingReplyToRunnablePolicy[Event, State, Param, ReplyMessage] =
    AwaitingReplyToRunnablePolicy(policy = policy, state = state, param = param)
}

==================================================
文件路径: app\net\imadz\common\serialization\ObjectIdOffsetSerializer.scala
==================================================

package net.imadz.common.serialization

import akka.contrib.persistence.mongodb.ObjectIdOffset
import akka.serialization.Serializer
import reactivemongo.api.bson.BSONObjectID

import java.math.BigInteger

class ObjectIdOffsetSerializer extends Serializer {
  override def identifier: Int = 20160728

  override def toBinary(o: AnyRef): Array[Byte] = o match {
    case ObjectIdOffset(hexString, _) =>
      new BigInteger(hexString, 16).toByteArray
    case _ => throw new IllegalArgumentException("Only for ObjectIdOffset")
  }

  override def includeManifest: Boolean = true

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef = {
    BSONObjectID.parse((new BigInteger(bytes)).toString(16))
      .map(id => ObjectIdOffset(id.stringify, id.time))
      .getOrElse(throw new IllegalStateException("Only for ObjectIdOffset"))
  }
}


==================================================
文件路径: app\net\imadz\domain\entities\CreditBalanceEntity.scala
==================================================

package net.imadz.domain.entities

import net.imadz.common.CommonTypes.Id
import net.imadz.domain.values.Money


object CreditBalanceEntity {

  // @formatter:off
  // State
  case class CreditBalanceState(userId: Id, accountBalance: Map[String, Money], reservedAmount: Map[Id, Money], incomingCredits: Map[Id, Money])

  def empty(userId: Id): CreditBalanceState = CreditBalanceState(userId, Map.empty, Map.empty, Map.empty)

  // Event
  sealed trait CreditBalanceEvent
  case class BalanceChanged(update: Money, timestamp: Long = System.currentTimeMillis()) extends CreditBalanceEvent
  case class FundsReserved(transferId: Id, amount: Money) extends CreditBalanceEvent
  case class FundsDeducted(transferId: Id, amount: Money) extends CreditBalanceEvent
  case class ReservationReleased(transferId: Id, amount: Money) extends CreditBalanceEvent
  case class IncomingCreditsRecorded(transferId: Id, amount: Money) extends CreditBalanceEvent
  case class IncomingCreditsCommited(transferId: Id) extends CreditBalanceEvent
  case class IncomingCreditsCanceled(transferId: Id) extends CreditBalanceEvent
  // @formatter:on

  // Event Handler Extension Point
  type CreditBalanceEventHandler = (CreditBalanceState, CreditBalanceEvent) => CreditBalanceState

}

==================================================
文件路径: app\net\imadz\domain\entities\behaviors\CreditBalanceEventHandler.scala
==================================================

package net.imadz.domain.entities.behaviors

import net.imadz.common.CommonTypes.Id
import net.imadz.domain.entities.CreditBalanceEntity.{BalanceChanged, CreditBalanceEventHandler, CreditBalanceState}
import net.imadz.domain.values.Money

import java.util.Currency
import net.imadz.domain.entities.CreditBalanceEntity._

object CreditBalanceEventHandler {
  def apply: CreditBalanceEventHandler = (state, event) => event match {
    case BalanceChanged(updateMoney@Money(_, currency), _) =>
      state.copy(accountBalance = updateAccountBalance(state, currency, updateMoney))

    case FundsReserved(transferId, reserveAmount@Money(_, currency)) =>
      state.copy(
        accountBalance = updateAccountBalance(state, currency, reserveAmount.copy(amount = -reserveAmount.amount)),
        reservedAmount = state.reservedAmount + (transferId -> reserveAmount)
      )
    case FundsDeducted(transferId: Id, amount: Money) =>
      state.copy(
        reservedAmount = state.reservedAmount - transferId
      )
    case ReservationReleased(transferId, releaseAmount@Money(_, currency)) =>
      state.copy(
        accountBalance = updateAccountBalance(state, currency, releaseAmount),
        reservedAmount = state.reservedAmount - transferId
      )

    case IncomingCreditsRecorded(transferId, amount) =>
      state.copy(
        incomingCredits = state.incomingCredits + (transferId -> amount)
      )
    case IncomingCreditsCommited(transferId) =>
      state.copy(
        accountBalance= updateAccountBalance(state, state.incomingCredits(transferId).currency, state.incomingCredits(transferId)),
        incomingCredits = state.incomingCredits - transferId
      )
    case IncomingCreditsCanceled(transferId) =>
      state.copy(
        incomingCredits = state.incomingCredits - transferId
      )

  }

  private def updateAccountBalance(state: CreditBalanceState, currency: Currency, updateMoney: Money): Map[String, Money] = {
    val currentBalance = state.accountBalance.getOrElse(currency.getCurrencyCode, Money(BigDecimal(0), currency))
    state.accountBalance + (currency.getCurrencyCode -> (currentBalance + updateMoney).getOrElse(Money(BigDecimal(0), currency)))
  }

  private def defaultMoney(currency: Currency) = {
    Money(BigDecimal(0), currency)
  }

  private def originalMoney(balanceMap: Map[String, Money], currency: Currency): Money = {
    balanceMap.getOrElse(currency.getCurrencyCode, defaultMoney(currency))
  }
}

==================================================
文件路径: app\net\imadz\domain\policy\AddInitialOnlyOncePolicy.scala
==================================================

package net.imadz.domain.policy

import net.imadz.common.CommonTypes.{DomainPolicy, iMadzError}
import net.imadz.domain.entities.CreditBalanceEntity.{BalanceChanged, CreditBalanceEvent, CreditBalanceState}
import net.imadz.domain.values.Money

object AddInitialOnlyOncePolicy extends DomainPolicy[CreditBalanceEvent, CreditBalanceState, Money] {

  private val InitialConditionNotMeet: iMadzError = iMadzError("60000", "不满足 Initial 条件")

  def apply(creditBalanceState: CreditBalanceState, initial: Money): Either[iMadzError, List[CreditBalanceEvent]] =
    if (creditBalanceState.accountBalance.values.exists(_.amount > 0)) Left(InitialConditionNotMeet)
    else Right(List(BalanceChanged(initial)))


}


==================================================
文件路径: app\net\imadz\domain\policy\DepositPolicy.scala
==================================================

package net.imadz.domain.policy

import net.imadz.common.CommonTypes.{DomainPolicy, iMadzError}
import net.imadz.domain.entities.CreditBalanceEntity.{BalanceChanged, CreditBalanceEvent, CreditBalanceState}
import net.imadz.domain.values.Money

object DepositPolicy extends DomainPolicy[CreditBalanceEvent, CreditBalanceState, Money] {
  private val ChangeShouldBePositive: iMadzError = iMadzError("60001", "change 需要为正数")

  def apply(state: CreditBalanceState, change: Money): Either[iMadzError, List[CreditBalanceEvent]] =
    if (change.amount <= 0) Left(ChangeShouldBePositive)
    else Right(List(BalanceChanged(change)))
}


==================================================
文件路径: app\net\imadz\domain\policy\WithdrawPolicy.scala
==================================================

package net.imadz.domain.policy

import net.imadz.common.CommonTypes.{DomainPolicy, iMadzError}
import net.imadz.domain.entities.CreditBalanceEntity.{BalanceChanged, CreditBalanceEvent, CreditBalanceState}
import net.imadz.domain.values.Money

object WithdrawPolicy extends DomainPolicy[CreditBalanceEvent, CreditBalanceState, Money] {

  private val NotEnoughBalance: iMadzError = iMadzError("60002", "balance 不足扣减 或 扣减值应该为正数")

  def apply(creditBalanceState: CreditBalanceState, withdrawAmount: Money): Either[iMadzError, List[CreditBalanceEvent]] =
    if (creditBalanceState.accountBalance
      .get(withdrawAmount.currency.getCurrencyCode)
      .flatMap(withdrawAmount <= _)
      .getOrElse(false)) Right(List(BalanceChanged(withdrawAmount.copy(amount = -withdrawAmount.amount))))
    else
      Left(NotEnoughBalance)

}


==================================================
文件路径: app\net\imadz\domain\services\TransferDomainService.scala
==================================================

package net.imadz.domain.services

import net.imadz.common.CommonTypes.{DomainService, Id, iMadzError}
import net.imadz.domain.values.Money

object TransferDomainService extends DomainService {
  def validateTransfer(transferId: Id, reservedAmount: Map[Id, Money], fromBalance: Money, transferAmount: Money): Either[iMadzError, Unit] = {
    if (reservedAmount.contains(transferId)) Left(iMadzError("60008", "Already reserved"))
    else if (fromBalance.amount < transferAmount.amount) {
      Left(iMadzError("60003", "Insufficient balance for transfer"))
    } else if (transferAmount.amount <= BigDecimal(0)) {
      Left(iMadzError("60004", "Transfer amount must be positive"))
    } else {
      Right(())
    }
  }
}

==================================================
文件路径: app\net\imadz\domain\values\Money.scala
==================================================

package net.imadz.domain.values

import java.util.Currency

// Value Object
case class Money(amount: BigDecimal, currency: Currency) {
  def -(other: Money): Option[Money] = {
    if (this.currency == other.currency) Some(copy(amount = this.amount - other.amount))
    else None
  }

  def +(other: Money): Option[Money] = {
    if (this.currency == other.currency) Some(copy(amount = this.amount + other.amount))
    else None
  }

  def <=(other: Money): Option[Boolean] = {
    if (this.currency == other.currency) Some(this.amount <= other.amount)
    else None
  }
}


==================================================
文件路径: app\net\imadz\infra\saga\ForSaga.scala
==================================================

package net.imadz.infra.saga

/**
 * Marker for indexing source code for grounding saga transaction
 */
trait ForSaga {

}


==================================================
文件路径: app\net\imadz\infra\saga\SagaParticipant.scala
==================================================

package net.imadz.infra.saga

import net.imadz.infra.saga.SagaParticipant._
import org.slf4j.{Logger, LoggerFactory}

import java.net.ConnectException
import java.sql.SQLTransientException
import scala.concurrent.{ExecutionContext, Future, TimeoutException}
import scala.util.{Failure, Success}

object SagaParticipant {
  case class SagaResult[T](
                            message: Option[String],
                            metadata: Map[String, String],
                            data: Option[T]
                          )

  object SagaResult {
    def empty[T](): SagaResult[T] = SagaResult[T](None, Map.empty[String, String], None)

    def apply[T](data: T): SagaResult[T] = SagaResult(None, Map.empty[String, String], Some(data))

    def apply[T](data: T, message: String): SagaResult[T] = SagaResult(Some(message), Map.empty[String, String], Some(data))
  }

  type ParticipantEffect[E, R] = Future[Either[E, SagaResult[R]]]

  sealed trait RetryableOrNotException {
    def message: String
  }

  case class RetryableFailure(message: String) extends RuntimeException(message) with RetryableOrNotException

  case class NonRetryableFailure(message: String) extends RuntimeException(message) with RetryableOrNotException

}

trait SagaParticipant[E, R] {

  protected def logger: Logger = LoggerFactory.getLogger(getClass)

  protected def doPrepare(transactionId: String): ParticipantEffect[E, R]

  protected def doCommit(transactionId: String): ParticipantEffect[E, R]

  protected def doCompensate(transactionId: String): ParticipantEffect[E, R]

  def prepare(transactionId: String)(implicit ec: ExecutionContext): ParticipantEffect[RetryableOrNotException, R] =
    executeWithRetryClassification(doPrepare(transactionId))

  def commit(transactionId: String)(implicit ec: ExecutionContext): ParticipantEffect[RetryableOrNotException, R] =
    executeWithRetryClassification(doCommit(transactionId))

  def compensate(transactionId: String)(implicit ec: ExecutionContext): ParticipantEffect[RetryableOrNotException, R] =
    executeWithRetryClassification(doCompensate(transactionId))

  private def executeWithRetryClassification(
                                              operation: => ParticipantEffect[E, R]
                                            )(implicit ec: ExecutionContext): ParticipantEffect[RetryableOrNotException, R] = {
    logger.debug("SagaParticipant is executing...")

    operation.transform {
      case Success(Right(r)) =>
        logger.info("SagaParticipant executed successfully with right result")
        Success(Right(r))
      case Success(Left(e@net.imadz.common.CommonTypes.iMadzError(code, message))) =>
        logger.warn(s"SagaParticipant executed failed with $e")
        Success(Left(classifyFailure(e)))
      case Success(Left(e)) =>
        logger.warn(s"SagaParticipant executed failed with $e")
        Success(Left(classifyFailure(new Exception("Operation failed"))))
      case Failure(e) =>
        logger.warn(s"SagaParticipant executed failed with $e")
        Success(Left(classifyFailure(e)))
    }
  }

  private def classifyFailure(e: Throwable): RetryableOrNotException = {
    val retryableOrNotException = defaultClassification
      .orElse(customClassification)
      .orElse(fallbackClassification)
      .apply(e)

    logger.warn(s"$e had been classified as $retryableOrNotException")

    retryableOrNotException
  }

  private def defaultClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case _: TimeoutException => RetryableFailure("Operation timed out")
    case _: ConnectException => RetryableFailure("Connection failed")
    case _: SQLTransientException => RetryableFailure("Transient database error")
    case _: IllegalArgumentException => NonRetryableFailure("Invalid argument")
  }

  protected def customClassification: PartialFunction[Throwable, RetryableOrNotException]

  private def fallbackClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case e => NonRetryableFailure("Unclassified error: " + e.getClass.getName + ":" + e.getMessage)
  }

}


==================================================
文件路径: app\net\imadz\infra\saga\SagaTransactionCoordinator.scala
==================================================

package net.imadz.infra.saga

import akka.actor.typed.scaladsl.{ActorContext, Behaviors}
import akka.actor.typed.{ActorRef, Behavior, Scheduler}
import akka.cluster.sharding.typed.scaladsl.EntityTypeKey
import akka.persistence.typed.PersistenceId
import akka.persistence.typed.scaladsl.{Effect, EventSourcedBehavior}
import akka.util.Timeout
import net.imadz.common.CborSerializable
import net.imadz.infra.saga.SagaParticipant.{NonRetryableFailure, RetryableFailure, RetryableOrNotException, SagaResult}
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.StepExecutor.{StepCompleted, StepFailed, StepResult}
import play.api.libs.json._

import scala.concurrent.{ExecutionContext, Future}
import scala.language.postfixOps

object SagaTransactionCoordinator {
  val tags: Vector[String] = Vector.tabulate(5)(i => s"SagaTransactionCoordinator-$i")
  val entityTypeKey: EntityTypeKey[Command] = EntityTypeKey("SagaTransactionCoordinator")


  // @formatter:off
  // Commands
  sealed trait Command extends CborSerializable
  case class StartTransaction[E, R](transactionId: String, steps: List[SagaTransactionStep[E, R]], replyTo: Option[ActorRef[TransactionResult]]) extends Command
  private case class PhaseCompleted(phase: TransactionPhase, results: List[Either[RetryableOrNotException, Any]], stepTraces: List[StepExecutor.State[_, _]], replyTo: Option[ActorRef[TransactionResult]]) extends Command
  private case class PhaseFailure(phase: TransactionPhase, error: RetryableOrNotException, stepTraces: List[StepExecutor.State[_, _]], replyTo: Option[ActorRef[TransactionResult]]) extends Command
  case class TracingStep(
                          stepNumber: Int,
                          stepId: String,
                          stepType: String,
                          phase: String,
                          participant: String,
                          status: String,
                          retries: Int,
                          maxRetries: Int,
                          timeoutInMillis: Long,
                          retryWhenRecoveredOngoing: Boolean,
                          circuitBreakerOpen: Boolean,
                          error: Option[ErrorInfo]
                        ) {
    override def toString: String = {
      val step = this
      s"""
         |Step Number: ${step.stepNumber}, Step Id: ${step.stepId}, Phase: ${step.phase}, Step Type: ${step.stepType},
         |Saga Participant: ${step.participant}, ${step.status},
         |Step Status: ${step.status}
         |Step Failure: ${step.error.map(e => "type: " + e.errorType +" , msg: " + e.message).getOrElse("")},
         |Retries/MaxRetries: ${step.retries}/${step.maxRetries},
         |RetryWhenRecoveredOngoing: ${step.retryWhenRecoveredOngoing},
         |Step Timeout: ${step.timeoutInMillis} millis,
         |CircuitBreakerOpen: ${step.circuitBreakerOpen}
         |
         |""".stripMargin.replaceAll("""\n""", "")
     }

  }
  object TracingStep {
    implicit val errorInfoFormat: OWrites[ErrorInfo] = Json.writes[ErrorInfo]

    implicit val tracingStepFormat: OWrites[TracingStep] = Json.writes[TracingStep]

    def fromStepExecutorState(state: StepExecutor.State[_, _], stepNumber: Int): TracingStep = {
      val step = state.step.getOrElse(throw new IllegalStateException(s"Step $stepNumber has no associated SagaTransactionStep"))
      TracingStep(
        stepNumber = stepNumber,
        stepId = step.stepId,
        stepType = step.getClass.getSimpleName,
        phase = step.phase.toString,
        participant = step.participant.getClass.getSimpleName,
        status = state.status.toString,
        retries = state.retries,
        maxRetries = step.maxRetries,
        timeoutInMillis = step.timeoutDuration.toMillis ,
        retryWhenRecoveredOngoing = step.retryWhenRecoveredOngoing,
        circuitBreakerOpen = state.circuitBreakerOpen,
        error = state.lastError.map(e => ErrorInfo(e.message, e.getClass.getSimpleName, e.isInstanceOf[RetryableFailure]))
      )
    }
  }
  case class ErrorInfo(
                        message: String,
                        errorType: String,
                        isRetryable: Boolean
                      )
  case class TransactionResult(successful: Boolean, state: State, stepTraces: List[StepExecutor.State[_, _]]){
    
    def orderedSteps: Seq[StepExecutor.State[_, _]]= stepTraces.reverse

    lazy val tracingSteps: List[TracingStep] = orderedSteps.zipWithIndex.map(step=> TracingStep.fromStepExecutorState(step._1, step._2)).toList
    def failReason: String = tracingSteps.filter(step => step.error.nonEmpty).map(_.toString).mkString(";")

  }

  // Events
  sealed trait Event extends CborSerializable
  case class TransactionStarted(transactionId: String, steps: List[SagaTransactionStep[_, _]]) extends Event
  case class PhaseSucceeded(phase: TransactionPhase) extends Event
  case class PhaseFailed(phase: TransactionPhase) extends Event
  case class TransactionCompleted(transactionId: String) extends Event
  case class TransactionFailed(transactionId: String, reason: String) extends Event

  // State
  case class State(
                    transactionId: Option[String] = None,
                    steps: List[SagaTransactionStep[_, _]] = List.empty,
                    currentPhase: TransactionPhase = PreparePhase,
                    status: Status = Created
                  )

  sealed trait Status
  case object Created extends Status
  case object InProgress extends Status
  case object Completed extends Status
  case object Failed extends Status

  // @formatter:on

  def apply(
             persistenceId: PersistenceId,
             stepExecutorFactory: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command]
           )(implicit ec: ExecutionContext, timeout: Timeout): Behavior[Command] = Behaviors.setup { context =>
    EventSourcedBehavior[Command, Event, State](
      persistenceId = persistenceId,
      emptyState = State(),
      commandHandler = commandHandler(context, stepExecutorFactory),
      eventHandler = eventHandler
    )
  }

  def commandHandler(
                      context: ActorContext[Command],
                      stepExecutorFactory: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command]
                    )(implicit ec: ExecutionContext, timeout: Timeout): (State, Command) => Effect[Event, State] = { (state, command) =>
    command match {
      case StartTransaction(transactionId, steps, replyTo) if state.status == Created =>
        Effect
          .persist(TransactionStarted(transactionId, steps))
          .thenRun { _ =>
            executePhase(context, State(Some(transactionId), steps, PreparePhase, InProgress), stepExecutorFactory, Nil, replyTo)
          }

      case PhaseCompleted(phase, results, trace, replyTo) =>
        handlePhaseCompletion(context, state, phase, results, trace, stepExecutorFactory, replyTo)

      case PhaseFailure(phase, error, trace, replyTo) =>
        handlePhaseFailure(context, state, phase, error, trace, stepExecutorFactory, replyTo)

      case _ => Effect.none
    }
  }

  private def handlePhaseCompletion(
                                     context: ActorContext[Command],
                                     state: State,
                                     phase: TransactionPhase,
                                     results: List[Either[RetryableOrNotException, Any]],
                                     trace: List[StepExecutor.State[_, _]],
                                     stepExecutorFactory: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command],
                                     replyTo: Option[ActorRef[TransactionResult]]
                                   )(implicit ec: ExecutionContext, timeout: Timeout): Effect[Event, State] = {
    if (results.forall(_.isRight)) {
      phase match {
        case PreparePhase =>
          Effect
            .persist(PhaseSucceeded(PreparePhase))
            .thenRun { _ => executePhase(context, state.copy(currentPhase = CommitPhase), stepExecutorFactory, trace, replyTo) }
        case CommitPhase =>
          Effect.persist(
            List(
              PhaseSucceeded(CommitPhase),
              TransactionCompleted(state.transactionId.get)
            )
          ).thenRun(stateNew => replyTo.foreach(_ ! TransactionResult(successful = true, stateNew, trace)))
        case CompensatePhase =>
          Effect.persist(
            List(
              PhaseSucceeded(CompensatePhase),
              TransactionFailed(state.transactionId.get, "transaction failed but compensated")
            )
          ).thenRun(stateNew => replyTo.foreach(_ ! TransactionResult(successful = false, stateNew, trace)))
      }
    } else {
      // If any step in the phase failed, start compensation
      Effect
        .persist(TransactionFailed(state.transactionId.get, s"Phase $phase failed"))
        .thenRun { _ => executePhase(context, state.copy(currentPhase = CompensatePhase), stepExecutorFactory, trace, replyTo) }
    }
  }

  private def handlePhaseFailure(
                                  context: ActorContext[Command],
                                  state: State,
                                  phase: TransactionPhase,
                                  error: RetryableOrNotException,
                                  trace: List[StepExecutor.State[_, _]],
                                  stepExecutorFactory: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command],
                                  replyTo: Option[ActorRef[TransactionResult]]
                                )(implicit ec: ExecutionContext, timeout: Timeout): Effect[Event, State] = {
    Effect
      .persist(PhaseFailed(phase), TransactionFailed(state.transactionId.get, s"Phase $phase failed with error: ${error.message}"))
      .thenRun { stateNew =>
        if (phase != CompensatePhase) {
          executePhase(context, state.copy(currentPhase = CompensatePhase), stepExecutorFactory, trace, replyTo)
        } else {
          replyTo.foreach(_ ! TransactionResult(successful = false, stateNew, trace))
        }
      }
  }

  private def executePhase[E, R](
                                  context: ActorContext[Command],
                                  state: State,
                                  stepExecutorFactory: (String, SagaTransactionStep[E, R]) => ActorRef[StepExecutor.Command],
                                  trace: List[StepExecutor.State[_, _]],
                                  replyTo: Option[ActorRef[TransactionResult]]
                                )(implicit ec: ExecutionContext, askTimeout: Timeout): Unit = {

    val stepsInPhase = state.steps.filter(_.phase == state.currentPhase)

    import akka.actor.typed.scaladsl.AskPattern._
    implicit val scheduler: Scheduler = context.system.scheduler

    val futureResults: Future[List[StepResult[E, R]]] = Future.sequence(
      stepsInPhase.map { step =>
        val stepExecutor = stepExecutorFactory(
          s"${state.transactionId.get}-${step.stepId}-${state.currentPhase}",
          step.asInstanceOf[SagaTransactionStep[E, R]]
        )
        stepExecutor.ask((ref: ActorRef[StepResult[E, R]]) => StepExecutor.Start[E, R](state.transactionId.get, step.asInstanceOf[SagaTransactionStep[E, R]], Some(ref)))(askTimeout, scheduler)
          .mapTo[StepResult[E, R]]
      }
    )

    futureResults.foreach(stepResults => {

      val stepStateTrace = stepResults.foldLeft(trace)((acc, result) => result match {
        case StepCompleted(tid, r, stepState) => stepState :: acc
        case StepFailed(tid, e, stepState) => stepState :: acc
      })

      val positiveResults = stepResults.foldLeft[List[Either[RetryableOrNotException, SagaResult[R]]]](Nil)((acc, result) => result match {
        case StepCompleted(tid, r, stepState) => Right(r) :: acc
        case StepFailed(tid, e: E, stepState) => Left(NonRetryableFailure(e.toString)) :: acc
      })

      stepResults.find(_.isInstanceOf[StepFailed[_, _]]).map(firstError => {
        context.self ! PhaseFailure(state.currentPhase, NonRetryableFailure(firstError.toString), stepStateTrace, replyTo)
      }).getOrElse({
        context.self ! PhaseCompleted(state.currentPhase, positiveResults, stepStateTrace, replyTo)
      })

    })
  }

  def eventHandler: (State, Event) => State = { (state, event) =>
    event match {
      case TransactionStarted(transactionId, steps) =>
        state.copy(transactionId = Some(transactionId), steps = steps, status = InProgress)
      case PhaseFailed(phase) =>
        phase match {
          case PreparePhase => state.copy(currentPhase = CompensatePhase, status = Failed)
          case CommitPhase => state.copy(currentPhase = CompensatePhase, status = Failed)
          case CompensatePhase => state.copy(status = Failed)
        }
      case PhaseSucceeded(phase) =>
        phase match {
          case PreparePhase => state.copy(currentPhase = CommitPhase)
          case CommitPhase => state.copy(status = Completed)
          case CompensatePhase => state
        }
      case TransactionCompleted(_) =>
        state.copy(status = Completed)
      case TransactionFailed(_, _) =>
        state.copy(status = Failed)
    }
  }
}

==================================================
文件路径: app\net\imadz\infra\saga\StepExecutor.scala
==================================================

package net.imadz.infra.saga

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ActorRef, Behavior}
import akka.pattern.CircuitBreaker
import akka.persistence.typed.scaladsl.EventSourcedBehavior
import akka.persistence.typed.{PersistenceId, RecoveryCompleted}
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CborSerializable
import net.imadz.infra.saga.SagaParticipant.{RetryableOrNotException, SagaResult}
import net.imadz.infra.saga.SagaPhase.TransactionPhase
import net.imadz.infra.saga.handlers.{StepExecutorCommandHandler, StepExecutorEventHandler, StepExecutorRecoveryHandler}
import net.imadz.infra.saga.serialization.AkkaSerializationWrapper
import net.imadz.infrastructure.persistence.StepExecutorEventAdapter

import scala.concurrent.duration._

object SagaPhase {
  // Value Object
  sealed trait TransactionPhase extends CborSerializable {
    val key: String = toString
  }

  case object PreparePhase extends TransactionPhase {
    override def toString: String = "prepare"
  }

  case object CommitPhase extends TransactionPhase {
    override def toString: String = "commit"
  }

  case object CompensatePhase extends TransactionPhase {
    override def toString: String = "compensate"
  }
}

case class SagaTransactionStep[E, R](
                                      stepId: String,
                                      phase: TransactionPhase,
                                      participant: SagaParticipant[E, R],
                                      maxRetries: Int = 0,
                                      timeoutDuration: FiniteDuration = 30.seconds,
                                      retryWhenRecoveredOngoing: Boolean = true
                                    )

object StepExecutor {
  // @formatter:off
  // Value Class
  case class CircuitBreakerSettings(maxFailures: Int, callTimeout: FiniteDuration, resetTimeout: FiniteDuration)

  // Command
  sealed trait Command extends CborSerializable
  case class Start[E, R](transactionId: String,  sagaStep: SagaTransactionStep[E, R], replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
  case class RecoverExecution[E, R](transactionId: String, sagaStep: SagaTransactionStep[E, R], replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
   case class OperationResponse[E, R](result: Either[RetryableOrNotException, R], replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
   case class RetryOperation[E, R](replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
   case class TimedOut[E, R](replyTo: Option[ActorRef[StepResult[E, R]]]) extends Command
  sealed trait StepResult[E, R] extends CborSerializable
  case class StepCompleted[E,R](transactionId: String, result: SagaResult[R], state: State[E, R]) extends StepResult[E, R]
  case class StepFailed[E, R](transactionId: String, error: E, state: State[E, R]) extends StepResult[E, R]

  // Events
  sealed trait Event
  case class ExecutionStarted[E, R](transactionId: String, transactionStep: SagaTransactionStep[E, R], replyToPath: String) extends Event
  case class OperationSucceeded[R](result: R) extends Event
  case class OperationFailed(error: RetryableOrNotException) extends Event
  case class RetryScheduled(retryCount: Int) extends Event

  // State
  case class State[E, R](
                          step: Option[SagaTransactionStep[E, R]] = None,
                          transactionId: Option[String] = None,
                          status: Status = Created,
                          retries: Int = 0,
                          lastError: Option[RetryableOrNotException] = None,
                          circuitBreakerOpen: Boolean = false,
                          replyTo: Option[String] = None
                        ) extends CborSerializable {
    def canRetry: Boolean = this.status == Ongoing

    def canScheduleRetryOnTimedOut(defaultMaxRetries: Int): Boolean = this.status == Ongoing && this.maxRetriesReached(defaultMaxRetries)

    def canScheduleRetryOnFailure(defaultMaxRetries: Int): Boolean = ((this.status == Ongoing || this.status == Failed)
      && !this.maxRetriesReached(defaultMaxRetries))

    def canStart: Boolean = this.status == Created

    def canRecover: Boolean = this.status == Ongoing && this.step.exists(_.retryWhenRecoveredOngoing)

    private def maxRetriesReached(defaultMaxRetries: Int): Boolean = {
      this.retries >= this.step.map(_.maxRetries).getOrElse(defaultMaxRetries)
    }
  }

  sealed trait Status extends CborSerializable
  case object Created extends Status
  case object Ongoing extends Status
  case object Succeed extends Status
  case object Failed extends Status

  // @formatter:on


  def apply[E, R](creditBalanceRepository: CreditBalanceRepository)(persistenceId: PersistenceId, defaultMaxRetries: Int, initialRetryDelay: FiniteDuration, circuitBreakerSettings: CircuitBreakerSettings): Behavior[Command] = {
    Behaviors.setup { context =>
      Behaviors.withTimers { timers =>

        val circuitBreaker: CircuitBreaker = CircuitBreaker(
          scheduler = context.system.classicSystem.scheduler,
          maxFailures = circuitBreakerSettings.maxFailures,
          callTimeout = circuitBreakerSettings.callTimeout,
          resetTimeout = circuitBreakerSettings.resetTimeout
        )
        val akkaSerialization = AkkaSerializationWrapper(context.system.classicSystem)
        val global = scala.concurrent.ExecutionContext.global

        EventSourcedBehavior[Command, Event, State[E, R]](
          persistenceId = persistenceId,
          emptyState = State[E, R](),
          commandHandler = StepExecutorCommandHandler.commandHandler[E, R](context, timers, defaultMaxRetries, initialRetryDelay, circuitBreaker),
          eventHandler = StepExecutorEventHandler.eventHandler[E, R]
        ).eventAdapter(StepExecutorEventAdapter(akkaSerialization, creditBalanceRepository, global))
          .receiveSignal {
            case (state, RecoveryCompleted) =>
              StepExecutorRecoveryHandler.onRecoveryCompleted[E, R](context, state)
          }
      }
    }
  }


  def apply[E, R](persistenceId: PersistenceId, defaultMaxRetries: Int, initialRetryDelay: FiniteDuration, circuitBreakerSettings: CircuitBreakerSettings): Behavior[Command] = {
    Behaviors.setup { context =>
      Behaviors.withTimers { timers =>

        val circuitBreaker: CircuitBreaker = CircuitBreaker(
          scheduler = context.system.classicSystem.scheduler,
          maxFailures = circuitBreakerSettings.maxFailures,
          callTimeout = circuitBreakerSettings.callTimeout,
          resetTimeout = circuitBreakerSettings.resetTimeout
        )
        val akkaSerialization = AkkaSerializationWrapper(context.system.classicSystem)
        val global = scala.concurrent.ExecutionContext.global

        EventSourcedBehavior[Command, Event, State[E, R]](
          persistenceId = persistenceId,
          emptyState = State[E, R](),
          commandHandler = StepExecutorCommandHandler.commandHandler[E, R](context, timers, defaultMaxRetries, initialRetryDelay, circuitBreaker),
          eventHandler = StepExecutorEventHandler.eventHandler[E, R]
        ).receiveSignal {
          case (state, RecoveryCompleted) =>
            StepExecutorRecoveryHandler.onRecoveryCompleted[E, R](context, state)
        }
      }
    }
  }
}

==================================================
文件路径: app\net\imadz\infra\saga\handlers\StepExecutorCommandHandler.scala
==================================================

package net.imadz.infra.saga.handlers
import akka.actor.typed.ActorRef
import akka.actor.typed.scaladsl.TimerScheduler
import akka.pattern.CircuitBreaker
import akka.persistence.typed.scaladsl.Effect
import net.imadz.infra.saga.SagaParticipant._
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.{SagaParticipant, SagaTransactionStep}
import net.imadz.infra.saga.StepExecutor._
import org.slf4j.LoggerFactory

import scala.concurrent.duration.FiniteDuration
object StepExecutorCommandHandler {
   def commandHandler[E, R](
                                    context: akka.actor.typed.scaladsl.ActorContext[Command],
                                    timers: TimerScheduler[Command],
                                    defaultMaxRetries: Int,
                                    initialRetryDelay: FiniteDuration,
                                    circuitBreaker: CircuitBreaker
                                  ): (State[E, R], Command) => Effect[Event, State[E, R]] = { (state, command) =>
    command match {
      case Start(transactionId, step, replyTo: Some[ActorRef[StepResult[E, R]]]) if state.canStart =>
        Effect
          .persist(ExecutionStarted(transactionId, step, serializeActorRef(replyTo)))
          .thenRun(_ => executeOperation(context, step.phase, step, transactionId, circuitBreaker, replyTo))

      case RecoverExecution(transactionId, step, replyTo) if state.canRecover =>

        Effect
          .persist(ExecutionStarted(transactionId, step, serializeActorRef(replyTo)))
          .thenRun(_ => executeOperation(context, step.phase, step, transactionId, circuitBreaker, replyTo))


      case OperationResponse(Right(result), replyTo: Option[ActorRef[StepResult[E, R]]]) if state.status == Ongoing =>
        Effect
          .persist(OperationSucceeded(result))
          .thenRun(updatedState => updatedState.status match {
            case Succeed => // Notify success
              replyTo.foreach(_ ! StepCompleted[E, R](state.transactionId.get, result.asInstanceOf[SagaResult[R]], updatedState))
            case _ => // Unexpected state
          })

      case OperationResponse(Left(error: RetryableFailure), replyTo) if state.canScheduleRetryOnFailure(defaultMaxRetries) =>

        val nextRetry = state.retries + 1
        val nextDelay = calculateBackoffDelay(initialRetryDelay, nextRetry)

        Effect
          .persist(List(OperationFailed(error), RetryScheduled(nextRetry)))
          .thenRun(_ => scheduleRetry(timers, nextDelay, replyTo))

      case OperationResponse(Left(error), replyTo: Option[ActorRef[StepResult[E, R]]]) =>
        Effect
          .persist(OperationFailed(error))
          .thenRun(stateUpdated => replyTo.foreach(_ ! StepFailed(state.transactionId.get, error, stateUpdated)))

      case TimedOut(replyTo) if state.canScheduleRetryOnTimedOut(defaultMaxRetries) =>
        context.log.warn(s"TimedOut found ${state.retries} times")

        val nextRetry = state.retries + 1
        val nextDelay = calculateBackoffDelay(initialRetryDelay, nextRetry)

        Effect
          .persist(List(OperationFailed(RetryableFailure("timed out")), RetryScheduled(nextRetry)))
          .thenRun(_ => scheduleRetry(timers, nextDelay, replyTo))

      case TimedOut(replyTo: Option[ActorRef[StepResult[E, R]]]) =>
        Effect
          .persist(OperationFailed(RetryableFailure("timed out")))
          .thenRun(stateUpdated => replyTo.foreach(_ ! StepFailed(state.transactionId.get, RetryableFailure("timed out"), stateUpdated)))

      case RetryOperation(replyTo: Option[ActorRef[StepResult[E, R]]]) if state.canRetry =>
        state.step.zip(state.transactionId).map {
          case (step, trxId) =>
            Effect.none[Event, State[E, R]]
              .thenRun(_ => executeOperation[E, R](context, step.phase, step, state.transactionId.get, circuitBreaker, replyTo))
        }.getOrElse(Effect.none)
      case msg =>
        context.log.warn(s"msg: $msg is not processed")
        Effect.none
    }
  }

  private val logger = LoggerFactory.getLogger(getClass)

  private def executeOperation[E, R](
                                      context: akka.actor.typed.scaladsl.ActorContext[Command],
                                      stepPhase: TransactionPhase,
                                      step: SagaTransactionStep[E, R],
                                      transactionId: String,
                                      circuitBreaker: CircuitBreaker,
                                      replyTo: Option[ActorRef[StepResult[E, R]]]
                                    ): Unit = {
    import context.executionContext

    context.scheduleOnce(step.timeoutDuration, context.self, TimedOut(replyTo))

    val eventualStepResult: SagaParticipant.ParticipantEffect[RetryableOrNotException, R] = stepPhase match {
      case PreparePhase =>
        step.participant.prepare(transactionId)
      case CommitPhase =>
        step.participant.commit(transactionId)
      case CompensatePhase =>
        step.participant.compensate(transactionId)
    }

    circuitBreaker.withCircuitBreaker(eventualStepResult).onComplete {
      case scala.util.Success(result: Either[RetryableOrNotException, R]) =>
        context.self ! OperationResponse(result, replyTo)
      case scala.util.Failure(exception) =>
        logger.warn(s"$exception found while processing ${step}")
        context.self ! OperationResponse(Left(NonRetryableFailure(exception.getMessage)), replyTo)
    }
  }

  private def scheduleRetry[E, R](timers: TimerScheduler[Command], delay: FiniteDuration, replyTo: Option[ActorRef[StepResult[E, R]]]): Unit = {
    timers.startSingleTimer(RetryOperation(replyTo), delay)
  }

  private def calculateBackoffDelay(initialDelay: FiniteDuration, retryCount: Int): FiniteDuration = {
    initialDelay * math.pow(2, retryCount - 1).toLong
  }


  private def serializeActorRef(replyTo: Option[ActorRef[_]]) = {
    replyTo.map(_.path.toSerializationFormat).getOrElse("")
  }

}


==================================================
文件路径: app\net\imadz\infra\saga\handlers\StepExecutorEventHandler.scala
==================================================

package net.imadz.infra.saga.handlers

import net.imadz.infra.saga.SagaTransactionStep
import net.imadz.infra.saga.StepExecutor._

object StepExecutorEventHandler {
  def eventHandler[E, R]: (State[E, R], Event) => State[E, R] = { (state, event) =>
    event match {
      case ExecutionStarted(transactionId, step, replyTo) =>
        state.copy(transactionId = Some(transactionId),
          step = Some(step.asInstanceOf[SagaTransactionStep[E, R]]), status = Ongoing,
          replyTo = Some(replyTo))
      case OperationSucceeded(_) =>
        state.copy(status = Succeed)
      case OperationFailed(error) =>
        state.copy(status = Failed, lastError = Some(error))
      case RetryScheduled(_) =>
        state.copy(retries = state.retries + 1, status = Ongoing)

    }
  }


}


==================================================
文件路径: app\net\imadz\infra\saga\handlers\StepExecutorRecoveryHandler.scala
==================================================

package net.imadz.infra.saga.handlers

import akka.actor.typed.ActorRef
import akka.actor.typed.scaladsl.ActorContext
import akka.actor.typed.scaladsl.adapter.ClassicActorRefOps
import net.imadz.infra.saga.StepExecutor._
import net.imadz.infra.saga.SagaParticipant._

import scala.concurrent.Await
import scala.concurrent.duration.DurationInt

object StepExecutorRecoveryHandler {
  def onRecoveryCompleted[E, R](context: ActorContext[Command], state: State[E, R]): Unit = {

    val replyTo = state
      .replyTo.map(context.system.classicSystem.actorSelection)
      .map(_.resolveOne(3.seconds))
      .map(futureRef => Await.result(futureRef, 3.seconds).toTyped.asInstanceOf[ActorRef[StepResult[E, R]]])

    context.log.info(s"SAGA Transaction Step is Recovered on ${state}")
    state.status match {
      case Created | Succeed =>
        state.step.foreach { step =>
          context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | No recovery action for durability on status: ${state.status}")
        }
        ()
      case Failed =>
        state.lastError.zip(state.step).foreach { case (error, step) => error match {

          case RetryableFailure(msg) if state.retries < step.maxRetries =>
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | Take RetryOperation on RetryableFailure(${msg})")
            context.self ! RetryOperation(replyTo)
          case RetryableFailure(msg) =>
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | No RetryOperation needed on RetryableFailure(${msg}) since max retries reached.")
            ()
          case NonRetryableFailure(msg) =>
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | No RetryOperation needed on NonRetryableFailure(${msg}).")
            ()
        }
        }
      case Ongoing =>
        state.step.zip(state.transactionId).foreach { case (step, trxId) =>
          if (step.retryWhenRecoveredOngoing) {
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | Take RetryOperation on Ongoing state")

            context.self ! RecoverExecution(trxId, step, replyTo)
          } else {
            context.log.info(s"TrxId: ${state.transactionId} Phase: ${step.phase} StepKey: ${step.stepId} | No need to take RetryOperation on Ongoing state while retryWhenRecoveredOngoing is ${step.retryWhenRecoveredOngoing}")
          }
        }
    }
  }

}


==================================================
文件路径: app\net\imadz\infra\saga\repository\SagaTransactionCoordinatorRepositoryImpl.scala
==================================================

package net.imadz.infra.saga.repository

import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, EntityRef}
import net.imadz.common.CommonTypes.Id
import net.imadz.infra.saga.SagaTransactionCoordinator

import javax.inject.Inject

case class SagaTransactionCoordinatorRepositoryImpl @Inject()(sharding: ClusterSharding) extends TransactionCoordinatorRepository {
  override def findSagaTransactionCoordinator(sagaTransactionId: Id): EntityRef[SagaTransactionCoordinator.Command] =
    sharding.entityRefFor(SagaTransactionCoordinator.entityTypeKey, sagaTransactionId.toString)
}


==================================================
文件路径: app\net\imadz\infra\saga\repository\TransactionCoordinatorRepository.scala
==================================================

package net.imadz.infra.saga.repository

import akka.cluster.sharding.typed.scaladsl.EntityRef
import com.google.inject.ImplementedBy
import net.imadz.common.CommonTypes.Id
import net.imadz.infra.saga.SagaTransactionCoordinator

@ImplementedBy(classOf[SagaTransactionCoordinatorRepositoryImpl])
trait TransactionCoordinatorRepository {

  def findSagaTransactionCoordinator(sagaTransactionId: Id): EntityRef[SagaTransactionCoordinator.Command]
}


==================================================
文件路径: app\net\imadz\infra\saga\serialization\AkkaSerializationWrapper.scala
==================================================

package net.imadz.infra.saga.serialization

import akka.actor.ActorSystem
import akka.serialization.{SerializationExtension, Serializers}

case class AkkaSerializationWrapper(system: ActorSystem) {
  private val serialization = SerializationExtension(system)

  def serialize(obj: AnyRef): (Array[Byte], String) = {
    val serializer = serialization.findSerializerFor(obj)
    val bytes = serializer.toBinary(obj)
    val manifest = Serializers.manifestFor(serializer, obj)
    (bytes, manifest)
  }

  def deserialize(bytes: Array[Byte], manifest: String): AnyRef = {
    val deserializer = serialization.serializerFor(Class.forName(manifest))
    deserializer.fromBinary(bytes, Class.forName(manifest)).asInstanceOf[AnyRef]
  }
}

==================================================
文件路径: app\net\imadz\infra\saga\serialization\SagaSerializer.scala
==================================================

package net.imadz.infra.saga.serialization

import akka.actor.ExtendedActorSystem
import akka.serialization.{SerializationExtension, SerializerWithStringManifest}
import com.google.protobuf.ByteString
import net.imadz.infra.saga.SagaParticipant
import net.imadz.infra.saga.StepExecutor.{OperationResponse, OperationSucceeded}
import net.imadz.infra.saga.proto.saga_v2.{OperationFailedCommandPO, OperationSucceedCommandPO, OperationSucceededPO, RetryableOrNotExceptionPO}

class SagaSerializer(system: ExtendedActorSystem) extends SerializerWithStringManifest {

  private lazy val serialization = SerializationExtension(system)

  override def identifier: Int = 1000

  override def manifest(o: AnyRef): String = o.getClass.getName

  override def toBinary(o: AnyRef): Array[Byte] = o match {
    case OperationResponse(result, replyTo) =>
      result match {
        case Left(SagaParticipant.RetryableFailure(message)) =>
          OperationFailedCommandPO(Some(RetryableOrNotExceptionPO(isRetryable = true, message))).toByteArray
        case Left(SagaParticipant.NonRetryableFailure(message)) =>
          OperationFailedCommandPO(Some(RetryableOrNotExceptionPO(isRetryable = false, message = message))).toByteArray
        case Right(positiveResult: AnyRef) =>
          val serializer = serialization.findSerializerFor(positiveResult)
          OperationSucceedCommandPO(
            successMessageType = positiveResult.getClass.getName,
            success = ByteString.copyFrom(serializer.toBinary(positiveResult))
          ).toByteArray
      }

    case OperationSucceeded(result: AnyRef) =>
      val serializer = serialization.findSerializerFor(result)
      OperationSucceededPO(resultType = result.getClass.getName, result = ByteString.copyFrom(serializer.toBinary(result))).toByteArray
    case _ => throw new IllegalArgumentException(s"Cannot serialize ${o.getClass}")
  }

  override def fromBinary(bytes: Array[Byte], manifest: String): AnyRef = {
    manifest match {
      case className if className == classOf[OperationResponse[_, _]].getName =>
        try {
          val failedCommand = OperationFailedCommandPO.parseFrom(bytes)
          failedCommand.error match {
            case Some(exception) if exception.isRetryable =>
              OperationResponse(Left(SagaParticipant.RetryableFailure(exception.message)), None)
            case Some(exception) =>
              OperationResponse(Left(SagaParticipant.NonRetryableFailure(exception.message)), None)
            case None =>
              throw new IllegalArgumentException("Invalid OperationFailedCommandPO: missing exception")
          }
        } catch {
          case _: com.google.protobuf.InvalidProtocolBufferException =>
            // If it's not a failure, it must be a success
            val successCommand = OperationSucceedCommandPO.parseFrom(bytes)
            val resultClass = system.dynamicAccess.getClassFor[AnyRef](successCommand.successMessageType)
              .getOrElse(throw new ClassNotFoundException(s"Cannot find class ${successCommand.successMessageType}"))
            val resultSerializer = serialization.serializerFor(resultClass)
            val result = resultSerializer.fromBinary(successCommand.success.toByteArray, resultClass)
            OperationResponse(Right(result), None) // Note: We cannot reconstruct the ActorRef here
        }

      case className if className == classOf[OperationSucceeded[_]].getName =>
        val protoMessage = OperationSucceededPO.parseFrom(bytes)
        val resultClass = system.dynamicAccess.getClassFor[AnyRef](protoMessage.resultType)
          .getOrElse(throw new ClassNotFoundException(s"Cannot find class ${protoMessage.resultType}"))
        val resultSerializer = serialization.serializerFor(resultClass)
        val result = resultSerializer.fromBinary(protoMessage.result.toByteArray, resultClass)
        OperationSucceeded(result)

      case _ => throw new IllegalArgumentException(s"Cannot deserialize class $manifest")
    }
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\SuffixCollectionNames.scala
==================================================

package net.imadz.infrastructure

import akka.contrib.persistence.mongodb.CanSuffixCollectionNames

class SuffixCollectionNames extends CanSuffixCollectionNames{
  override def getSuffixFromPersistenceId(persistenceId: String): String = persistenceId match {
    // in this example, we remove any leading "-test" string from persistenceId passed as parameter
    // otherwise, we do not suffix our collection
    case _ => ""
  }

  override def validateMongoCharacters(input: String): String = {
    // According to mongoDB documentation,
    // forbidden characters in mongoDB collection names (Unix) are /\. "$
    // Forbidden characters in mongoDB collection names (Windows) are /\. "$*<>:|?
    // in this example, we replace each forbidden character with an underscore character
    val forbidden = List('/', '\\', '.', ' ', '\"', '$', '*', '<', '>', ':', '|', '?')

    input.map { c => if (forbidden.contains(c)) '_' else c }
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\bootstrap\CreditBalanceBootstrap.scala
==================================================

package net.imadz.infrastructure.bootstrap

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{Behavior, LogOptions, SupervisorStrategy}
import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, Entity, EntityContext}
import akka.persistence.typed.PersistenceId
import akka.persistence.typed.scaladsl.{EventSourcedBehavior, RetentionCriteria}
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.CreditBalanceAggregate.{CreditBalanceCommand, CreditBalanceEntityTypeKey}
import net.imadz.application.aggregates.behaviors.CreditBalanceBehaviors
import net.imadz.common.CommonTypes.Id
import net.imadz.common.Id
import net.imadz.domain.entities.CreditBalanceEntity
import net.imadz.domain.entities.behaviors.CreditBalanceEventHandler
import net.imadz.infrastructure.persistence.{CreditBalanceEventAdapter, CreditBalanceSnapshotAdapter}
import org.slf4j.LoggerFactory
import org.slf4j.event.Level

import scala.concurrent.duration.DurationInt

trait CreditBalanceBootstrap {

  def initCreditBalanceAggregate(sharding: ClusterSharding): Unit = {
    val behaviorFactory: EntityContext[CreditBalanceCommand] => Behavior[CreditBalanceCommand] = { context =>
      val i = math.abs(context.entityId.hashCode % CreditBalanceAggregate.tags.size)
      val selectedTag = CreditBalanceAggregate.tags(i)
      apply(Id.of(context.entityId), selectedTag)
    }

    sharding.init(Entity(CreditBalanceAggregate.CreditBalanceEntityTypeKey)(behaviorFactory))
  }

  private def apply(userId: Id, tag: String): Behavior[CreditBalanceCommand] =
    Behaviors.logMessages(LogOptions().withLogger(LoggerFactory.getLogger("iMadz")).withLevel(Level.INFO),
      Behaviors
        .setup { actorContext =>
          EventSourcedBehavior(
            persistenceId = PersistenceId(CreditBalanceEntityTypeKey.name, userId.toString),
            emptyState = CreditBalanceEntity.empty(userId),
            commandHandler = CreditBalanceBehaviors.apply,
            eventHandler = CreditBalanceEventHandler.apply
          ).withTagger(_ => Set(tag))
            .withRetention(RetentionCriteria.snapshotEvery(numberOfEvents = 100, keepNSnapshots = 3))
            .onPersistFailure(SupervisorStrategy.restartWithBackoff(200.millis, 5.seconds, 0.1).withStashCapacity(100))
            .eventAdapter(new CreditBalanceEventAdapter)
            .snapshotAdapter(new CreditBalanceSnapshotAdapter)
        })
}


==================================================
文件路径: app\net\imadz\infrastructure\bootstrap\MonthlyIncomeAndExpenseBootstrap.scala
==================================================

package net.imadz.infrastructure.bootstrap

import akka.actor.typed.ActorSystem
import akka.cluster.sharding.typed.ShardedDaemonProcessSettings
import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, ShardedDaemonProcess}
import akka.projection.ProjectionBehavior
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.projection.MonthlyIncomeAndExpenseSummaryProjection.{createProjection, projectionName}
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository

trait MonthlyIncomeAndExpenseBootstrap {
  def initMonthlySummaryProjection(system: ActorSystem[_], sharding: ClusterSharding, repository: MonthlyIncomeAndExpenseSummaryRepository): Unit = {
    ShardedDaemonProcess(system).init(
      name = projectionName,
      numberOfInstances = CreditBalanceAggregate.tags.size,
      behaviorFactory = index => ProjectionBehavior(createProjection(system, sharding, index, repository)),
      settings = ShardedDaemonProcessSettings(system),
      stopMessage = Some(ProjectionBehavior.Stop)
    )
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\bootstrap\SagaTransactionCoordinatorBootstrap.scala
==================================================

package net.imadz.infrastructure.bootstrap

import akka.actor.typed.scaladsl.{ActorContext, Behaviors}
import akka.actor.typed.{Behavior, LogOptions, SupervisorStrategy}
import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, Entity, EntityContext}
import akka.persistence.typed.PersistenceId
import akka.persistence.typed.scaladsl.{EventSourcedBehavior, RetentionCriteria}
import akka.util.Timeout
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id
import net.imadz.common.Id
import net.imadz.infra.saga.SagaTransactionCoordinator.entityTypeKey
import net.imadz.infra.saga.{ForSaga, SagaTransactionCoordinator, StepExecutor}
import net.imadz.infrastructure.persistence.SagaTransactionCoordinatorEventAdapter
import org.slf4j.LoggerFactory
import org.slf4j.event.Level

import scala.concurrent.duration.DurationInt

trait SagaTransactionCoordinatorBootstrap extends ForSaga {

  import scala.concurrent.ExecutionContext.Implicits.global

  def initSagaTransactionCoordinatorAggregate(sharding: ClusterSharding, repository: CreditBalanceRepository): Unit = {
    val behaviorFactory: EntityContext[SagaTransactionCoordinator.Command] => Behavior[SagaTransactionCoordinator.Command] = { context =>
      val i = math.abs(context.entityId.hashCode % SagaTransactionCoordinator.tags.size)
      val selectedTag = SagaTransactionCoordinator.tags(i)
      apply(Id.of(context.entityId), selectedTag, repository)
    }

    sharding.init(Entity(SagaTransactionCoordinator.entityTypeKey)(behaviorFactory))
  }

  //TODO: Bad Smell
  private def apply(transactionId: Id, tag: String, repository: CreditBalanceRepository): Behavior[SagaTransactionCoordinator.Command] = {
    implicit val askTimeout: Timeout = Timeout(30.seconds)
    Behaviors.logMessages(LogOptions().withLogger(LoggerFactory.getLogger("iMadz")).withLevel(Level.INFO),
      Behaviors
        .setup { actorContext =>
          EventSourcedBehavior(
            persistenceId = PersistenceId(entityTypeKey.name, transactionId.toString),
            emptyState = SagaTransactionCoordinator.State.apply(),
            commandHandler = SagaTransactionCoordinator.commandHandler(actorContext, (key, step) => createStepExecutor(actorContext, key, repository)),
            eventHandler = SagaTransactionCoordinator.eventHandler
          ).withTagger(_ => Set(tag))
            .withRetention(RetentionCriteria.snapshotEvery(numberOfEvents = 100, keepNSnapshots = 3))
            .onPersistFailure(SupervisorStrategy.restartWithBackoff(200.millis, 5.seconds, 0.1).withStashCapacity(100))
            .eventAdapter(SagaTransactionCoordinatorEventAdapter(actorContext.system, repository, global))
        })
  }


  private def createStepExecutor(context: ActorContext[SagaTransactionCoordinator.Command], key: String, creditBalanceRepository: CreditBalanceRepository) = {
    context.spawn(StepExecutor[Any, Any](creditBalanceRepository)(
      PersistenceId.ofUniqueId(key),
      defaultMaxRetries = 5,
      initialRetryDelay = 100.millis,
      circuitBreakerSettings = StepExecutor.CircuitBreakerSettings(5, 30.seconds, 30.seconds)
    ), key)
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\persistence\CreditBalanceEventAdapter.scala
==================================================

package net.imadz.infrastructure.persistence

import akka.persistence.typed.{EventAdapter, EventSeq}
import net.imadz.common.Id
import net.imadz.domain.entities.CreditBalanceEntity._
import net.imadz.domain.values.Money
import net.imadz.infrastructure.proto.credits.{CreditBalanceEventPO => CreditEventPO, MoneyPO}

import java.util.Currency

class CreditBalanceEventAdapter extends EventAdapter[CreditBalanceEvent, CreditEventPO.Event] {

  override def toJournal(e: CreditBalanceEvent): CreditEventPO.Event =
    e match {
      case BalanceChanged(update, timestamp) =>
        CreditEventPO.Event.BalanceChanged(
          net.imadz.infrastructure.proto.credits.BalanceChanged(
            Some(MoneyPO(update.amount.doubleValue, update.currency.getCurrencyCode)),
            timestamp
          )
        )
      case FundsReserved(transferId, amount) =>
        CreditEventPO.Event.FundsReserved(
          net.imadz.infrastructure.proto.credits.FundsReserved(
            transferId.toString,
            Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
          )
        )
      case FundsDeducted(transferId, amount) =>
        CreditEventPO.Event.FundsDeducted(
          net.imadz.infrastructure.proto.credits.FundsDeducted(
            transferId.toString,
            Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
          )
        )
      case ReservationReleased(transferId, amount) =>
        CreditEventPO.Event.ReservationReleased(
          net.imadz.infrastructure.proto.credits.ReservationReleased(
            transferId.toString,
            Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
          )
        )
      case IncomingCreditsRecorded(transferId, amount) =>
        CreditEventPO.Event.IncomingCreditsRecorded(
          net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded(
            transferId.toString,
            Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
          )
        )
      case IncomingCreditsCommited(transferId) =>
        CreditEventPO.Event.IncomingCreditsCommited(
          net.imadz.infrastructure.proto.credits.IncomingCreditsCommited(
            transferId.toString
          )
        )
      case IncomingCreditsCanceled(transferId) =>
        CreditEventPO.Event.IncomingCreditsCanceled(
          net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled(
            transferId.toString
          )
        )
    }

  override def manifest(event: CreditBalanceEvent): String = event.getClass.getName

  override def fromJournal(p: CreditEventPO.Event, manifest: String): EventSeq[CreditBalanceEvent] =
    p match {
      case CreditEventPO.Event.BalanceChanged(po) =>
        EventSeq.single(BalanceChanged(
          po.update.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get, po.timestamp)
        )
      case CreditEventPO.Event.FundsReserved(po) =>
        EventSeq.single(FundsReserved(
          Id.of(po.transferId),
          po.amount.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get
        ))
      case CreditEventPO.Event.FundsDeducted(po) =>
        EventSeq.single(FundsDeducted(
          Id.of(po.transferId),
          po.amount.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get
        ))
      case CreditEventPO.Event.ReservationReleased(po) =>
        EventSeq.single(ReservationReleased(
          Id.of(po.transferId),
          po.amount.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get
        ))
      case CreditEventPO.Event.IncomingCreditsRecorded(po) =>
        EventSeq.single(IncomingCreditsRecorded(
          Id.of(po.transferId),
          po.amount.map((moneyPO: MoneyPO) => {
            val currency = Currency.getInstance(moneyPO.currency)
            Money(BigDecimal(moneyPO.amount), currency)
          }).get
        ))
      case CreditEventPO.Event.IncomingCreditsCommited(po) =>
        EventSeq.single(IncomingCreditsCommited(
          Id.of(po.transferId)
        ))
      case CreditEventPO.Event.IncomingCreditsCanceled(po) =>
        EventSeq.single(IncomingCreditsCanceled(
          Id.of(po.transferId)
        ))
      case _ =>
        EventSeq.empty
    }
}

==================================================
文件路径: app\net\imadz\infrastructure\persistence\CreditBalanceSnapshotAdapter.scala
==================================================

package net.imadz.infrastructure.persistence

import akka.persistence.typed.SnapshotAdapter
import net.imadz.common.Id
import net.imadz.domain.entities.CreditBalanceEntity._
import net.imadz.domain.values.Money
import net.imadz.infrastructure.proto.credits._

import java.util.{Currency, UUID}

class CreditBalanceSnapshotAdapter extends SnapshotAdapter[CreditBalanceState] {

  override def toJournal(state: CreditBalanceState): Any = {
    val accountBalance = state.accountBalance.map { case (k, v) =>
      k -> MoneyPO(v.amount.doubleValue, v.currency.getCurrencyCode)
    }
    val reservedAmount = state.reservedAmount.map { case (k, v) =>
      k.toString -> MoneyPO(v.amount.doubleValue, v.currency.getCurrencyCode)
    }
    val incomingCredits = state.incomingCredits.map { case (k, v) =>
      k.toString -> MoneyPO(v.amount.doubleValue, v.currency.getCurrencyCode)
    }
    CreditBalanceStatePO(
      userId = state.userId.toString,
      accountBalance = accountBalance,
      reservedAmount = reservedAmount,
      incomingCredits = incomingCredits
    )
  }

  override def fromJournal(from: Any): CreditBalanceState = from match {
    case po: CreditBalanceStatePO =>
      val accountBalance = po.accountBalance.map { case (k, v) =>
        k -> Money(v.amount, Currency.getInstance(v.currency))
      }
      val reservedAmount = po.reservedAmount.map { case (k, v) =>
        Id.of(k) -> Money(v.amount, Currency.getInstance(v.currency))
      }
      val incomingCredits = po.incomingCredits.map { case (k, v) =>
        Id.of(k) -> Money(v.amount, Currency.getInstance(v.currency))
      }
      CreditBalanceState(
        userId = UUID.fromString(po.userId),
        accountBalance = accountBalance,
        reservedAmount = reservedAmount,
        incomingCredits = incomingCredits
      )
    case unknown => throw new IllegalStateException(s"Unknown journal type: ${unknown.getClass.getName}")
  }
}

==================================================
文件路径: app\net\imadz\infrastructure\persistence\SagaTransactionCoordinatorEventAdapter.scala
==================================================

package net.imadz.infrastructure.persistence

import akka.actor.typed.ActorSystem
import akka.persistence.typed.{EventAdapter, EventSeq}
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.infra.saga.SagaPhase.{CommitPhase, CompensatePhase, PreparePhase}
import net.imadz.infra.saga.proto.saga_v2._
import net.imadz.infra.saga.{ForSaga, SagaPhase, SagaTransactionCoordinator, serialization}

import scala.concurrent.ExecutionContext

case class SagaTransactionCoordinatorEventAdapter(system: ActorSystem[Nothing], repository: CreditBalanceRepository, ec: ExecutionContext)
  extends EventAdapter[SagaTransactionCoordinator.Event, SagaTransactionCoordinatorEventPO.Event]
  with ForSaga {
  private val stepSerializer: SagaTransactionStepSerializer = SagaTransactionStepSerializer(repository = repository, ec = ec)

  override def toJournal(e: SagaTransactionCoordinator.Event): SagaTransactionCoordinatorEventPO.Event = e match {
    case SagaTransactionCoordinator.TransactionStarted(transactionId, steps) => SagaTransactionCoordinatorEventPO.Event.Started(TransactionStartedPO(transactionId = transactionId, steps = steps.map(stepSerializer.serializeSagaTransactionStep)))
    case SagaTransactionCoordinator.PhaseSucceeded(phase) => SagaTransactionCoordinatorEventPO.Event.PhaseSucceeded(PhaseSucceededPO(serializePhase(phase)))
    case SagaTransactionCoordinator.PhaseFailed(phase) => SagaTransactionCoordinatorEventPO.Event.PhaseFailed(PhaseFailedPO(serializePhase(phase)))
    case SagaTransactionCoordinator.TransactionCompleted(transactionId) => SagaTransactionCoordinatorEventPO.Event.TransactionCompleted(TransactionCompletedPO(transactionId))
    case SagaTransactionCoordinator.TransactionFailed(transactionId, reason) => SagaTransactionCoordinatorEventPO.Event.TransactionFailed(TransactionFailedPO(transactionId, reason))
  }


  private def serializePhase(phase: SagaPhase.TransactionPhase) = {
    phase match {
      case PreparePhase => TransactionPhasePO.PREPARE_PHASE
      case CommitPhase => TransactionPhasePO.COMMIT_PHASE
      case CompensatePhase => TransactionPhasePO.COMPENSATE_PHASE
    }
  }

  private def deserializePhase(phase: TransactionPhasePO) = phase match {
    case TransactionPhasePO.PREPARE_PHASE => SagaPhase.PreparePhase
    case TransactionPhasePO.COMMIT_PHASE => SagaPhase.CommitPhase
    case TransactionPhasePO.COMPENSATE_PHASE => SagaPhase.CompensatePhase
    case TransactionPhasePO.Unrecognized(_) =>
      throw new IllegalArgumentException(s"Unrecognized transaction phase: $phase")
  }

  override def manifest(event: SagaTransactionCoordinator.Event): String = event.getClass.getName

  override def fromJournal(p: SagaTransactionCoordinatorEventPO.Event, manifest: String): EventSeq[SagaTransactionCoordinator.Event] = {
    val event = p match {
      case SagaTransactionCoordinatorEventPO.Event.Started(TransactionStartedPO(transactionId, steps, _)) =>
        SagaTransactionCoordinator.TransactionStarted(
          transactionId,
          steps.map(stepSerializer.deserializeSagaTransactionStep).toList
        )
      case SagaTransactionCoordinatorEventPO.Event.PhaseSucceeded(PhaseSucceededPO(phase, _)) =>
        SagaTransactionCoordinator.PhaseSucceeded(deserializePhase(phase))
      case SagaTransactionCoordinatorEventPO.Event.PhaseFailed(PhaseFailedPO(phase, _)) =>
        SagaTransactionCoordinator.PhaseFailed(deserializePhase(phase))
      case SagaTransactionCoordinatorEventPO.Event.TransactionCompleted(TransactionCompletedPO(transactionId, _)) =>
        SagaTransactionCoordinator.TransactionCompleted(transactionId)
      case SagaTransactionCoordinatorEventPO.Event.TransactionFailed(TransactionFailedPO(transactionId, reason, _)) =>
        SagaTransactionCoordinator.TransactionFailed(transactionId, reason)
      case _ =>
        throw new IllegalArgumentException(s"Unrecognized event: $p")
    }
    EventSeq.single(event)
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\persistence\SagaTransactionStepSerializer.scala
==================================================

package net.imadz.infrastructure.persistence

import akka.serialization.Serializer
import com.google.protobuf.ByteString
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.application.services.transactor.MoneyTransferSagaTransactor.{FromAccountParticipant, ToAccountParticipant}
import net.imadz.common.CommonTypes.iMadzError
import net.imadz.common.Id
import net.imadz.domain.values.Money
import net.imadz.infra.saga.SagaPhase.{CommitPhase, CompensatePhase, PreparePhase}
import net.imadz.infra.saga.proto.saga_v2.{SagaParticipantPO, SagaTransactionStepPO, TransactionPhasePO}
import net.imadz.infra.saga.{SagaParticipant, SagaTransactionStep}
import net.imadz.infrastructure.proto.credits.MoneyPO
import net.imadz.infrastructure.proto.saga_participant.{FromAccountParticipantPO, ToAccountParticipantPO}

import java.util.Currency
import scala.concurrent.ExecutionContext
import scala.util.{Failure, Success, Try}

case class SagaTransactionStepSerializer(repository: CreditBalanceRepository, ec: ExecutionContext) extends Serializer {

  implicit val executionContext: ExecutionContext = ec

  override def identifier: Int = 1234

  override def toBinary(o: AnyRef): Array[Byte] = o match {
    case step: SagaTransactionStep[_, _] => serializeSagaTransactionStep(step).toByteArray
    case _ => throw new IllegalArgumentException(s"Cannot serialize object of type ${o.getClass}")
  }

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef = {
    Try(SagaTransactionStepPO.parseFrom(bytes)).map(deserializeSagaTransactionStep) match {
      case Success(step) => step
      case Failure(e) => throw new RuntimeException(s"Failed to deserialize SagaTransactionStep: ${e.getMessage}")
    }
  }

  override def includeManifest: Boolean = false

  def serializeSagaTransactionStep(step: SagaTransactionStep[_, _]): SagaTransactionStepPO = {
    val (typeName, payloadBytes) = step.participant match {
      case FromAccountParticipant(fromUserId, amount, _) =>
        val specificPO = FromAccountParticipantPO(
          fromUserId.toString,
          Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
        )
        // 返回：(类型标记, 二进制数据)
        ("FromAccountParticipantPO", ByteString.copyFrom(specificPO.toByteArray))

      case ToAccountParticipant(toUserId, amount, _) =>
        val specificPO = ToAccountParticipantPO(
          toUserId.toString,
          Some(MoneyPO(amount.amount.doubleValue, amount.currency.getCurrencyCode))
        )
        ("ToAccountParticipantPO", ByteString.copyFrom(specificPO.toByteArray))

      case _ => throw new IllegalArgumentException("Unknown participant type")
    }

    // 3. 构建通用的 SagaParticipantPO
    val genericParticipantPO = SagaParticipantPO(
      typeName = typeName,
      payload = payloadBytes
    )

    SagaTransactionStepPO(
      stepId = step.stepId,
      phase = step.phase match {
        case PreparePhase => TransactionPhasePO.PREPARE_PHASE
        case CommitPhase => TransactionPhasePO.COMMIT_PHASE
        case CompensatePhase => TransactionPhasePO.COMPENSATE_PHASE
      },
      participant = Some(genericParticipantPO),
      maxRetries = step.maxRetries,
      timeoutDurationMillis = step.timeoutDuration.toMillis,
      retryWhenRecoveredOngoing = step.retryWhenRecoveredOngoing
    )
  }

  def deserializeSagaTransactionStep(stepPO: SagaTransactionStepPO): SagaTransactionStep[iMadzError, String] = {
    val genericParticipant = stepPO.participant.getOrElse(throw new IllegalArgumentException("Missing participant"))

    // 1. 根据 type_name 决定如何解析 payload
    val participant: SagaParticipant[iMadzError, String] = genericParticipant.typeName match {
      case "FromAccountParticipantPO" =>
        // 解析具体的业务 Proto
        val specificPO = FromAccountParticipantPO.parseFrom(genericParticipant.payload.toByteArray)
        // 转换回 Scala 对象
        FromAccountParticipant(Id.of(specificPO.fromUserId), Money(BigDecimal(specificPO.getAmount.amount), Currency.getInstance(specificPO.getAmount.currency)), repository)(ec)

      case "ToAccountParticipantPO" =>
        val specificPO = ToAccountParticipantPO.parseFrom(genericParticipant.payload.toByteArray)
        ToAccountParticipant(Id.of(specificPO.toUserId), Money(BigDecimal(specificPO.getAmount.amount), Currency.getInstance(specificPO.getAmount.currency)), repository)(ec)

      case _ => throw new IllegalArgumentException(s"Unknown type: ${genericParticipant.typeName}")
    }

    SagaTransactionStep[iMadzError, String](
      stepId = stepPO.stepId,
      phase = stepPO.phase match {
        case TransactionPhasePO.PREPARE_PHASE => PreparePhase
        case TransactionPhasePO.COMMIT_PHASE => CommitPhase
        case TransactionPhasePO.COMPENSATE_PHASE => CompensatePhase
      },
      participant = participant,
      maxRetries = stepPO.maxRetries,
      timeoutDuration = stepPO.timeoutDurationMillis.millis,
      retryWhenRecoveredOngoing = stepPO.retryWhenRecoveredOngoing
    )
  }

}


==================================================
文件路径: app\net\imadz\infrastructure\persistence\StepExecutorEventAdapter.scala
==================================================

package net.imadz.infrastructure.persistence

import akka.persistence.typed.{EventAdapter, EventSeq}
import com.google.protobuf.ByteString
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.infra.saga.SagaParticipant._
import net.imadz.infra.saga.SagaPhase.{CommitPhase, CompensatePhase, PreparePhase}
import net.imadz.infra.saga._
import net.imadz.infra.saga.proto.saga_v2._
import net.imadz.infra.saga.serialization.AkkaSerializationWrapper

import scala.concurrent.ExecutionContext
import scala.concurrent.duration.DurationLong

case class StepExecutorEventAdapter(serialization: AkkaSerializationWrapper, repository: CreditBalanceRepository, ec: ExecutionContext)
  extends EventAdapter[StepExecutor.Event, StepExecutorEventPO.Event]
  with ForSaga {
  private val stepSerializer: SagaTransactionStepSerializer = SagaTransactionStepSerializer(repository = repository, ec = ec)

  override def manifest(event: StepExecutor.Event): String = event.getClass.getName

  override def toJournal(e: StepExecutor.Event): StepExecutorEventPO.Event = e match {
    case StepExecutor.ExecutionStarted(transactionId, step, replyToPath) =>
      val stepPO = stepSerializer.serializeSagaTransactionStep(step)
      StepExecutorEventPO.Event.Started(ExecutionStartedPO(transactionId, Some(stepPO), replyToPath))

    case StepExecutor.OperationSucceeded(result) =>
      // TODO FIX
      val (bytes, manifest) = serialization.serialize(result.asInstanceOf[AnyRef])
      StepExecutorEventPO.Event.Succeed(OperationSucceededPO(result.getClass.getName, ByteString.copyFrom(bytes)))

    case StepExecutor.OperationFailed(error) =>
      val errorPO = RetryableOrNotExceptionPO(error.isInstanceOf[RetryableFailure], error.message)
      StepExecutorEventPO.Event.Failed(OperationFailedPO(Some(errorPO)))

    case StepExecutor.RetryScheduled(retryCount) =>
      StepExecutorEventPO.Event.Rescheduled(RetryScheduledPO(retryCount))
  }

  override def fromJournal(p: StepExecutorEventPO.Event, manifest: String): EventSeq[StepExecutor.Event] = {
    val event = p match {
      case StepExecutorEventPO.Event.Started(started) =>
        val step = started.transactionStep.map { stepPO =>
          SagaTransactionStep(
            stepId = stepPO.stepId,
            phase = stepPO.phase match {
              case TransactionPhasePO.PREPARE_PHASE => PreparePhase
              case TransactionPhasePO.COMMIT_PHASE => CommitPhase
              case TransactionPhasePO.COMPENSATE_PHASE => CompensatePhase
              case _ => throw new IllegalArgumentException(s"Unknown phase: ${stepPO.phase}")
            },
            participant = stepSerializer.deserializeSagaTransactionStep(stepPO).asInstanceOf[SagaParticipant[_, _]],
            maxRetries = stepPO.maxRetries,
            timeoutDuration = stepPO.timeoutDurationMillis.milliseconds,
            retryWhenRecoveredOngoing = stepPO.retryWhenRecoveredOngoing
          )
        }.getOrElse(throw new IllegalArgumentException("TransactionStep is missing"))
        StepExecutor.ExecutionStarted(started.transactionId, step, started.replyToPath)

      case StepExecutorEventPO.Event.Succeed(OperationSucceededPO(resultType, resultBytes, _)) =>
        val result = serialization.deserialize(resultBytes.toByteArray, resultType)
        StepExecutor.OperationSucceeded(result)

      case StepExecutorEventPO.Event.Failed(failed) =>
        val error = failed.error.map { errorPO =>
          if (errorPO.isRetryable) RetryableFailure(errorPO.message)
          else NonRetryableFailure(errorPO.message)
        }.getOrElse(throw new IllegalArgumentException("Error is missing"))
        StepExecutor.OperationFailed(error)

      case StepExecutorEventPO.Event.Rescheduled(rescheduled) =>
        StepExecutor.RetryScheduled(rescheduled.retryCount)
    }
    EventSeq.single(event)
  }
}

==================================================
文件路径: app\net\imadz\infrastructure\repositories\aggregate\CreditBalanceRepositoryImpl.scala
==================================================

package net.imadz.infrastructure.repositories.aggregate

import akka.cluster.sharding.typed.scaladsl.{ClusterSharding, EntityRef}
import net.imadz.application.aggregates.CreditBalanceAggregate
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.common.CommonTypes.Id

import javax.inject.Inject

case class CreditBalanceRepositoryImpl @Inject()(sharding: ClusterSharding) extends CreditBalanceRepository {

  override def findCreditBalanceByUserId(userId: Id): EntityRef[CreditBalanceAggregate.CreditBalanceCommand] =
    sharding.entityRefFor(CreditBalanceAggregate.CreditBalanceEntityTypeKey, userId.toString)
}


==================================================
文件路径: app\net\imadz\infrastructure\repositories\projection\MonthlyIncomeAndExpenseSummaryRepositoryImpl.scala
==================================================

package net.imadz.infrastructure.repositories.projection

import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryRepository
import net.imadz.application.projection.repository.MonthlyIncomeAndExpenseSummaryTable.MonthlyIncomeAndExpenseSummary
import scalikejdbc._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future


class MonthlyIncomeAndExpenseSummaryRepositoryImpl extends MonthlyIncomeAndExpenseSummaryRepository {

  override def filterByPeriodLCRO(userId: String, startFromYear: Int, startFromMonth: Int, untilYear: Int, untilMonth: Int): Future[List[MonthlyIncomeAndExpenseSummary]] = Future {
    DB readOnly { implicit session =>
      sql"""
        SELECT user_id, income, expense, year, month
        FROM monthly_income_and_expense_summary
        WHERE user_id = ${userId}
          AND ((year > ${startFromYear}) OR (year = ${startFromYear} AND month >= ${startFromMonth}))
          AND ((year < ${untilYear}) OR (year = ${untilYear} AND month <= ${untilMonth}))
        ORDER BY year, month
      """
        .map(rs => MonthlyIncomeAndExpenseSummary(
          userId = rs.string("user_id"),
          income = rs.bigDecimal("income"),
          expense = rs.bigDecimal("expense"),
          year = rs.int("year"),
          month = rs.int("month")
        )).list.apply()
    }
  }

  override def updateIncome(userId: String, amount: BigDecimal, year: Int, month: Int, day: Int): Unit = {
    DB localTx { implicit session =>
      sql"""
        INSERT INTO monthly_income_and_expense_summary (user_id, income, year, month, day)
        VALUES (${userId}, ${amount}, ${year}, ${month}, ${day})
        ON DUPLICATE KEY UPDATE
        income = income + VALUES(income)
      """.update.apply()
    }
  }

  override def updateExpense(userId: String, amount: BigDecimal, year: Int, month: Int, day: Int): Unit = {
    DB localTx { implicit session =>
      sql"""
        INSERT INTO monthly_income_and_expense_summary (user_id, expense, year, month, day)
        VALUES (${userId}, ${amount}, ${year}, ${month}, ${day})
        ON DUPLICATE KEY UPDATE
        expense = expense + VALUES(expense)
      """.update.apply()
    }
  }
}


==================================================
文件路径: app\net\imadz\infrastructure\repositories\service\MoneyTransferTransactionRepositoryImpl.scala
==================================================

package net.imadz.infrastructure.repositories.service

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.scaladsl.adapter.ClassicActorSystemOps
import akka.actor.typed.{ActorRef, ActorSystem, Scheduler}
import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import net.imadz.application.aggregates.repository.CreditBalanceRepository
import net.imadz.application.services.transactor.MoneyTransferSagaTransactor.MoneyTransferTransactionCommand
import net.imadz.application.services.transactor.{MoneyTransferSagaTransactor, MoneyTransferSagaTransactorBehaviors, MoneyTransferTransactionRepository}
import net.imadz.common.CommonTypes.Id
import net.imadz.infra.saga.SagaTransactionCoordinator
import play.api.Application

import javax.inject.Inject
import scala.concurrent.ExecutionContext

class MoneyTransferTransactionRepositoryImpl @Inject()(sharding: ClusterSharding, app: Application,
                                                       repository: CreditBalanceRepository) extends MoneyTransferTransactionRepository {
  val system: ActorSystem[Nothing] = app.actorSystem.toTyped
  implicit val ec: ExecutionContext = system.executionContext
  implicit val scheduler: Scheduler = system.scheduler

  override def findTransactionById(transactionId: Id): ActorRef[MoneyTransferSagaTransactor.MoneyTransferTransactionCommand] = {
    val coordinator = sharding.entityRefFor(SagaTransactionCoordinator.entityTypeKey, transactionId.toString)
    system.systemActorOf(
      Behaviors.setup[MoneyTransferTransactionCommand] { context =>
        MoneyTransferSagaTransactorBehaviors.apply(context,
          coordinator, repository)
      },
      s"moneyTransferActor-$transactionId"
    )
  }
}

==================================================
文件路径: app\protobuf\credits.proto
==================================================

syntax = "proto3";

package net.imadz.infrastructure.proto;

// Define the Money type
message MoneyPO {
  double amount = 1;
  string currency = 2;
}

// Define the BalanceChanged event
message BalanceChanged {
  MoneyPO update = 1;
  int64 timestamp = 2;
}

// Define the FundsReserved event
message FundsReserved {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the FundsDeducted event
message FundsDeducted {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the ReservationReleased event
message ReservationReleased {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the IncomingCreditsRecorded event
message IncomingCreditsRecorded {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the IncomingCreditsCommited event
message IncomingCreditsCommited {
  string transferId = 1;
}

// Define the IncomingCreditsCanceled event
message IncomingCreditsCanceled {
  string transferId = 1;
}

// Define the CreditBalanceEvent union
message CreditBalanceEventPO {
  oneof event {
    BalanceChanged balanceChanged = 1;
    FundsReserved fundsReserved = 2;
    FundsDeducted fundsDeducted = 3;
    ReservationReleased reservationReleased = 4;
    IncomingCreditsRecorded incomingCreditsRecorded = 5;
    IncomingCreditsCommited incomingCreditsCommited = 6;
    IncomingCreditsCanceled incomingCreditsCanceled = 7;
  }
}

// Define the CreditBalanceState snapshot
message CreditBalanceStatePO {
  string userId = 1; // UUID can be represented as a string
  map<string, MoneyPO> accountBalance = 2;
  map<string, MoneyPO> reservedAmount = 3;
  map<string, MoneyPO> incomingCredits = 4;
}

==================================================
文件路径: app\protobuf\saga_participant.proto
==================================================

syntax = "proto3";
import "credits.proto";

package net.imadz.infrastructure.proto;

// Represents a participant that handles the from account in a transaction
message FromAccountParticipantPO {
  string from_user_id = 1;
  net.imadz.infrastructure.proto.MoneyPO amount = 2;
}

message ToAccountParticipantPO {
  string to_user_id = 1;
  net.imadz.infrastructure.proto.MoneyPO amount = 2;
}

==================================================
文件路径: app\protobuf\saga_v2.proto
==================================================

syntax = "proto3";

package net.imadz.infra.saga;

option java_multiple_files = true;
option java_package = "net.imadz.infra.saga.proto";

// Enums
enum TransactionPhasePO {
  PREPARE_PHASE = 0;
  COMMIT_PHASE = 1;
  COMPENSATE_PHASE = 2;
}

enum StepStatusPO {
  CREATED = 0;
  ONGOING = 1;
  SUCCEED = 2;
  FAILED = 3;
}


// [关键修改]：通用的参与者容器
message SagaParticipantPO {
  // 业务参与者的全限定类名，例如 "net.imadz.infra.proto.FromAccountParticipantPO"
  // 或者对应的 Scala 类名，取决于你序列化策略的映射方式
  string type_name = 1;

  // 业务参与者序列化后的二进制数据
  bytes payload = 2;
}

// Messages
message SagaTransactionStepPO {
  string step_id = 1;
  TransactionPhasePO phase = 2;
  int32 max_retries = 3;
  int64 timeout_duration_millis = 4;
  bool retry_when_recovered_ongoing = 5;
  SagaParticipantPO participant = 6;
  string participant_type = 7;// This will be used to identify the participant implementation
}

message StepStatePO {
  SagaTransactionStepPO step = 1;
  string transaction_id = 2;
  StepStatusPO status = 3;
  int32 retries = 4;
  RetryableOrNotExceptionPO last_error = 5;
  bool circuit_breaker_open = 6;
  string replyToPath = 7;
}

message RetryableOrNotExceptionPO {
  bool is_retryable = 1;
  string message = 2;
}

// Events
message ExecutionStartedPO {
  string transaction_id = 1;
  SagaTransactionStepPO transaction_step = 2;
  string replyToPath = 3;
}

message OperationSucceededPO {
  string resultType = 1;
  bytes result = 2; // Use bytes to store serialized result
}

message OperationFailedPO {
  RetryableOrNotExceptionPO error = 1;
}

message RetryScheduledPO {
  int32 retry_count = 1;
}

message StepExecutorEventPO {
  oneof event {
    ExecutionStartedPO started = 1;
    OperationSucceededPO succeed = 2;
    OperationFailedPO failed = 3;
    RetryScheduledPO rescheduled = 4;
  }
}

// Commands
message StartCommandPO {
  string transaction_id = 1;
  SagaTransactionStepPO saga_step = 2;
  string replyToPath = 3;
}

message RecoverExecutionCommandPO {
  string transaction_id = 1;
  SagaTransactionStepPO saga_step = 2;
}

message OperationSucceedCommandPO {
    string successMessageType = 1;
    bytes success = 2;
}

message OperationFailedCommandPO {
   RetryableOrNotExceptionPO error = 1;
}

message OperationResponseCommandPO {
  oneof result {
    OperationSucceedCommandPO succeed = 1;
    OperationFailedCommandPO error = 2;
  }
}

message RetryOperationCommandPO {}

message TimedOutCommandPO {}

// Coordinator's Proto

enum CoordinatorStatusPO {
  TRANSACTION_CREATED = 0;
  TRANSACTION_IN_PROGRESS = 1;
  TRANSACTION_COMPLETED = 2;
  TRANSACTION_FAILED = 3;
}

// Commands
message StartTransactionPO {
  string transaction_id = 1;
  repeated SagaTransactionStepPO steps = 2;
}

message PhaseCompletedPO {
  TransactionPhasePO phase = 1;
  repeated PhaseResultPO results = 2;
}

message PhaseFailurePO {
  TransactionPhasePO phase = 1;
  string error_message = 2;
  bool is_retryable = 3;
}

message PhaseResultPO {
  oneof result {
    string error = 1;
    bytes success = 2;
  }
}

// Events
message TransactionStartedPO {
  string transaction_id = 1;
  repeated SagaTransactionStepPO steps = 2;
}

message PhaseSucceededPO {
  TransactionPhasePO phase = 1;
}

message PhaseFailedPO {
  TransactionPhasePO phase = 1;
}

message TransactionCompletedPO {
  string transaction_id = 1;
}

message TransactionFailedPO {
  string transaction_id = 1;
  string reason = 2;
}

message SagaTransactionCoordinatorEventPO {
  oneof event {
    TransactionStartedPO started = 1;
    PhaseSucceededPO phaseSucceeded = 2;
    PhaseFailedPO phaseFailed = 3;
    TransactionCompletedPO transactionCompleted = 4;
    TransactionFailedPO transactionFailed = 5;
  }
}

// State
message CoordinatorStatePO {
  string transaction_id = 1;
  repeated SagaTransactionStepPO steps = 2;
  TransactionPhasePO current_phase = 3;
  CoordinatorStatusPO status = 4;
}

==================================================
文件路径: app\protobuf\saga_v2_test.proto
==================================================

syntax = "proto3";

package net.imadz.infra.saga;

option java_multiple_files = true;
option java_package = "net.imadz.infra.saga.proto";

// Participant definitions for testing
message SuccessfulParticipant {}

message RetryingParticipant {
  int32 succeed_after = 1;
}

message TimeoutParticipant {}

message AlwaysFailingParticipant {}

message NonRetryableFailingParticipant {}



==================================================
文件路径: app\protobuf\transactions.proto
==================================================

syntax = "proto3";
import "credits.proto";

package net.imadz.infrastructure.proto;

// Define the Id type
message string {
  string value = 1;
}

// Define the Money type


// Define the TransactionStatus enum
enum TransactionStatusPO {
  UNKNOWN = 0;
  NEW = 1;
  INITIATED = 2;
  PREPARED = 3;
  COMPLETED = 4;
  FAILED = 5;
}

// Define the Failed status message
message FailedStatusPO {
  string reason = 1;
}

// Define the TransactionStatus union
message TransactionStatusMessagePO {
  TransactionStatusPO status = 1;
  oneof details {
    FailedStatusPO failed = 2;
  }
}

// Define the TransactionState message
message TransactionStatePO {
  string id = 1;
  string fromUserId = 2;
  string toUserId = 3;
  MoneyPO amount = 4;
  TransactionStatusMessagePO status = 5;
}

// Define the TransactionEvent union
message TransactionEventPO {
  oneof event {
    TransactionInitiatedPO initiated = 1;
    TransactionPreparedPO prepared = 2;
    TransactionCompletedPO completed = 3;
    TransactionFailedPO failed = 4;
  }
}

// Define the TransactionInitiated event
message TransactionInitiatedPO {
  string fromUserId = 1;
  string toUserId = 2;
  MoneyPO amount = 3;
}

// Define the TransactionPrepared event
message TransactionPreparedPO {
  string id = 1;
}

// Define the TransactionCompleted event
message TransactionCompletedPO {
  string id = 1;
}

// Define the TransactionFailed event
message TransactionFailedPO {
  string id = 1;
  string reason = 2;
}

==================================================
文件路径: conf\application.conf
==================================================

# https://www.playframework.com/documentation/latest/Configuration
include "projection.conf"
include "persistence.conf"
include "serialization.conf"
include "cluster.conf"

akka {
  loglevel = DEBUG
}

play.modules.enabled += "scalikejdbc.PlayModule"
# scalikejdbc.PlayModule doesn't depend on Play's DBModule
play.modules.disabled += "play.api.db.DBModule"
play.filters.enabled=[controllers.filter.LoggingFilter]
play.server.websocket.periodic-keep-alive-max-idle = 10 seconds

play.temporaryFile {
  reaper {
    enabled = true
    initialDelay = "5 minutes"
    interval = "30 seconds"
    olderThan = "30 minutes"
  }
}



==================================================
文件路径: conf\cluster.conf
==================================================

akka {

   actor {
     provider = cluster
   }

   min-nr-of-member = 1

   remote.artery {
       canonical {
         hostname = ${clustering.ip}
         port = ${clustering.port}
       }
       bind {
         hostname = ${clustering.ip}
         port = ${clustering.port}
       }
     }
   cluster {
     seed-nodes = ["akka://application@"${clustering.seed-ip}":"${clustering.seed-port}]
     downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
     shutdown-after-unsuccessful-join-seed-nodes = 120s

     sharding {
       least-shard-allocation-strategy.rebalance-absolute-limit = 20
       passivation {
         strategy = custom-lru-strategy
         custom-lru-strategy {
           active-entity-limit = 1000000
           replacement.policy = least-recently-used
         }
       }
     }
   }
}

clustering {
 ip = "127.0.0.1"
 ip = ${?CLUSTER_IP}
 port = 2551
 port = ${?CLUSTER_PORT}
 seed-ip = "127.0.0.1"
 seed-ip = ${?SEED_IP}
 seed-ip = ${?SEED_PORT_1600_TCP_ADDR}
 seed-port = 2551
 seed-port = ${?SEED_PORT_1600_TCP_PORT}
 cluster.name = application
}

==================================================
文件路径: conf\persistence.conf
==================================================

akka {
  persistence {
    journal.plugin = "akka-contrib-mongodb-persistence-journal"
	snapshot-store.plugin = "akka-contrib-mongodb-persistence-snapshot"
  }
  contrib.persistence.mongodb.mongo.mongouri = "mongodb://127.0.0.1:27017/cqrs-demo-journal?maxPoolSize=20&w=majority&authSource=admin"
  contrib.persistence.mongodb.mongo.suffix-builder.separator = "_"
  contrib.persistence.mongodb.mongo.suffix-builder.class = "net.imadz.infrastructure.SuffixCollectionNames"
}

==================================================
文件路径: conf\projection.conf
==================================================

akka {

   projection {
     jdbc.blocking-jdbc-dispatcher.thread-pool-executor.fixed-pool-size = 10
     jdbc.dialect = mysql-dialect
   }

}

jdbc-connection-settings {
  driver = "com.mysql.jdbc.Driver"
  url = "jdbc:mysql://127.0.0.1:3308/cqrs_jdbc_demo?allowPublicKeyRetrieval=true&noAccessToProcedureBodies=true&createDatabaseIfNotExist=true&m=yes&characterEncoding=UTF-8&connectTimeout=300000&useSSL=false&serverTimezone=UTC&socketTimeout=30000&autoReconnect=true&maxReconnects=10&initialTimeout=10"
  user = "root"
  password = "1q2w3e4r5t"

    # the following properties are used to configure the
    # Hikari connection pool used on the read-side (akka-projections)
    connection-pool {
      # How many connections should be available to from the pool?
      # it's recommended to use the same value used by the blocking-jdbc-dispatcher (see above)
      max-pool-size = ${akka.projection.jdbc.blocking-jdbc-dispatcher.thread-pool-executor.fixed-pool-size}

      # How long should we wait (in millis) before it times out?
      # In a normal scenario, we should always be able to get a connection
      # If we got a thread from the blocking-jdbc-dispatcher, we should be able to get a connection.
      # If for some reason the pool can't provide a connection, it's better to let it crash and liberate the current thread.
      # Hence the low timout (note, 250 is lowest value hikari accepts)
      timeout = 250ms
    }
}

scalikejdbc.global {
  loggingSQLAndTime.enabled=false
  loggingSQLAndTime.singleLineMode=false
  loggingSQLAndTime.logLevel=debug
  loggingSQLAndTime.warningEnabled=true
  loggingSQLAndTime.warningThresholdMillis=5
  loggingSQLAndTime.warningLogLevel=warn
}

==================================================
文件路径: conf\serialization.conf
==================================================

akka {
   actor {
     serializers {
        jackson-json = "akka.serialization.jackson.JacksonJsonSerializer"
        jackson-cbor = "akka.serialization.jackson.JacksonCborSerializer"
        object-id-offset = "net.imadz.common.serialization.ObjectIdOffsetSerializer"
        proto = "akka.remote.serialization.ProtobufSerializer"
        saga-serializer = "net.imadz.infra.saga.serialization.SagaSerializer"
     }
     serialization-bindings {
       "akka.contrib.persistence.mongodb.ObjectIdOffset" = object-id-offset
       "com.google.protobuf.Message" = proto
       "scalapb.GeneratedMessage" = proto
       "net.imadz.common.CborSerializable" = jackson-cbor
       "net.imadz.infra.saga.StepExecutor$OperationResponse" =  saga-serializer
       "net.imadz.infra.saga.StepExecutor$OperationSucceeded" =  saga-serializer
     }
     allow-java-serialization = on
     warn-about-java-serializer-usage = off
   }

}

==================================================
文件路径: target\protobuf_external\google\protobuf\any.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option go_package = "google.golang.org/protobuf/types/known/anypb";
option java_package = "com.google.protobuf";
option java_outer_classname = "AnyProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";

// `Any` contains an arbitrary serialized protocol buffer message along with a
// URL that describes the type of the serialized message.
//
// Protobuf library provides support to pack/unpack Any values in the form
// of utility functions or additional generated methods of the Any type.
//
// Example 1: Pack and unpack a message in C++.
//
//     Foo foo = ...;
//     Any any;
//     any.PackFrom(foo);
//     ...
//     if (any.UnpackTo(&foo)) {
//       ...
//     }
//
// Example 2: Pack and unpack a message in Java.
//
//     Foo foo = ...;
//     Any any = Any.pack(foo);
//     ...
//     if (any.is(Foo.class)) {
//       foo = any.unpack(Foo.class);
//     }
//
//  Example 3: Pack and unpack a message in Python.
//
//     foo = Foo(...)
//     any = Any()
//     any.Pack(foo)
//     ...
//     if any.Is(Foo.DESCRIPTOR):
//       any.Unpack(foo)
//       ...
//
//  Example 4: Pack and unpack a message in Go
//
//      foo := &pb.Foo{...}
//      any, err := anypb.New(foo)
//      if err != nil {
//        ...
//      }
//      ...
//      foo := &pb.Foo{}
//      if err := any.UnmarshalTo(foo); err != nil {
//        ...
//      }
//
// The pack methods provided by protobuf library will by default use
// 'type.googleapis.com/full.type.name' as the type URL and the unpack
// methods only use the fully qualified type name after the last '/'
// in the type URL, for example "foo.bar.com/x/y.z" will yield type
// name "y.z".
//
//
// JSON
// ====
// The JSON representation of an `Any` value uses the regular
// representation of the deserialized, embedded message, with an
// additional field `@type` which contains the type URL. Example:
//
//     package google.profile;
//     message Person {
//       string first_name = 1;
//       string last_name = 2;
//     }
//
//     {
//       "@type": "type.googleapis.com/google.profile.Person",
//       "firstName": <string>,
//       "lastName": <string>
//     }
//
// If the embedded message type is well-known and has a custom JSON
// representation, that representation will be embedded adding a field
// `value` which holds the custom JSON in addition to the `@type`
// field. Example (for message [google.protobuf.Duration][]):
//
//     {
//       "@type": "type.googleapis.com/google.protobuf.Duration",
//       "value": "1.212s"
//     }
//
message Any {
  // A URL/resource name that uniquely identifies the type of the serialized
  // protocol buffer message. This string must contain at least
  // one "/" character. The last segment of the URL's path must represent
  // the fully qualified name of the type (as in
  // `path/google.protobuf.Duration`). The name should be in a canonical form
  // (e.g., leading "." is not accepted).
  //
  // In practice, teams usually precompile into the binary all types that they
  // expect it to use in the context of Any. However, for URLs which use the
  // scheme `http`, `https`, or no scheme, one can optionally set up a type
  // server that maps type URLs to message definitions as follows:
  //
  // * If no scheme is provided, `https` is assumed.
  // * An HTTP GET on the URL must yield a [google.protobuf.Type][]
  //   value in binary format, or produce an error.
  // * Applications are allowed to cache lookup results based on the
  //   URL, or have them precompiled into a binary to avoid any
  //   lookup. Therefore, binary compatibility needs to be preserved
  //   on changes to types. (Use versioned type names to manage
  //   breaking changes.)
  //
  // Note: this functionality is not currently available in the official
  // protobuf release, and it is not used for type URLs beginning with
  // type.googleapis.com.
  //
  // Schemes other than `http`, `https` (or the empty scheme) might be
  // used with implementation specific semantics.
  //
  string type_url = 1;

  // Must be a valid serialized protocol buffer of the above specified type.
  bytes value = 2;
}


==================================================
文件路径: target\protobuf_external\google\protobuf\api.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

import "google/protobuf/source_context.proto";
import "google/protobuf/type.proto";

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option java_package = "com.google.protobuf";
option java_outer_classname = "ApiProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";
option go_package = "google.golang.org/protobuf/types/known/apipb";

// Api is a light-weight descriptor for an API Interface.
//
// Interfaces are also described as "protocol buffer services" in some contexts,
// such as by the "service" keyword in a .proto file, but they are different
// from API Services, which represent a concrete implementation of an interface
// as opposed to simply a description of methods and bindings. They are also
// sometimes simply referred to as "APIs" in other contexts, such as the name of
// this message itself. See https://cloud.google.com/apis/design/glossary for
// detailed terminology.
message Api {
  // The fully qualified name of this interface, including package name
  // followed by the interface's simple name.
  string name = 1;

  // The methods of this interface, in unspecified order.
  repeated Method methods = 2;

  // Any metadata attached to the interface.
  repeated Option options = 3;

  // A version string for this interface. If specified, must have the form
  // `major-version.minor-version`, as in `1.10`. If the minor version is
  // omitted, it defaults to zero. If the entire version field is empty, the
  // major version is derived from the package name, as outlined below. If the
  // field is not empty, the version in the package name will be verified to be
  // consistent with what is provided here.
  //
  // The versioning schema uses [semantic
  // versioning](http://semver.org) where the major version number
  // indicates a breaking change and the minor version an additive,
  // non-breaking change. Both version numbers are signals to users
  // what to expect from different versions, and should be carefully
  // chosen based on the product plan.
  //
  // The major version is also reflected in the package name of the
  // interface, which must end in `v<major-version>`, as in
  // `google.feature.v1`. For major versions 0 and 1, the suffix can
  // be omitted. Zero major versions must only be used for
  // experimental, non-GA interfaces.
  //
  //
  string version = 4;

  // Source context for the protocol buffer service represented by this
  // message.
  SourceContext source_context = 5;

  // Included interfaces. See [Mixin][].
  repeated Mixin mixins = 6;

  // The source syntax of the service.
  Syntax syntax = 7;
}

// Method represents a method of an API interface.
message Method {
  // The simple name of this method.
  string name = 1;

  // A URL of the input message type.
  string request_type_url = 2;

  // If true, the request is streamed.
  bool request_streaming = 3;

  // The URL of the output message type.
  string response_type_url = 4;

  // If true, the response is streamed.
  bool response_streaming = 5;

  // Any metadata attached to the method.
  repeated Option options = 6;

  // The source syntax of this method.
  Syntax syntax = 7;
}

// Declares an API Interface to be included in this interface. The including
// interface must redeclare all the methods from the included interface, but
// documentation and options are inherited as follows:
//
// - If after comment and whitespace stripping, the documentation
//   string of the redeclared method is empty, it will be inherited
//   from the original method.
//
// - Each annotation belonging to the service config (http,
//   visibility) which is not set in the redeclared method will be
//   inherited.
//
// - If an http annotation is inherited, the path pattern will be
//   modified as follows. Any version prefix will be replaced by the
//   version of the including interface plus the [root][] path if
//   specified.
//
// Example of a simple mixin:
//
//     package google.acl.v1;
//     service AccessControl {
//       // Get the underlying ACL object.
//       rpc GetAcl(GetAclRequest) returns (Acl) {
//         option (google.api.http).get = "/v1/{resource=**}:getAcl";
//       }
//     }
//
//     package google.storage.v2;
//     service Storage {
//       rpc GetAcl(GetAclRequest) returns (Acl);
//
//       // Get a data record.
//       rpc GetData(GetDataRequest) returns (Data) {
//         option (google.api.http).get = "/v2/{resource=**}";
//       }
//     }
//
// Example of a mixin configuration:
//
//     apis:
//     - name: google.storage.v2.Storage
//       mixins:
//       - name: google.acl.v1.AccessControl
//
// The mixin construct implies that all methods in `AccessControl` are
// also declared with same name and request/response types in
// `Storage`. A documentation generator or annotation processor will
// see the effective `Storage.GetAcl` method after inheriting
// documentation and annotations as follows:
//
//     service Storage {
//       // Get the underlying ACL object.
//       rpc GetAcl(GetAclRequest) returns (Acl) {
//         option (google.api.http).get = "/v2/{resource=**}:getAcl";
//       }
//       ...
//     }
//
// Note how the version in the path pattern changed from `v1` to `v2`.
//
// If the `root` field in the mixin is specified, it should be a
// relative path under which inherited HTTP paths are placed. Example:
//
//     apis:
//     - name: google.storage.v2.Storage
//       mixins:
//       - name: google.acl.v1.AccessControl
//         root: acls
//
// This implies the following inherited HTTP annotation:
//
//     service Storage {
//       // Get the underlying ACL object.
//       rpc GetAcl(GetAclRequest) returns (Acl) {
//         option (google.api.http).get = "/v2/acls/{resource=**}:getAcl";
//       }
//       ...
//     }
message Mixin {
  // The fully qualified name of the interface which is included.
  string name = 1;

  // If non-empty specifies a path under which inherited HTTP paths
  // are rooted.
  string root = 2;
}


==================================================
文件路径: target\protobuf_external\google\protobuf\descriptor.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// The messages in this file describe the definitions found in .proto files.
// A valid .proto file can be translated directly to a FileDescriptorProto
// without any other information (e.g. without reading its imports).


syntax = "proto2";

package google.protobuf;

option go_package = "google.golang.org/protobuf/types/descriptorpb";
option java_package = "com.google.protobuf";
option java_outer_classname = "DescriptorProtos";
option csharp_namespace = "Google.Protobuf.Reflection";
option objc_class_prefix = "GPB";
option cc_enable_arenas = true;

// descriptor.proto must be optimized for speed because reflection-based
// algorithms don't work during bootstrapping.
option optimize_for = SPEED;

// The protocol compiler can output a FileDescriptorSet containing the .proto
// files it parses.
message FileDescriptorSet {
  repeated FileDescriptorProto file = 1;
}

// Describes a complete .proto file.
message FileDescriptorProto {
  optional string name = 1;     // file name, relative to root of source tree
  optional string package = 2;  // e.g. "foo", "foo.bar", etc.

  // Names of files imported by this file.
  repeated string dependency = 3;
  // Indexes of the public imported files in the dependency list above.
  repeated int32 public_dependency = 10;
  // Indexes of the weak imported files in the dependency list.
  // For Google-internal migration only. Do not use.
  repeated int32 weak_dependency = 11;

  // All top-level definitions in this file.
  repeated DescriptorProto message_type = 4;
  repeated EnumDescriptorProto enum_type = 5;
  repeated ServiceDescriptorProto service = 6;
  repeated FieldDescriptorProto extension = 7;

  optional FileOptions options = 8;

  // This field contains optional information about the original source code.
  // You may safely remove this entire field without harming runtime
  // functionality of the descriptors -- the information is needed only by
  // development tools.
  optional SourceCodeInfo source_code_info = 9;

  // The syntax of the proto file.
  // The supported values are "proto2" and "proto3".
  optional string syntax = 12;
}

// Describes a message type.
message DescriptorProto {
  optional string name = 1;

  repeated FieldDescriptorProto field = 2;
  repeated FieldDescriptorProto extension = 6;

  repeated DescriptorProto nested_type = 3;
  repeated EnumDescriptorProto enum_type = 4;

  message ExtensionRange {
    optional int32 start = 1;  // Inclusive.
    optional int32 end = 2;    // Exclusive.

    optional ExtensionRangeOptions options = 3;
  }
  repeated ExtensionRange extension_range = 5;

  repeated OneofDescriptorProto oneof_decl = 8;

  optional MessageOptions options = 7;

  // Range of reserved tag numbers. Reserved tag numbers may not be used by
  // fields or extension ranges in the same message. Reserved ranges may
  // not overlap.
  message ReservedRange {
    optional int32 start = 1;  // Inclusive.
    optional int32 end = 2;    // Exclusive.
  }
  repeated ReservedRange reserved_range = 9;
  // Reserved field names, which may not be used by fields in the same message.
  // A given name may only be reserved once.
  repeated string reserved_name = 10;
}

message ExtensionRangeOptions {
  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;


  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

// Describes a field within a message.
message FieldDescriptorProto {
  enum Type {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    TYPE_DOUBLE = 1;
    TYPE_FLOAT = 2;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    TYPE_INT64 = 3;
    TYPE_UINT64 = 4;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    TYPE_INT32 = 5;
    TYPE_FIXED64 = 6;
    TYPE_FIXED32 = 7;
    TYPE_BOOL = 8;
    TYPE_STRING = 9;
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    TYPE_GROUP = 10;
    TYPE_MESSAGE = 11;  // Length-delimited aggregate.

    // New in version 2.
    TYPE_BYTES = 12;
    TYPE_UINT32 = 13;
    TYPE_ENUM = 14;
    TYPE_SFIXED32 = 15;
    TYPE_SFIXED64 = 16;
    TYPE_SINT32 = 17;  // Uses ZigZag encoding.
    TYPE_SINT64 = 18;  // Uses ZigZag encoding.
  }

  enum Label {
    // 0 is reserved for errors
    LABEL_OPTIONAL = 1;
    LABEL_REQUIRED = 2;
    LABEL_REPEATED = 3;
  }

  optional string name = 1;
  optional int32 number = 3;
  optional Label label = 4;

  // If type_name is set, this need not be set.  If both this and type_name
  // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
  optional Type type = 5;

  // For message and enum types, this is the name of the type.  If the name
  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
  // rules are used to find the type (i.e. first the nested types within this
  // message are searched, then within the parent, on up to the root
  // namespace).
  optional string type_name = 6;

  // For extensions, this is the name of the type being extended.  It is
  // resolved in the same manner as type_name.
  optional string extendee = 2;

  // For numeric types, contains the original text representation of the value.
  // For booleans, "true" or "false".
  // For strings, contains the default text contents (not escaped in any way).
  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
  // TODO(kenton):  Base-64 encode?
  optional string default_value = 7;

  // If set, gives the index of a oneof in the containing type's oneof_decl
  // list.  This field is a member of that oneof.
  optional int32 oneof_index = 9;

  // JSON name of this field. The value is set by protocol compiler. If the
  // user has set a "json_name" option on this field, that option's value
  // will be used. Otherwise, it's deduced from the field's name by converting
  // it to camelCase.
  optional string json_name = 10;

  optional FieldOptions options = 8;

  // If true, this is a proto3 "optional". When a proto3 field is optional, it
  // tracks presence regardless of field type.
  //
  // When proto3_optional is true, this field must be belong to a oneof to
  // signal to old proto3 clients that presence is tracked for this field. This
  // oneof is known as a "synthetic" oneof, and this field must be its sole
  // member (each proto3 optional field gets its own synthetic oneof). Synthetic
  // oneofs exist in the descriptor only, and do not generate any API. Synthetic
  // oneofs must be ordered after all "real" oneofs.
  //
  // For message fields, proto3_optional doesn't create any semantic change,
  // since non-repeated message fields always track presence. However it still
  // indicates the semantic detail of whether the user wrote "optional" or not.
  // This can be useful for round-tripping the .proto file. For consistency we
  // give message fields a synthetic oneof also, even though it is not required
  // to track presence. This is especially important because the parser can't
  // tell if a field is a message or an enum, so it must always create a
  // synthetic oneof.
  //
  // Proto2 optional fields do not set this flag, because they already indicate
  // optional with `LABEL_OPTIONAL`.
  optional bool proto3_optional = 17;
}

// Describes a oneof.
message OneofDescriptorProto {
  optional string name = 1;
  optional OneofOptions options = 2;
}

// Describes an enum type.
message EnumDescriptorProto {
  optional string name = 1;

  repeated EnumValueDescriptorProto value = 2;

  optional EnumOptions options = 3;

  // Range of reserved numeric values. Reserved values may not be used by
  // entries in the same enum. Reserved ranges may not overlap.
  //
  // Note that this is distinct from DescriptorProto.ReservedRange in that it
  // is inclusive such that it can appropriately represent the entire int32
  // domain.
  message EnumReservedRange {
    optional int32 start = 1;  // Inclusive.
    optional int32 end = 2;    // Inclusive.
  }

  // Range of reserved numeric values. Reserved numeric values may not be used
  // by enum values in the same enum declaration. Reserved ranges may not
  // overlap.
  repeated EnumReservedRange reserved_range = 4;

  // Reserved enum value names, which may not be reused. A given name may only
  // be reserved once.
  repeated string reserved_name = 5;
}

// Describes a value within an enum.
message EnumValueDescriptorProto {
  optional string name = 1;
  optional int32 number = 2;

  optional EnumValueOptions options = 3;
}

// Describes a service.
message ServiceDescriptorProto {
  optional string name = 1;
  repeated MethodDescriptorProto method = 2;

  optional ServiceOptions options = 3;
}

// Describes a method of a service.
message MethodDescriptorProto {
  optional string name = 1;

  // Input and output type names.  These are resolved in the same way as
  // FieldDescriptorProto.type_name, but must refer to a message type.
  optional string input_type = 2;
  optional string output_type = 3;

  optional MethodOptions options = 4;

  // Identifies if client streams multiple client messages
  optional bool client_streaming = 5 [default = false];
  // Identifies if server streams multiple server messages
  optional bool server_streaming = 6 [default = false];
}


// ===================================================================
// Options

// Each of the definitions above may have "options" attached.  These are
// just annotations which may cause code to be generated slightly differently
// or may contain hints for code that manipulates protocol messages.
//
// Clients may define custom options as extensions of the *Options messages.
// These extensions may not yet be known at parsing time, so the parser cannot
// store the values in them.  Instead it stores them in a field in the *Options
// message called uninterpreted_option. This field must have the same name
// across all *Options messages. We then use this field to populate the
// extensions when we build a descriptor, at which point all protos have been
// parsed and so all extensions are known.
//
// Extension numbers for custom options may be chosen as follows:
// * For options which will only be used within a single application or
//   organization, or for experimental options, use field numbers 50000
//   through 99999.  It is up to you to ensure that you do not use the
//   same number for multiple options.
// * For options which will be published and used publicly by multiple
//   independent entities, e-mail protobuf-global-extension-registry@google.com
//   to reserve extension numbers. Simply provide your project name (e.g.
//   Objective-C plugin) and your project website (if available) -- there's no
//   need to explain how you intend to use them. Usually you only need one
//   extension number. You can declare multiple options with only one extension
//   number by putting them in a sub-message. See the Custom Options section of
//   the docs for examples:
//   https://developers.google.com/protocol-buffers/docs/proto#options
//   If this turns out to be popular, a web service will be set up
//   to automatically assign option numbers.

message FileOptions {

  // Sets the Java package where classes generated from this .proto will be
  // placed.  By default, the proto package is used, but this is often
  // inappropriate because proto packages do not normally start with backwards
  // domain names.
  optional string java_package = 1;


  // Controls the name of the wrapper Java class generated for the .proto file.
  // That class will always contain the .proto file's getDescriptor() method as
  // well as any top-level extensions defined in the .proto file.
  // If java_multiple_files is disabled, then all the other classes from the
  // .proto file will be nested inside the single wrapper outer class.
  optional string java_outer_classname = 8;

  // If enabled, then the Java code generator will generate a separate .java
  // file for each top-level message, enum, and service defined in the .proto
  // file.  Thus, these types will *not* be nested inside the wrapper class
  // named by java_outer_classname.  However, the wrapper class will still be
  // generated to contain the file's getDescriptor() method as well as any
  // top-level extensions defined in the file.
  optional bool java_multiple_files = 10 [default = false];

  // This option does nothing.
  optional bool java_generate_equals_and_hash = 20 [deprecated=true];

  // If set true, then the Java2 code generator will generate code that
  // throws an exception whenever an attempt is made to assign a non-UTF-8
  // byte sequence to a string field.
  // Message reflection will do the same.
  // However, an extension field still accepts non-UTF-8 byte sequences.
  // This option has no effect on when used with the lite runtime.
  optional bool java_string_check_utf8 = 27 [default = false];


  // Generated classes can be optimized for speed or code size.
  enum OptimizeMode {
    SPEED = 1;         // Generate complete code for parsing, serialization,
                       // etc.
    CODE_SIZE = 2;     // Use ReflectionOps to implement these methods.
    LITE_RUNTIME = 3;  // Generate code using MessageLite and the lite runtime.
  }
  optional OptimizeMode optimize_for = 9 [default = SPEED];

  // Sets the Go package where structs generated from this .proto will be
  // placed. If omitted, the Go package will be derived from the following:
  //   - The basename of the package import path, if provided.
  //   - Otherwise, the package statement in the .proto file, if present.
  //   - Otherwise, the basename of the .proto file, without extension.
  optional string go_package = 11;




  // Should generic services be generated in each language?  "Generic" services
  // are not specific to any particular RPC system.  They are generated by the
  // main code generators in each language (without additional plugins).
  // Generic services were the only kind of service generation supported by
  // early versions of google.protobuf.
  //
  // Generic services are now considered deprecated in favor of using plugins
  // that generate code specific to your particular RPC system.  Therefore,
  // these default to false.  Old code which depends on generic services should
  // explicitly set them to true.
  optional bool cc_generic_services = 16 [default = false];
  optional bool java_generic_services = 17 [default = false];
  optional bool py_generic_services = 18 [default = false];
  optional bool php_generic_services = 42 [default = false];

  // Is this file deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for everything in the file, or it will be completely ignored; in the very
  // least, this is a formalization for deprecating files.
  optional bool deprecated = 23 [default = false];

  // Enables the use of arenas for the proto messages in this file. This applies
  // only to generated classes for C++.
  optional bool cc_enable_arenas = 31 [default = true];


  // Sets the objective c class prefix which is prepended to all objective c
  // generated classes from this .proto. There is no default.
  optional string objc_class_prefix = 36;

  // Namespace for generated classes; defaults to the package.
  optional string csharp_namespace = 37;

  // By default Swift generators will take the proto package and CamelCase it
  // replacing '.' with underscore and use that to prefix the types/symbols
  // defined. When this options is provided, they will use this value instead
  // to prefix the types/symbols defined.
  optional string swift_prefix = 39;

  // Sets the php class prefix which is prepended to all php generated classes
  // from this .proto. Default is empty.
  optional string php_class_prefix = 40;

  // Use this option to change the namespace of php generated classes. Default
  // is empty. When this option is empty, the package name will be used for
  // determining the namespace.
  optional string php_namespace = 41;

  // Use this option to change the namespace of php generated metadata classes.
  // Default is empty. When this option is empty, the proto file name will be
  // used for determining the namespace.
  optional string php_metadata_namespace = 44;

  // Use this option to change the package of ruby generated classes. Default
  // is empty. When this option is not set, the package name will be used for
  // determining the ruby package.
  optional string ruby_package = 45;


  // The parser stores options it doesn't recognize here.
  // See the documentation for the "Options" section above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message.
  // See the documentation for the "Options" section above.
  extensions 1000 to max;

  reserved 38;
}

message MessageOptions {
  // Set true to use the old proto1 MessageSet wire format for extensions.
  // This is provided for backwards-compatibility with the MessageSet wire
  // format.  You should not use this for any other reason:  It's less
  // efficient, has fewer features, and is more complicated.
  //
  // The message must be defined exactly as follows:
  //   message Foo {
  //     option message_set_wire_format = true;
  //     extensions 4 to max;
  //   }
  // Note that the message cannot have any defined fields; MessageSets only
  // have extensions.
  //
  // All extensions of your type must be singular messages; e.g. they cannot
  // be int32s, enums, or repeated messages.
  //
  // Because this is an option, the above two restrictions are not enforced by
  // the protocol compiler.
  optional bool message_set_wire_format = 1 [default = false];

  // Disables the generation of the standard "descriptor()" accessor, which can
  // conflict with a field of the same name.  This is meant to make migration
  // from proto1 easier; new code should avoid fields named "descriptor".
  optional bool no_standard_descriptor_accessor = 2 [default = false];

  // Is this message deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the message, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating messages.
  optional bool deprecated = 3 [default = false];

  reserved 4, 5, 6;

  // Whether the message is an automatically generated map entry type for the
  // maps field.
  //
  // For maps fields:
  //     map<KeyType, ValueType> map_field = 1;
  // The parsed descriptor looks like:
  //     message MapFieldEntry {
  //         option map_entry = true;
  //         optional KeyType key = 1;
  //         optional ValueType value = 2;
  //     }
  //     repeated MapFieldEntry map_field = 1;
  //
  // Implementations may choose not to generate the map_entry=true message, but
  // use a native map in the target language to hold the keys and values.
  // The reflection APIs in such implementations still need to work as
  // if the field is a repeated message field.
  //
  // NOTE: Do not set the option in .proto files. Always use the maps syntax
  // instead. The option should only be implicitly set by the proto compiler
  // parser.
  optional bool map_entry = 7;

  reserved 8;  // javalite_serializable
  reserved 9;  // javanano_as_lite


  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message FieldOptions {
  // The ctype option instructs the C++ code generator to use a different
  // representation of the field than it normally would.  See the specific
  // options below.  This option is not yet implemented in the open source
  // release -- sorry, we'll try to include it in a future version!
  optional CType ctype = 1 [default = STRING];
  enum CType {
    // Default mode.
    STRING = 0;

    CORD = 1;

    STRING_PIECE = 2;
  }
  // The packed option can be enabled for repeated primitive fields to enable
  // a more efficient representation on the wire. Rather than repeatedly
  // writing the tag and type for each element, the entire array is encoded as
  // a single length-delimited blob. In proto3, only explicit setting it to
  // false will avoid using packed encoding.
  optional bool packed = 2;

  // The jstype option determines the JavaScript type used for values of the
  // field.  The option is permitted only for 64 bit integral and fixed types
  // (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
  // is represented as JavaScript string, which avoids loss of precision that
  // can happen when a large value is converted to a floating point JavaScript.
  // Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
  // use the JavaScript "number" type.  The behavior of the default option
  // JS_NORMAL is implementation dependent.
  //
  // This option is an enum to permit additional types to be added, e.g.
  // goog.math.Integer.
  optional JSType jstype = 6 [default = JS_NORMAL];
  enum JSType {
    // Use the default type.
    JS_NORMAL = 0;

    // Use JavaScript strings.
    JS_STRING = 1;

    // Use JavaScript numbers.
    JS_NUMBER = 2;
  }

  // Should this field be parsed lazily?  Lazy applies only to message-type
  // fields.  It means that when the outer message is initially parsed, the
  // inner message's contents will not be parsed but instead stored in encoded
  // form.  The inner message will actually be parsed when it is first accessed.
  //
  // This is only a hint.  Implementations are free to choose whether to use
  // eager or lazy parsing regardless of the value of this option.  However,
  // setting this option true suggests that the protocol author believes that
  // using lazy parsing on this field is worth the additional bookkeeping
  // overhead typically needed to implement it.
  //
  // This option does not affect the public interface of any generated code;
  // all method signatures remain the same.  Furthermore, thread-safety of the
  // interface is not affected by this option; const methods remain safe to
  // call from multiple threads concurrently, while non-const methods continue
  // to require exclusive access.
  //
  //
  // Note that implementations may choose not to check required fields within
  // a lazy sub-message.  That is, calling IsInitialized() on the outer message
  // may return true even if the inner message has missing required fields.
  // This is necessary because otherwise the inner message would have to be
  // parsed in order to perform the check, defeating the purpose of lazy
  // parsing.  An implementation which chooses not to check required fields
  // must be consistent about it.  That is, for any particular sub-message, the
  // implementation must either *always* check its required fields, or *never*
  // check its required fields, regardless of whether or not the message has
  // been parsed.
  optional bool lazy = 5 [default = false];

  // Is this field deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for accessors, or it will be completely ignored; in the very least, this
  // is a formalization for deprecating fields.
  optional bool deprecated = 3 [default = false];

  // For Google-internal migration only. Do not use.
  optional bool weak = 10 [default = false];


  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;

  reserved 4;  // removed jtype
}

message OneofOptions {
  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message EnumOptions {

  // Set this option to true to allow mapping different tag names to the same
  // value.
  optional bool allow_alias = 2;

  // Is this enum deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the enum, or it will be completely ignored; in the very least, this
  // is a formalization for deprecating enums.
  optional bool deprecated = 3 [default = false];

  reserved 5;  // javanano_as_lite

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message EnumValueOptions {
  // Is this enum value deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the enum value, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating enum values.
  optional bool deprecated = 1 [default = false];

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message ServiceOptions {

  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
  //   framework.  We apologize for hoarding these numbers to ourselves, but
  //   we were already using them long before we decided to release Protocol
  //   Buffers.

  // Is this service deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the service, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating services.
  optional bool deprecated = 33 [default = false];

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message MethodOptions {

  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
  //   framework.  We apologize for hoarding these numbers to ourselves, but
  //   we were already using them long before we decided to release Protocol
  //   Buffers.

  // Is this method deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the method, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating methods.
  optional bool deprecated = 33 [default = false];

  // Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
  // or neither? HTTP based RPC implementation may choose GET verb for safe
  // methods, and PUT verb for idempotent methods instead of the default POST.
  enum IdempotencyLevel {
    IDEMPOTENCY_UNKNOWN = 0;
    NO_SIDE_EFFECTS = 1;  // implies idempotent
    IDEMPOTENT = 2;       // idempotent, but may have side effects
  }
  optional IdempotencyLevel idempotency_level = 34
      [default = IDEMPOTENCY_UNKNOWN];

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}


// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
message UninterpretedOption {
  // The name of the uninterpreted option.  Each string represents a segment in
  // a dot-separated name.  is_extension is true iff a segment represents an
  // extension (denoted with parentheses in options specs in .proto files).
  // E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
  // "foo.(bar.baz).qux".
  message NamePart {
    required string name_part = 1;
    required bool is_extension = 2;
  }
  repeated NamePart name = 2;

  // The value of the uninterpreted option, in whatever type the tokenizer
  // identified it as during parsing. Exactly one of these should be set.
  optional string identifier_value = 3;
  optional uint64 positive_int_value = 4;
  optional int64 negative_int_value = 5;
  optional double double_value = 6;
  optional bytes string_value = 7;
  optional string aggregate_value = 8;
}

// ===================================================================
// Optional source code info

// Encapsulates information about the original source file from which a
// FileDescriptorProto was generated.
message SourceCodeInfo {
  // A Location identifies a piece of source code in a .proto file which
  // corresponds to a particular definition.  This information is intended
  // to be useful to IDEs, code indexers, documentation generators, and similar
  // tools.
  //
  // For example, say we have a file like:
  //   message Foo {
  //     optional string foo = 1;
  //   }
  // Let's look at just the field definition:
  //   optional string foo = 1;
  //   ^       ^^     ^^  ^  ^^^
  //   a       bc     de  f  ghi
  // We have the following locations:
  //   span   path               represents
  //   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
  //   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
  //   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
  //   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
  //   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
  //
  // Notes:
  // - A location may refer to a repeated field itself (i.e. not to any
  //   particular index within it).  This is used whenever a set of elements are
  //   logically enclosed in a single code segment.  For example, an entire
  //   extend block (possibly containing multiple extension definitions) will
  //   have an outer location whose path refers to the "extensions" repeated
  //   field without an index.
  // - Multiple locations may have the same path.  This happens when a single
  //   logical declaration is spread out across multiple places.  The most
  //   obvious example is the "extend" block again -- there may be multiple
  //   extend blocks in the same scope, each of which will have the same path.
  // - A location's span is not always a subset of its parent's span.  For
  //   example, the "extendee" of an extension declaration appears at the
  //   beginning of the "extend" block and is shared by all extensions within
  //   the block.
  // - Just because a location's span is a subset of some other location's span
  //   does not mean that it is a descendant.  For example, a "group" defines
  //   both a type and a field in a single declaration.  Thus, the locations
  //   corresponding to the type and field and their components will overlap.
  // - Code which tries to interpret locations should probably be designed to
  //   ignore those that it doesn't understand, as more types of locations could
  //   be recorded in the future.
  repeated Location location = 1;
  message Location {
    // Identifies which part of the FileDescriptorProto was defined at this
    // location.
    //
    // Each element is a field number or an index.  They form a path from
    // the root FileDescriptorProto to the place where the definition.  For
    // example, this path:
    //   [ 4, 3, 2, 7, 1 ]
    // refers to:
    //   file.message_type(3)  // 4, 3
    //       .field(7)         // 2, 7
    //       .name()           // 1
    // This is because FileDescriptorProto.message_type has field number 4:
    //   repeated DescriptorProto message_type = 4;
    // and DescriptorProto.field has field number 2:
    //   repeated FieldDescriptorProto field = 2;
    // and FieldDescriptorProto.name has field number 1:
    //   optional string name = 1;
    //
    // Thus, the above path gives the location of a field name.  If we removed
    // the last element:
    //   [ 4, 3, 2, 7 ]
    // this path refers to the whole field declaration (from the beginning
    // of the label to the terminating semicolon).
    repeated int32 path = 1 [packed = true];

    // Always has exactly three or four elements: start line, start column,
    // end line (optional, otherwise assumed same as start line), end column.
    // These are packed into a single field for efficiency.  Note that line
    // and column numbers are zero-based -- typically you will want to add
    // 1 to each before displaying to a user.
    repeated int32 span = 2 [packed = true];

    // If this SourceCodeInfo represents a complete declaration, these are any
    // comments appearing before and after the declaration which appear to be
    // attached to the declaration.
    //
    // A series of line comments appearing on consecutive lines, with no other
    // tokens appearing on those lines, will be treated as a single comment.
    //
    // leading_detached_comments will keep paragraphs of comments that appear
    // before (but not connected to) the current element. Each paragraph,
    // separated by empty lines, will be one comment element in the repeated
    // field.
    //
    // Only the comment content is provided; comment markers (e.g. //) are
    // stripped out.  For block comments, leading whitespace and an asterisk
    // will be stripped from the beginning of each line other than the first.
    // Newlines are included in the output.
    //
    // Examples:
    //
    //   optional int32 foo = 1;  // Comment attached to foo.
    //   // Comment attached to bar.
    //   optional int32 bar = 2;
    //
    //   optional string baz = 3;
    //   // Comment attached to baz.
    //   // Another line attached to baz.
    //
    //   // Comment attached to qux.
    //   //
    //   // Another line attached to qux.
    //   optional double qux = 4;
    //
    //   // Detached comment for corge. This is not leading or trailing comments
    //   // to qux or corge because there are blank lines separating it from
    //   // both.
    //
    //   // Detached comment for corge paragraph 2.
    //
    //   optional string corge = 5;
    //   /* Block comment attached
    //    * to corge.  Leading asterisks
    //    * will be removed. */
    //   /* Block comment attached to
    //    * grault. */
    //   optional int32 grault = 6;
    //
    //   // ignored detached comments.
    optional string leading_comments = 3;
    optional string trailing_comments = 4;
    repeated string leading_detached_comments = 6;
  }
}

// Describes the relationship between generated code and its original source
// file. A GeneratedCodeInfo message is associated with only one generated
// source file, but may contain references to different source .proto files.
message GeneratedCodeInfo {
  // An Annotation connects some span of text in generated code to an element
  // of its generating .proto file.
  repeated Annotation annotation = 1;
  message Annotation {
    // Identifies the element in the original source .proto file. This field
    // is formatted the same as SourceCodeInfo.Location.path.
    repeated int32 path = 1 [packed = true];

    // Identifies the filesystem path to the original source .proto.
    optional string source_file = 2;

    // Identifies the starting offset in bytes in the generated code
    // that relates to the identified object.
    optional int32 begin = 3;

    // Identifies the ending offset in bytes in the generated code that
    // relates to the identified offset. The end offset should be one past
    // the last relevant byte (so the length of the text = end - begin).
    optional int32 end = 4;
  }
}


==================================================
文件路径: target\protobuf_external\google\protobuf\duration.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option cc_enable_arenas = true;
option go_package = "google.golang.org/protobuf/types/known/durationpb";
option java_package = "com.google.protobuf";
option java_outer_classname = "DurationProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";

// A Duration represents a signed, fixed-length span of time represented
// as a count of seconds and fractions of seconds at nanosecond
// resolution. It is independent of any calendar and concepts like "day"
// or "month". It is related to Timestamp in that the difference between
// two Timestamp values is a Duration and it can be added or subtracted
// from a Timestamp. Range is approximately +-10,000 years.
//
// # Examples
//
// Example 1: Compute Duration from two Timestamps in pseudo code.
//
//     Timestamp start = ...;
//     Timestamp end = ...;
//     Duration duration = ...;
//
//     duration.seconds = end.seconds - start.seconds;
//     duration.nanos = end.nanos - start.nanos;
//
//     if (duration.seconds < 0 && duration.nanos > 0) {
//       duration.seconds += 1;
//       duration.nanos -= 1000000000;
//     } else if (duration.seconds > 0 && duration.nanos < 0) {
//       duration.seconds -= 1;
//       duration.nanos += 1000000000;
//     }
//
// Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
//
//     Timestamp start = ...;
//     Duration duration = ...;
//     Timestamp end = ...;
//
//     end.seconds = start.seconds + duration.seconds;
//     end.nanos = start.nanos + duration.nanos;
//
//     if (end.nanos < 0) {
//       end.seconds -= 1;
//       end.nanos += 1000000000;
//     } else if (end.nanos >= 1000000000) {
//       end.seconds += 1;
//       end.nanos -= 1000000000;
//     }
//
// Example 3: Compute Duration from datetime.timedelta in Python.
//
//     td = datetime.timedelta(days=3, minutes=10)
//     duration = Duration()
//     duration.FromTimedelta(td)
//
// # JSON Mapping
//
// In JSON format, the Duration type is encoded as a string rather than an
// object, where the string ends in the suffix "s" (indicating seconds) and
// is preceded by the number of seconds, with nanoseconds expressed as
// fractional seconds. For example, 3 seconds with 0 nanoseconds should be
// encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
// be expressed in JSON format as "3.000000001s", and 3 seconds and 1
// microsecond should be expressed in JSON format as "3.000001s".
//
//
message Duration {
  // Signed seconds of the span of time. Must be from -315,576,000,000
  // to +315,576,000,000 inclusive. Note: these bounds are computed from:
  // 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
  int64 seconds = 1;

  // Signed fractions of a second at nanosecond resolution of the span
  // of time. Durations less than one second are represented with a 0
  // `seconds` field and a positive or negative `nanos` field. For durations
  // of one second or more, a non-zero value for the `nanos` field must be
  // of the same sign as the `seconds` field. Must be from -999,999,999
  // to +999,999,999 inclusive.
  int32 nanos = 2;
}


==================================================
文件路径: target\protobuf_external\google\protobuf\empty.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option go_package = "google.golang.org/protobuf/types/known/emptypb";
option java_package = "com.google.protobuf";
option java_outer_classname = "EmptyProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";
option cc_enable_arenas = true;

// A generic empty message that you can re-use to avoid defining duplicated
// empty messages in your APIs. A typical example is to use it as the request
// or the response type of an API method. For instance:
//
//     service Foo {
//       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
//     }
//
// The JSON representation for `Empty` is empty JSON object `{}`.
message Empty {}


==================================================
文件路径: target\protobuf_external\google\protobuf\field_mask.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option java_package = "com.google.protobuf";
option java_outer_classname = "FieldMaskProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";
option go_package = "google.golang.org/protobuf/types/known/fieldmaskpb";
option cc_enable_arenas = true;

// `FieldMask` represents a set of symbolic field paths, for example:
//
//     paths: "f.a"
//     paths: "f.b.d"
//
// Here `f` represents a field in some root message, `a` and `b`
// fields in the message found in `f`, and `d` a field found in the
// message in `f.b`.
//
// Field masks are used to specify a subset of fields that should be
// returned by a get operation or modified by an update operation.
// Field masks also have a custom JSON encoding (see below).
//
// # Field Masks in Projections
//
// When used in the context of a projection, a response message or
// sub-message is filtered by the API to only contain those fields as
// specified in the mask. For example, if the mask in the previous
// example is applied to a response message as follows:
//
//     f {
//       a : 22
//       b {
//         d : 1
//         x : 2
//       }
//       y : 13
//     }
//     z: 8
//
// The result will not contain specific values for fields x,y and z
// (their value will be set to the default, and omitted in proto text
// output):
//
//
//     f {
//       a : 22
//       b {
//         d : 1
//       }
//     }
//
// A repeated field is not allowed except at the last position of a
// paths string.
//
// If a FieldMask object is not present in a get operation, the
// operation applies to all fields (as if a FieldMask of all fields
// had been specified).
//
// Note that a field mask does not necessarily apply to the
// top-level response message. In case of a REST get operation, the
// field mask applies directly to the response, but in case of a REST
// list operation, the mask instead applies to each individual message
// in the returned resource list. In case of a REST custom method,
// other definitions may be used. Where the mask applies will be
// clearly documented together with its declaration in the API.  In
// any case, the effect on the returned resource/resources is required
// behavior for APIs.
//
// # Field Masks in Update Operations
//
// A field mask in update operations specifies which fields of the
// targeted resource are going to be updated. The API is required
// to only change the values of the fields as specified in the mask
// and leave the others untouched. If a resource is passed in to
// describe the updated values, the API ignores the values of all
// fields not covered by the mask.
//
// If a repeated field is specified for an update operation, new values will
// be appended to the existing repeated field in the target resource. Note that
// a repeated field is only allowed in the last position of a `paths` string.
//
// If a sub-message is specified in the last position of the field mask for an
// update operation, then new value will be merged into the existing sub-message
// in the target resource.
//
// For example, given the target message:
//
//     f {
//       b {
//         d: 1
//         x: 2
//       }
//       c: [1]
//     }
//
// And an update message:
//
//     f {
//       b {
//         d: 10
//       }
//       c: [2]
//     }
//
// then if the field mask is:
//
//  paths: ["f.b", "f.c"]
//
// then the result will be:
//
//     f {
//       b {
//         d: 10
//         x: 2
//       }
//       c: [1, 2]
//     }
//
// An implementation may provide options to override this default behavior for
// repeated and message fields.
//
// In order to reset a field's value to the default, the field must
// be in the mask and set to the default value in the provided resource.
// Hence, in order to reset all fields of a resource, provide a default
// instance of the resource and set all fields in the mask, or do
// not provide a mask as described below.
//
// If a field mask is not present on update, the operation applies to
// all fields (as if a field mask of all fields has been specified).
// Note that in the presence of schema evolution, this may mean that
// fields the client does not know and has therefore not filled into
// the request will be reset to their default. If this is unwanted
// behavior, a specific service may require a client to always specify
// a field mask, producing an error if not.
//
// As with get operations, the location of the resource which
// describes the updated values in the request message depends on the
// operation kind. In any case, the effect of the field mask is
// required to be honored by the API.
//
// ## Considerations for HTTP REST
//
// The HTTP kind of an update operation which uses a field mask must
// be set to PATCH instead of PUT in order to satisfy HTTP semantics
// (PUT must only be used for full updates).
//
// # JSON Encoding of Field Masks
//
// In JSON, a field mask is encoded as a single string where paths are
// separated by a comma. Fields name in each path are converted
// to/from lower-camel naming conventions.
//
// As an example, consider the following message declarations:
//
//     message Profile {
//       User user = 1;
//       Photo photo = 2;
//     }
//     message User {
//       string display_name = 1;
//       string address = 2;
//     }
//
// In proto a field mask for `Profile` may look as such:
//
//     mask {
//       paths: "user.display_name"
//       paths: "photo"
//     }
//
// In JSON, the same mask is represented as below:
//
//     {
//       mask: "user.displayName,photo"
//     }
//
// # Field Masks and Oneof Fields
//
// Field masks treat fields in oneofs just as regular fields. Consider the
// following message:
//
//     message SampleMessage {
//       oneof test_oneof {
//         string name = 4;
//         SubMessage sub_message = 9;
//       }
//     }
//
// The field mask can be:
//
//     mask {
//       paths: "name"
//     }
//
// Or:
//
//     mask {
//       paths: "sub_message"
//     }
//
// Note that oneof type names ("test_oneof" in this case) cannot be used in
// paths.
//
// ## Field Mask Verification
//
// The implementation of any API method which has a FieldMask type field in the
// request should verify the included field paths, and return an
// `INVALID_ARGUMENT` error if any path is unmappable.
message FieldMask {
  // The set of field mask paths.
  repeated string paths = 1;
}


==================================================
文件路径: target\protobuf_external\google\protobuf\source_context.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option java_package = "com.google.protobuf";
option java_outer_classname = "SourceContextProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";
option go_package = "google.golang.org/protobuf/types/known/sourcecontextpb";

// `SourceContext` represents information about the source of a
// protobuf element, like the file in which it is defined.
message SourceContext {
  // The path-qualified name of the .proto file that contained the associated
  // protobuf element.  For example: `"google/protobuf/source_context.proto"`.
  string file_name = 1;
}


==================================================
文件路径: target\protobuf_external\google\protobuf\struct.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option cc_enable_arenas = true;
option go_package = "google.golang.org/protobuf/types/known/structpb";
option java_package = "com.google.protobuf";
option java_outer_classname = "StructProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";

// `Struct` represents a structured data value, consisting of fields
// which map to dynamically typed values. In some languages, `Struct`
// might be supported by a native representation. For example, in
// scripting languages like JS a struct is represented as an
// object. The details of that representation are described together
// with the proto support for the language.
//
// The JSON representation for `Struct` is JSON object.
message Struct {
  // Unordered map of dynamically typed values.
  map<string, Value> fields = 1;
}

// `Value` represents a dynamically typed value which can be either
// null, a number, a string, a boolean, a recursive struct value, or a
// list of values. A producer of value is expected to set one of these
// variants. Absence of any variant indicates an error.
//
// The JSON representation for `Value` is JSON value.
message Value {
  // The kind of value.
  oneof kind {
    // Represents a null value.
    NullValue null_value = 1;
    // Represents a double value.
    double number_value = 2;
    // Represents a string value.
    string string_value = 3;
    // Represents a boolean value.
    bool bool_value = 4;
    // Represents a structured value.
    Struct struct_value = 5;
    // Represents a repeated `Value`.
    ListValue list_value = 6;
  }
}

// `NullValue` is a singleton enumeration to represent the null value for the
// `Value` type union.
//
//  The JSON representation for `NullValue` is JSON `null`.
enum NullValue {
  // Null value.
  NULL_VALUE = 0;
}

// `ListValue` is a wrapper around a repeated field of values.
//
// The JSON representation for `ListValue` is JSON array.
message ListValue {
  // Repeated field of dynamically typed values.
  repeated Value values = 1;
}


==================================================
文件路径: target\protobuf_external\google\protobuf\timestamp.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option cc_enable_arenas = true;
option go_package = "google.golang.org/protobuf/types/known/timestamppb";
option java_package = "com.google.protobuf";
option java_outer_classname = "TimestampProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";

// A Timestamp represents a point in time independent of any time zone or local
// calendar, encoded as a count of seconds and fractions of seconds at
// nanosecond resolution. The count is relative to an epoch at UTC midnight on
// January 1, 1970, in the proleptic Gregorian calendar which extends the
// Gregorian calendar backwards to year one.
//
// All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
// second table is needed for interpretation, using a [24-hour linear
// smear](https://developers.google.com/time/smear).
//
// The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
// restricting to that range, we ensure that we can convert to and from [RFC
// 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
//
// # Examples
//
// Example 1: Compute Timestamp from POSIX `time()`.
//
//     Timestamp timestamp;
//     timestamp.set_seconds(time(NULL));
//     timestamp.set_nanos(0);
//
// Example 2: Compute Timestamp from POSIX `gettimeofday()`.
//
//     struct timeval tv;
//     gettimeofday(&tv, NULL);
//
//     Timestamp timestamp;
//     timestamp.set_seconds(tv.tv_sec);
//     timestamp.set_nanos(tv.tv_usec * 1000);
//
// Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
//
//     FILETIME ft;
//     GetSystemTimeAsFileTime(&ft);
//     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
//
//     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
//     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
//     Timestamp timestamp;
//     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
//     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
//
// Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
//
//     long millis = System.currentTimeMillis();
//
//     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
//         .setNanos((int) ((millis % 1000) * 1000000)).build();
//
//
// Example 5: Compute Timestamp from Java `Instant.now()`.
//
//     Instant now = Instant.now();
//
//     Timestamp timestamp =
//         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
//             .setNanos(now.getNano()).build();
//
//
// Example 6: Compute Timestamp from current time in Python.
//
//     timestamp = Timestamp()
//     timestamp.GetCurrentTime()
//
// # JSON Mapping
//
// In JSON format, the Timestamp type is encoded as a string in the
// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
// format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
// where {year} is always expressed using four digits while {month}, {day},
// {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
// seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
// are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
// is required. A proto3 JSON serializer should always use UTC (as indicated by
// "Z") when printing the Timestamp type and a proto3 JSON parser should be
// able to accept both UTC and other timezones (as indicated by an offset).
//
// For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
// 01:30 UTC on January 15, 2017.
//
// In JavaScript, one can convert a Date object to this format using the
// standard
// [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
// method. In Python, a standard `datetime.datetime` object can be converted
// to this format using
// [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
// the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
// the Joda Time's [`ISODateTimeFormat.dateTime()`](
// http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
// ) to obtain a formatter capable of generating timestamps in this format.
//
//
message Timestamp {
  // Represents seconds of UTC time since Unix epoch
  // 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  // 9999-12-31T23:59:59Z inclusive.
  int64 seconds = 1;

  // Non-negative fractions of a second at nanosecond resolution. Negative
  // second values with fractions must still have non-negative nanos values
  // that count forward in time. Must be from 0 to 999,999,999
  // inclusive.
  int32 nanos = 2;
}


==================================================
文件路径: target\protobuf_external\google\protobuf\type.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

import "google/protobuf/any.proto";
import "google/protobuf/source_context.proto";

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option cc_enable_arenas = true;
option java_package = "com.google.protobuf";
option java_outer_classname = "TypeProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";
option go_package = "google.golang.org/protobuf/types/known/typepb";

// A protocol buffer message type.
message Type {
  // The fully qualified message name.
  string name = 1;
  // The list of fields.
  repeated Field fields = 2;
  // The list of types appearing in `oneof` definitions in this type.
  repeated string oneofs = 3;
  // The protocol buffer options.
  repeated Option options = 4;
  // The source context.
  SourceContext source_context = 5;
  // The source syntax.
  Syntax syntax = 6;
}

// A single field of a message type.
message Field {
  // Basic field types.
  enum Kind {
    // Field type unknown.
    TYPE_UNKNOWN = 0;
    // Field type double.
    TYPE_DOUBLE = 1;
    // Field type float.
    TYPE_FLOAT = 2;
    // Field type int64.
    TYPE_INT64 = 3;
    // Field type uint64.
    TYPE_UINT64 = 4;
    // Field type int32.
    TYPE_INT32 = 5;
    // Field type fixed64.
    TYPE_FIXED64 = 6;
    // Field type fixed32.
    TYPE_FIXED32 = 7;
    // Field type bool.
    TYPE_BOOL = 8;
    // Field type string.
    TYPE_STRING = 9;
    // Field type group. Proto2 syntax only, and deprecated.
    TYPE_GROUP = 10;
    // Field type message.
    TYPE_MESSAGE = 11;
    // Field type bytes.
    TYPE_BYTES = 12;
    // Field type uint32.
    TYPE_UINT32 = 13;
    // Field type enum.
    TYPE_ENUM = 14;
    // Field type sfixed32.
    TYPE_SFIXED32 = 15;
    // Field type sfixed64.
    TYPE_SFIXED64 = 16;
    // Field type sint32.
    TYPE_SINT32 = 17;
    // Field type sint64.
    TYPE_SINT64 = 18;
  }

  // Whether a field is optional, required, or repeated.
  enum Cardinality {
    // For fields with unknown cardinality.
    CARDINALITY_UNKNOWN = 0;
    // For optional fields.
    CARDINALITY_OPTIONAL = 1;
    // For required fields. Proto2 syntax only.
    CARDINALITY_REQUIRED = 2;
    // For repeated fields.
    CARDINALITY_REPEATED = 3;
  }

  // The field type.
  Kind kind = 1;
  // The field cardinality.
  Cardinality cardinality = 2;
  // The field number.
  int32 number = 3;
  // The field name.
  string name = 4;
  // The field type URL, without the scheme, for message or enumeration
  // types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`.
  string type_url = 6;
  // The index of the field type in `Type.oneofs`, for message or enumeration
  // types. The first type has index 1; zero means the type is not in the list.
  int32 oneof_index = 7;
  // Whether to use alternative packed wire representation.
  bool packed = 8;
  // The protocol buffer options.
  repeated Option options = 9;
  // The field JSON name.
  string json_name = 10;
  // The string value of the default value of this field. Proto2 syntax only.
  string default_value = 11;
}

// Enum type definition.
message Enum {
  // Enum type name.
  string name = 1;
  // Enum value definitions.
  repeated EnumValue enumvalue = 2;
  // Protocol buffer options.
  repeated Option options = 3;
  // The source context.
  SourceContext source_context = 4;
  // The source syntax.
  Syntax syntax = 5;
}

// Enum value definition.
message EnumValue {
  // Enum value name.
  string name = 1;
  // Enum value number.
  int32 number = 2;
  // Protocol buffer options.
  repeated Option options = 3;
}

// A protocol buffer option, which can be attached to a message, field,
// enumeration, etc.
message Option {
  // The option's name. For protobuf built-in options (options defined in
  // descriptor.proto), this is the short name. For example, `"map_entry"`.
  // For custom options, it should be the fully-qualified name. For example,
  // `"google.api.http"`.
  string name = 1;
  // The option's value packed in an Any message. If the value is a primitive,
  // the corresponding wrapper type defined in google/protobuf/wrappers.proto
  // should be used. If the value is an enum, it should be stored as an int32
  // value using the google.protobuf.Int32Value type.
  Any value = 2;
}

// The syntax in which a protocol buffer element is defined.
enum Syntax {
  // Syntax `proto2`.
  SYNTAX_PROTO2 = 0;
  // Syntax `proto3`.
  SYNTAX_PROTO3 = 1;
}


==================================================
文件路径: target\protobuf_external\google\protobuf\wrappers.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Wrappers for primitive (non-message) types. These types are useful
// for embedding primitives in the `google.protobuf.Any` type and for places
// where we need to distinguish between the absence of a primitive
// typed field and its default value.
//
// These wrappers have no meaningful use within repeated fields as they lack
// the ability to detect presence on individual elements.
// These wrappers have no meaningful use within a map or a oneof since
// individual entries of a map or fields of a oneof can already detect presence.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option cc_enable_arenas = true;
option go_package = "google.golang.org/protobuf/types/known/wrapperspb";
option java_package = "com.google.protobuf";
option java_outer_classname = "WrappersProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";

// Wrapper message for `double`.
//
// The JSON representation for `DoubleValue` is JSON number.
message DoubleValue {
  // The double value.
  double value = 1;
}

// Wrapper message for `float`.
//
// The JSON representation for `FloatValue` is JSON number.
message FloatValue {
  // The float value.
  float value = 1;
}

// Wrapper message for `int64`.
//
// The JSON representation for `Int64Value` is JSON string.
message Int64Value {
  // The int64 value.
  int64 value = 1;
}

// Wrapper message for `uint64`.
//
// The JSON representation for `UInt64Value` is JSON string.
message UInt64Value {
  // The uint64 value.
  uint64 value = 1;
}

// Wrapper message for `int32`.
//
// The JSON representation for `Int32Value` is JSON number.
message Int32Value {
  // The int32 value.
  int32 value = 1;
}

// Wrapper message for `uint32`.
//
// The JSON representation for `UInt32Value` is JSON number.
message UInt32Value {
  // The uint32 value.
  uint32 value = 1;
}

// Wrapper message for `bool`.
//
// The JSON representation for `BoolValue` is JSON `true` and `false`.
message BoolValue {
  // The bool value.
  bool value = 1;
}

// Wrapper message for `string`.
//
// The JSON representation for `StringValue` is JSON string.
message StringValue {
  // The string value.
  string value = 1;
}

// Wrapper message for `bytes`.
//
// The JSON representation for `BytesValue` is JSON string.
message BytesValue {
  // The bytes value.
  bytes value = 1;
}


==================================================
文件路径: target\protobuf_external\google\protobuf\compiler\plugin.proto
==================================================

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//
// WARNING:  The plugin interface is currently EXPERIMENTAL and is subject to
//   change.
//
// protoc (aka the Protocol Compiler) can be extended via plugins.  A plugin is
// just a program that reads a CodeGeneratorRequest from stdin and writes a
// CodeGeneratorResponse to stdout.
//
// Plugins written using C++ can use google/protobuf/compiler/plugin.h instead
// of dealing with the raw protocol defined here.
//
// A plugin executable needs only to be placed somewhere in the path.  The
// plugin should be named "protoc-gen-$NAME", and will then be used when the
// flag "--${NAME}_out" is passed to protoc.

syntax = "proto2";

package google.protobuf.compiler;
option java_package = "com.google.protobuf.compiler";
option java_outer_classname = "PluginProtos";

option go_package = "google.golang.org/protobuf/types/pluginpb";

import "google/protobuf/descriptor.proto";

// The version number of protocol compiler.
message Version {
  optional int32 major = 1;
  optional int32 minor = 2;
  optional int32 patch = 3;
  // A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
  // be empty for mainline stable releases.
  optional string suffix = 4;
}

// An encoded CodeGeneratorRequest is written to the plugin's stdin.
message CodeGeneratorRequest {
  // The .proto files that were explicitly listed on the command-line.  The
  // code generator should generate code only for these files.  Each file's
  // descriptor will be included in proto_file, below.
  repeated string file_to_generate = 1;

  // The generator parameter passed on the command-line.
  optional string parameter = 2;

  // FileDescriptorProtos for all files in files_to_generate and everything
  // they import.  The files will appear in topological order, so each file
  // appears before any file that imports it.
  //
  // protoc guarantees that all proto_files will be written after
  // the fields above, even though this is not technically guaranteed by the
  // protobuf wire format.  This theoretically could allow a plugin to stream
  // in the FileDescriptorProtos and handle them one by one rather than read
  // the entire set into memory at once.  However, as of this writing, this
  // is not similarly optimized on protoc's end -- it will store all fields in
  // memory at once before sending them to the plugin.
  //
  // Type names of fields and extensions in the FileDescriptorProto are always
  // fully qualified.
  repeated FileDescriptorProto proto_file = 15;

  // The version number of protocol compiler.
  optional Version compiler_version = 3;

}

// The plugin writes an encoded CodeGeneratorResponse to stdout.
message CodeGeneratorResponse {
  // Error message.  If non-empty, code generation failed.  The plugin process
  // should exit with status code zero even if it reports an error in this way.
  //
  // This should be used to indicate errors in .proto files which prevent the
  // code generator from generating correct code.  Errors which indicate a
  // problem in protoc itself -- such as the input CodeGeneratorRequest being
  // unparseable -- should be reported by writing a message to stderr and
  // exiting with a non-zero status code.
  optional string error = 1;

  // A bitmask of supported features that the code generator supports.
  // This is a bitwise "or" of values from the Feature enum.
  optional uint64 supported_features = 2;

  // Sync with code_generator.h.
  enum Feature {
    FEATURE_NONE = 0;
    FEATURE_PROTO3_OPTIONAL = 1;
  }

  // Represents a single generated file.
  message File {
    // The file name, relative to the output directory.  The name must not
    // contain "." or ".." components and must be relative, not be absolute (so,
    // the file cannot lie outside the output directory).  "/" must be used as
    // the path separator, not "\".
    //
    // If the name is omitted, the content will be appended to the previous
    // file.  This allows the generator to break large files into small chunks,
    // and allows the generated text to be streamed back to protoc so that large
    // files need not reside completely in memory at one time.  Note that as of
    // this writing protoc does not optimize for this -- it will read the entire
    // CodeGeneratorResponse before writing files to disk.
    optional string name = 1;

    // If non-empty, indicates that the named file should already exist, and the
    // content here is to be inserted into that file at a defined insertion
    // point.  This feature allows a code generator to extend the output
    // produced by another code generator.  The original generator may provide
    // insertion points by placing special annotations in the file that look
    // like:
    //   @@protoc_insertion_point(NAME)
    // The annotation can have arbitrary text before and after it on the line,
    // which allows it to be placed in a comment.  NAME should be replaced with
    // an identifier naming the point -- this is what other generators will use
    // as the insertion_point.  Code inserted at this point will be placed
    // immediately above the line containing the insertion point (thus multiple
    // insertions to the same point will come out in the order they were added).
    // The double-@ is intended to make it unlikely that the generated code
    // could contain things that look like insertion points by accident.
    //
    // For example, the C++ code generator places the following line in the
    // .pb.h files that it generates:
    //   // @@protoc_insertion_point(namespace_scope)
    // This line appears within the scope of the file's package namespace, but
    // outside of any particular class.  Another plugin can then specify the
    // insertion_point "namespace_scope" to generate additional classes or
    // other declarations that should be placed in this scope.
    //
    // Note that if the line containing the insertion point begins with
    // whitespace, the same whitespace will be added to every line of the
    // inserted text.  This is useful for languages like Python, where
    // indentation matters.  In these languages, the insertion point comment
    // should be indented the same amount as any inserted code will need to be
    // in order to work correctly in that context.
    //
    // The code generator that generates the initial file and the one which
    // inserts into it must both run as part of a single invocation of protoc.
    // Code generators are executed in the order in which they appear on the
    // command line.
    //
    // If |insertion_point| is present, |name| must also be present.
    optional string insertion_point = 2;

    // The file contents.
    optional string content = 15;

    // Information describing the file content being inserted. If an insertion
    // point is used, this information will be appropriately offset and inserted
    // into the code generation metadata for the generated files.
    optional GeneratedCodeInfo generated_code_info = 16;
  }
  repeated File file = 15;
}


==================================================
文件路径: target\protobuf_external\scalapb\scalapb.proto
==================================================

syntax = "proto2";

package scalapb;

option go_package = "scalapb.github.io/protobuf/scalapb";
option java_package = "scalapb.options";

option (options) = {
  package_name: "scalapb.options"
  flat_package: true
};

import "google/protobuf/descriptor.proto";

message ScalaPbOptions {
  // If set then it overrides the java_package and package.
  optional string package_name = 1;

  // If true, the compiler does not append the proto base file name
  // into the generated package name. If false (the default), the
  // generated scala package name is the package_name.basename where
  // basename is the proto file name without the .proto extension.
  optional bool flat_package = 2;

  // Adds the following imports at the top of the file (this is meant
  // to provide implicit TypeMappers)
  repeated string import = 3;

  // Text to add to the generated scala file.  This can be used only
  // when single_file is true.
  repeated string preamble = 4;

  // If true, all messages and enums (but not services) will be written
  // to a single Scala file.
  optional bool single_file = 5;

  // By default, wrappers defined at
  // https://github.com/google/protobuf/blob/master/src/google/protobuf/wrappers.proto,
  // are mapped to an Option[T] where T is a primitive type. When this field
  // is set to true, we do not perform this transformation.
  optional bool no_primitive_wrappers = 7;

  // DEPRECATED. In ScalaPB <= 0.5.47, it was necessary to explicitly enable
  // primitive_wrappers. This field remains here for backwards compatibility,
  // but it has no effect on generated code. It is an error to set both
  // `primitive_wrappers` and `no_primitive_wrappers`.
  optional bool primitive_wrappers = 6;

  // Scala type to be used for repeated fields. If unspecified,
  // `scala.collection.Seq` will be used.
  optional string collection_type = 8;

  // If set to true, all generated messages in this file will preserve unknown
  // fields.
  optional bool preserve_unknown_fields = 9 [default=true];

  // If defined, sets the name of the file-level object that would be generated. This
  // object extends `GeneratedFileObject` and contains descriptors, and list of message
  // and enum companions.
  optional string object_name = 10;

  // Whether to apply the options only to this file, or for the entire package (and its subpackages)
  enum OptionsScope {
    // Apply the options for this file only (default)
    FILE = 0;

    // Apply the options for the entire package and its subpackages.
    PACKAGE = 1;
  }
  // Experimental: scope to apply the given options.
  optional OptionsScope scope = 11;

  // If true, lenses will be generated.
  optional bool lenses = 12 [default=true];

  // If true, then source-code info information will be included in the
  // generated code - normally the source code info is cleared out to reduce
  // code size.  The source code info is useful for extracting source code
  // location from the descriptors as well as comments.
  optional bool retain_source_code_info = 13;

  // Scala type to be used for maps. If unspecified,
  // `scala.collection.immutable.Map` will be used.
  optional string map_type = 14;

  // If true, no default values will be generated in message constructors.
  // This setting can be overridden at the message-level and for individual
  // fields.
  optional bool no_default_values_in_constructor = 15;

  /* Naming convention for generated enum values */
  enum EnumValueNaming {
    AS_IN_PROTO = 0;  // Enum value names in Scala use the same name as in the proto
    CAMEL_CASE = 1;   // Convert enum values to CamelCase in Scala.
  }
  optional EnumValueNaming enum_value_naming = 16;

  // Indicate if prefix (enum name + optional underscore) should be removed in scala code
  // Strip is applied before enum value naming changes.
  optional bool enum_strip_prefix = 17 [default=false];

  // Scala type to use for bytes fields.
  optional string bytes_type = 21;

  // Enable java conversions for this file.
  optional bool java_conversions = 23;

  // AuxMessageOptions enables you to set message-level options through package-scoped options.
  // This is useful when you can't add a dependency on scalapb.proto from the proto file that
  // defines the message.
  message AuxMessageOptions {
    // The fully-qualified name of the message in the proto name space. Set to `*` to apply to all
    // messages in scope.
    optional string target = 1;

    // Options to apply to the message. If there are any options defined on the target message
    // they take precedence over the options.
    optional MessageOptions options = 2;
  }

  // AuxFieldOptions enables you to set field-level options through package-scoped options.
  // This is useful when you can't add a dependency on scalapb.proto from the proto file that
  // defines the field.
  message AuxFieldOptions {
    // The fully-qualified name of the field in the proto name space. Set to `*` to apply to all
    // fields in scope.
    optional string target = 1;

    // Options to apply to the field. If there are any options defined on the target message
    // they take precedence over the options.
    optional FieldOptions options = 2;
  }

  // AuxEnumOptions enables you to set enum-level options through package-scoped options.
  // This is useful when you can't add a dependency on scalapb.proto from the proto file that
  // defines the enum.
  message AuxEnumOptions {
    // The fully-qualified name of the enum in the proto name space. Set to `*` to apply to
    // all enums in scope.
    optional string target = 1;

    // Options to apply to the enum. If there are any options defined on the target enum
    // they take precedence over the options.
    optional EnumOptions options = 2;
  }

  // AuxEnumValueOptions enables you to set enum value level options through package-scoped
  // options.  This is useful when you can't add a dependency on scalapb.proto from the proto
  // file that defines the enum.
  message AuxEnumValueOptions {
    // The fully-qualified name of the enum value in the proto name space. Set to `*` to apply
    // to all enum values in scope.
    optional string target = 1;

    // Options to apply to the enum value. If there are any options defined on
    // the target enum value they take precedence over the options.
    optional EnumValueOptions options = 2;
  }

  // List of message options to apply to some messages.
  repeated AuxMessageOptions aux_message_options = 18;

  // List of message options to apply to some fields.
  repeated AuxFieldOptions aux_field_options = 19;

  // List of message options to apply to some enums.
  repeated AuxEnumOptions aux_enum_options = 20;

  // List of enum value options to apply to some enum values.
  repeated AuxEnumValueOptions aux_enum_value_options = 22;

  // List of preprocessors to apply.
  repeated string preprocessors = 24;

  repeated FieldTransformation field_transformations = 25;

  // Ignores all transformations for this file. This is meant to allow specific files to
  // opt out from transformations inherited through package-scoped options.
  optional bool ignore_all_transformations = 26;

  // If true, getters will be generated.
  optional bool getters = 27 [default=true];

  // Generate sources that are compatible with Scala 3
  optional bool scala3_sources = 28;

  // For use in tests only. Inhibit Java conversions even when when generator parameters
  // request for it.
  optional bool test_only_no_java_conversions = 999;

  extensions 1000 to max;
}

extend google.protobuf.FileOptions {
  // File-level optionals for ScalaPB.
  // Extension number officially assigned by protobuf-global-extension-registry@google.com
  optional ScalaPbOptions options = 1020;
}

message MessageOptions {
  // Additional classes and traits to mix in to the case class.
  repeated string extends = 1;

  // Additional classes and traits to mix in to the companion object.
  repeated string companion_extends = 2;

  // Custom annotations to add to the generated case class.
  repeated string annotations = 3;

  // All instances of this message will be converted to this type. An implicit TypeMapper
  // must be present.
  optional string type = 4;

  // Custom annotations to add to the companion object of the generated class.
  repeated string companion_annotations = 5;

  // Additional classes and traits to mix in to generated sealed_oneof base trait.
  repeated string sealed_oneof_extends = 6;

  // If true, when this message is used as an optional field, do not wrap it in an `Option`.
  // This is equivalent of setting `(field).no_box` to true on each field with the message type.
  optional bool no_box = 7;

  // Custom annotations to add to the generated `unknownFields` case class field.
  repeated string unknown_fields_annotations = 8;

  // If true, no default values will be generated in message constructors.
  // If set (to true or false), the message-level setting overrides the
  // file-level value, and can be overridden by the field-level setting.
  optional bool no_default_values_in_constructor = 9;

  // Additional classes and traits to mix in to generated sealed oneof base trait's companion object.
  repeated string sealed_oneof_companion_extends = 10;

  // Adds a derives clause to the message case class
  repeated string derives = 11;

  // Additional classes and traits to add to the derives clause of a sealed oneof.
  repeated string sealed_oneof_derives = 12;

  extensions 1000 to max;
}

extend google.protobuf.MessageOptions {
  // Message-level optionals for ScalaPB.
  // Extension number officially assigned by protobuf-global-extension-registry@google.com
  optional MessageOptions message = 1020;
}

// Represents a custom Collection type in Scala. This allows ScalaPB to integrate with
// collection types that are different enough from the ones in the standard library.
message Collection {
  // Type of the collection
  optional string type = 1;

  // Set to true if this collection type is not allowed to be empty, for example
  // cats.data.NonEmptyList.  When true, ScalaPB will not generate `clearX` for the repeated
  // field and not provide a default argument in the constructor.
  optional bool non_empty = 2;

  // An Adapter is a Scala object available at runtime that provides certain static methods
  // that can operate on this collection type.
  optional string adapter = 3;
}

message FieldOptions {
  optional string type = 1;

  optional string scala_name = 2;

  // Can be specified only if this field is repeated. If unspecified,
  // it falls back to the file option named `collection_type`, which defaults
  // to `scala.collection.Seq`.
  optional string collection_type = 3;

  optional Collection collection = 8;

  // If the field is a map, you can specify custom Scala types for the key
  // or value.
  optional string key_type = 4;
  optional string value_type = 5;

  // Custom annotations to add to the field.
  repeated string annotations = 6;

  // Can be specified only if this field is a map. If unspecified,
  // it falls back to the file option named `map_type` which defaults to
  // `scala.collection.immutable.Map`
  optional string map_type = 7;

  // If true, no default value will be generated for this field in the message
  // constructor. If this field is set, it has the highest precedence and overrides the
  // values at the message-level and file-level.
  optional bool no_default_value_in_constructor = 9;

  // Do not box this value in Option[T]. If set, this overrides MessageOptions.no_box
  optional bool no_box = 30;

  // Like no_box it does not box a value in Option[T], but also fails parsing when a value
  // is not provided. This enables to emulate required fields in proto3.
  optional bool required = 31;

  extensions 1000 to max;
}

extend google.protobuf.FieldOptions {
  // Field-level optionals for ScalaPB.
  // Extension number officially assigned by protobuf-global-extension-registry@google.com
  optional FieldOptions field = 1020;
}

message EnumOptions {
  // Additional classes and traits to mix in to the base trait
  repeated string extends = 1;

  // Additional classes and traits to mix in to the companion object.
  repeated string companion_extends = 2;

  // All instances of this enum will be converted to this type. An implicit TypeMapper
  // must be present.
  optional string type = 3;

  // Custom annotations to add to the generated enum's base class.
  repeated string base_annotations = 4;

  // Custom annotations to add to the generated trait.
  repeated string recognized_annotations = 5;

  // Custom annotations to add to the generated Unrecognized case class.
  repeated string unrecognized_annotations = 6;

  extensions 1000 to max;
}

extend google.protobuf.EnumOptions {
  // Enum-level optionals for ScalaPB.
  // Extension number officially assigned by protobuf-global-extension-registry@google.com
  //
  // The field is called enum_options and not enum since enum is not allowed in Java.
  optional EnumOptions enum_options = 1020;
}

message EnumValueOptions {
  // Additional classes and traits to mix in to an individual enum value.
  repeated string extends = 1;

  // Name in Scala to use for this enum value.
  optional string scala_name = 2;

  // Custom annotations to add to the generated case object for this enum value.
  repeated string annotations = 3;

  extensions 1000 to max;
}

extend google.protobuf.EnumValueOptions {
  // Enum-level optionals for ScalaPB.
  // Extension number officially assigned by protobuf-global-extension-registry@google.com
  optional EnumValueOptions enum_value = 1020;
}

message OneofOptions {
  // Additional traits to mix in to a oneof.
  repeated string extends = 1;

  // Name in Scala to use for this oneof field.
  optional string scala_name = 2;

  extensions 1000 to max;
}

extend google.protobuf.OneofOptions {
  // Enum-level optionals for ScalaPB.
  // Extension number officially assigned by protobuf-global-extension-registry@google.com
  optional OneofOptions oneof = 1020;
}

enum MatchType {
  CONTAINS = 0;
  EXACT = 1;
  PRESENCE = 2;
}

message FieldTransformation {
  optional google.protobuf.FieldDescriptorProto when = 1;
  optional MatchType match_type = 2 [default=CONTAINS];
  optional google.protobuf.FieldOptions set = 3;
}

message PreprocessorOutput {
  map<string, ScalaPbOptions> options_by_file = 1;
}


==================================================
文件路径: target\scala-2.13\classes\application.conf
==================================================

# https://www.playframework.com/documentation/latest/Configuration
include "projection.conf"
include "persistence.conf"
include "serialization.conf"
include "cluster.conf"

akka {
  loglevel = DEBUG
}

play.modules.enabled += "scalikejdbc.PlayModule"
# scalikejdbc.PlayModule doesn't depend on Play's DBModule
play.modules.disabled += "play.api.db.DBModule"
play.filters.enabled=[controllers.filter.LoggingFilter]
play.server.websocket.periodic-keep-alive-max-idle = 10 seconds

play.temporaryFile {
  reaper {
    enabled = true
    initialDelay = "5 minutes"
    interval = "30 seconds"
    olderThan = "30 minutes"
  }
}



==================================================
文件路径: target\scala-2.13\classes\cluster.conf
==================================================

akka {

   actor {
     provider = cluster
   }

   min-nr-of-member = 1

   remote.artery {
       canonical {
         hostname = ${clustering.ip}
         port = ${clustering.port}
       }
       bind {
         hostname = ${clustering.ip}
         port = ${clustering.port}
       }
     }
   cluster {
     seed-nodes = ["akka://application@"${clustering.seed-ip}":"${clustering.seed-port}]
     downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
     shutdown-after-unsuccessful-join-seed-nodes = 120s

     sharding {
       least-shard-allocation-strategy.rebalance-absolute-limit = 20
       passivation {
         strategy = custom-lru-strategy
         custom-lru-strategy {
           active-entity-limit = 1000000
           replacement.policy = least-recently-used
         }
       }
     }
   }
}

clustering {
 ip = "127.0.0.1"
 ip = ${?CLUSTER_IP}
 port = 2551
 port = ${?CLUSTER_PORT}
 seed-ip = "127.0.0.1"
 seed-ip = ${?SEED_IP}
 seed-ip = ${?SEED_PORT_1600_TCP_ADDR}
 seed-port = 2551
 seed-port = ${?SEED_PORT_1600_TCP_PORT}
 cluster.name = application
}

==================================================
文件路径: target\scala-2.13\classes\credits.proto
==================================================

syntax = "proto3";

package net.imadz.infrastructure.proto;

// Define the Money type
message MoneyPO {
  double amount = 1;
  string currency = 2;
}

// Define the BalanceChanged event
message BalanceChanged {
  MoneyPO update = 1;
  int64 timestamp = 2;
}

// Define the FundsReserved event
message FundsReserved {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the FundsDeducted event
message FundsDeducted {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the ReservationReleased event
message ReservationReleased {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the IncomingCreditsRecorded event
message IncomingCreditsRecorded {
  string transferId = 1;
  MoneyPO amount = 2;
}

// Define the IncomingCreditsCommited event
message IncomingCreditsCommited {
  string transferId = 1;
}

// Define the IncomingCreditsCanceled event
message IncomingCreditsCanceled {
  string transferId = 1;
}

// Define the CreditBalanceEvent union
message CreditBalanceEventPO {
  oneof event {
    BalanceChanged balanceChanged = 1;
    FundsReserved fundsReserved = 2;
    FundsDeducted fundsDeducted = 3;
    ReservationReleased reservationReleased = 4;
    IncomingCreditsRecorded incomingCreditsRecorded = 5;
    IncomingCreditsCommited incomingCreditsCommited = 6;
    IncomingCreditsCanceled incomingCreditsCanceled = 7;
  }
}

// Define the CreditBalanceState snapshot
message CreditBalanceStatePO {
  string userId = 1; // UUID can be represented as a string
  map<string, MoneyPO> accountBalance = 2;
  map<string, MoneyPO> reservedAmount = 3;
  map<string, MoneyPO> incomingCredits = 4;
}

==================================================
文件路径: target\scala-2.13\classes\persistence.conf
==================================================

akka {
  persistence {
    journal.plugin = "akka-contrib-mongodb-persistence-journal"
	snapshot-store.plugin = "akka-contrib-mongodb-persistence-snapshot"
  }
  contrib.persistence.mongodb.mongo.mongouri = "mongodb://127.0.0.1:27017/cqrs-demo-journal?maxPoolSize=20&w=majority&authSource=admin"
  contrib.persistence.mongodb.mongo.suffix-builder.separator = "_"
  contrib.persistence.mongodb.mongo.suffix-builder.class = "net.imadz.infrastructure.SuffixCollectionNames"
}

==================================================
文件路径: target\scala-2.13\classes\projection.conf
==================================================

akka {

   projection {
     jdbc.blocking-jdbc-dispatcher.thread-pool-executor.fixed-pool-size = 10
     jdbc.dialect = mysql-dialect
   }

}

jdbc-connection-settings {
  driver = "com.mysql.jdbc.Driver"
  url = "jdbc:mysql://127.0.0.1:3308/cqrs_jdbc_demo?allowPublicKeyRetrieval=true&noAccessToProcedureBodies=true&createDatabaseIfNotExist=true&m=yes&characterEncoding=UTF-8&connectTimeout=300000&useSSL=false&serverTimezone=UTC&socketTimeout=30000&autoReconnect=true&maxReconnects=10&initialTimeout=10"
  user = "root"
  password = "1q2w3e4r5t"

    # the following properties are used to configure the
    # Hikari connection pool used on the read-side (akka-projections)
    connection-pool {
      # How many connections should be available to from the pool?
      # it's recommended to use the same value used by the blocking-jdbc-dispatcher (see above)
      max-pool-size = ${akka.projection.jdbc.blocking-jdbc-dispatcher.thread-pool-executor.fixed-pool-size}

      # How long should we wait (in millis) before it times out?
      # In a normal scenario, we should always be able to get a connection
      # If we got a thread from the blocking-jdbc-dispatcher, we should be able to get a connection.
      # If for some reason the pool can't provide a connection, it's better to let it crash and liberate the current thread.
      # Hence the low timout (note, 250 is lowest value hikari accepts)
      timeout = 250ms
    }
}

scalikejdbc.global {
  loggingSQLAndTime.enabled=false
  loggingSQLAndTime.singleLineMode=false
  loggingSQLAndTime.logLevel=debug
  loggingSQLAndTime.warningEnabled=true
  loggingSQLAndTime.warningThresholdMillis=5
  loggingSQLAndTime.warningLogLevel=warn
}

==================================================
文件路径: target\scala-2.13\classes\saga_participant.proto
==================================================

syntax = "proto3";
import "credits.proto";

package net.imadz.infrastructure.proto;

// Represents a participant that handles the from account in a transaction
message FromAccountParticipantPO {
  string from_user_id = 1;
  net.imadz.infrastructure.proto.MoneyPO amount = 2;
}

message ToAccountParticipantPO {
  string to_user_id = 1;
  net.imadz.infrastructure.proto.MoneyPO amount = 2;
}

==================================================
文件路径: target\scala-2.13\classes\saga_v2.proto
==================================================

syntax = "proto3";

package net.imadz.infra.saga;

option java_multiple_files = true;
option java_package = "net.imadz.infra.saga.proto";

// Enums
enum TransactionPhasePO {
  PREPARE_PHASE = 0;
  COMMIT_PHASE = 1;
  COMPENSATE_PHASE = 2;
}

enum StepStatusPO {
  CREATED = 0;
  ONGOING = 1;
  SUCCEED = 2;
  FAILED = 3;
}


// [关键修改]：通用的参与者容器
message SagaParticipantPO {
  // 业务参与者的全限定类名，例如 "net.imadz.infra.proto.FromAccountParticipantPO"
  // 或者对应的 Scala 类名，取决于你序列化策略的映射方式
  string type_name = 1;

  // 业务参与者序列化后的二进制数据
  bytes payload = 2;
}

// Messages
message SagaTransactionStepPO {
  string step_id = 1;
  TransactionPhasePO phase = 2;
  int32 max_retries = 3;
  int64 timeout_duration_millis = 4;
  bool retry_when_recovered_ongoing = 5;
  SagaParticipantPO participant = 6;
  string participant_type = 7;// This will be used to identify the participant implementation
}

message StepStatePO {
  SagaTransactionStepPO step = 1;
  string transaction_id = 2;
  StepStatusPO status = 3;
  int32 retries = 4;
  RetryableOrNotExceptionPO last_error = 5;
  bool circuit_breaker_open = 6;
  string replyToPath = 7;
}

message RetryableOrNotExceptionPO {
  bool is_retryable = 1;
  string message = 2;
}

// Events
message ExecutionStartedPO {
  string transaction_id = 1;
  SagaTransactionStepPO transaction_step = 2;
  string replyToPath = 3;
}

message OperationSucceededPO {
  string resultType = 1;
  bytes result = 2; // Use bytes to store serialized result
}

message OperationFailedPO {
  RetryableOrNotExceptionPO error = 1;
}

message RetryScheduledPO {
  int32 retry_count = 1;
}

message StepExecutorEventPO {
  oneof event {
    ExecutionStartedPO started = 1;
    OperationSucceededPO succeed = 2;
    OperationFailedPO failed = 3;
    RetryScheduledPO rescheduled = 4;
  }
}

// Commands
message StartCommandPO {
  string transaction_id = 1;
  SagaTransactionStepPO saga_step = 2;
  string replyToPath = 3;
}

message RecoverExecutionCommandPO {
  string transaction_id = 1;
  SagaTransactionStepPO saga_step = 2;
}

message OperationSucceedCommandPO {
    string successMessageType = 1;
    bytes success = 2;
}

message OperationFailedCommandPO {
   RetryableOrNotExceptionPO error = 1;
}

message OperationResponseCommandPO {
  oneof result {
    OperationSucceedCommandPO succeed = 1;
    OperationFailedCommandPO error = 2;
  }
}

message RetryOperationCommandPO {}

message TimedOutCommandPO {}

// Coordinator's Proto

enum CoordinatorStatusPO {
  TRANSACTION_CREATED = 0;
  TRANSACTION_IN_PROGRESS = 1;
  TRANSACTION_COMPLETED = 2;
  TRANSACTION_FAILED = 3;
}

// Commands
message StartTransactionPO {
  string transaction_id = 1;
  repeated SagaTransactionStepPO steps = 2;
}

message PhaseCompletedPO {
  TransactionPhasePO phase = 1;
  repeated PhaseResultPO results = 2;
}

message PhaseFailurePO {
  TransactionPhasePO phase = 1;
  string error_message = 2;
  bool is_retryable = 3;
}

message PhaseResultPO {
  oneof result {
    string error = 1;
    bytes success = 2;
  }
}

// Events
message TransactionStartedPO {
  string transaction_id = 1;
  repeated SagaTransactionStepPO steps = 2;
}

message PhaseSucceededPO {
  TransactionPhasePO phase = 1;
}

message PhaseFailedPO {
  TransactionPhasePO phase = 1;
}

message TransactionCompletedPO {
  string transaction_id = 1;
}

message TransactionFailedPO {
  string transaction_id = 1;
  string reason = 2;
}

message SagaTransactionCoordinatorEventPO {
  oneof event {
    TransactionStartedPO started = 1;
    PhaseSucceededPO phaseSucceeded = 2;
    PhaseFailedPO phaseFailed = 3;
    TransactionCompletedPO transactionCompleted = 4;
    TransactionFailedPO transactionFailed = 5;
  }
}

// State
message CoordinatorStatePO {
  string transaction_id = 1;
  repeated SagaTransactionStepPO steps = 2;
  TransactionPhasePO current_phase = 3;
  CoordinatorStatusPO status = 4;
}

==================================================
文件路径: target\scala-2.13\classes\saga_v2_test.proto
==================================================

syntax = "proto3";

package net.imadz.infra.saga;

option java_multiple_files = true;
option java_package = "net.imadz.infra.saga.proto";

// Participant definitions for testing
message SuccessfulParticipant {}

message RetryingParticipant {
  int32 succeed_after = 1;
}

message TimeoutParticipant {}

message AlwaysFailingParticipant {}

message NonRetryableFailingParticipant {}



==================================================
文件路径: target\scala-2.13\classes\serialization.conf
==================================================

akka {
   actor {
     serializers {
        jackson-json = "akka.serialization.jackson.JacksonJsonSerializer"
        jackson-cbor = "akka.serialization.jackson.JacksonCborSerializer"
        object-id-offset = "net.imadz.common.serialization.ObjectIdOffsetSerializer"
        proto = "akka.remote.serialization.ProtobufSerializer"
        saga-serializer = "net.imadz.infra.saga.serialization.SagaSerializer"
     }
     serialization-bindings {
       "akka.contrib.persistence.mongodb.ObjectIdOffset" = object-id-offset
       "com.google.protobuf.Message" = proto
       "scalapb.GeneratedMessage" = proto
       "net.imadz.common.CborSerializable" = jackson-cbor
       "net.imadz.infra.saga.StepExecutor$OperationResponse" =  saga-serializer
       "net.imadz.infra.saga.StepExecutor$OperationSucceeded" =  saga-serializer
     }
     allow-java-serialization = on
     warn-about-java-serializer-usage = off
   }

}

==================================================
文件路径: target\scala-2.13\classes\transactions.proto
==================================================

syntax = "proto3";
import "credits.proto";

package net.imadz.infrastructure.proto;

// Define the Id type
message string {
  string value = 1;
}

// Define the Money type


// Define the TransactionStatus enum
enum TransactionStatusPO {
  UNKNOWN = 0;
  NEW = 1;
  INITIATED = 2;
  PREPARED = 3;
  COMPLETED = 4;
  FAILED = 5;
}

// Define the Failed status message
message FailedStatusPO {
  string reason = 1;
}

// Define the TransactionStatus union
message TransactionStatusMessagePO {
  TransactionStatusPO status = 1;
  oneof details {
    FailedStatusPO failed = 2;
  }
}

// Define the TransactionState message
message TransactionStatePO {
  string id = 1;
  string fromUserId = 2;
  string toUserId = 3;
  MoneyPO amount = 4;
  TransactionStatusMessagePO status = 5;
}

// Define the TransactionEvent union
message TransactionEventPO {
  oneof event {
    TransactionInitiatedPO initiated = 1;
    TransactionPreparedPO prepared = 2;
    TransactionCompletedPO completed = 3;
    TransactionFailedPO failed = 4;
  }
}

// Define the TransactionInitiated event
message TransactionInitiatedPO {
  string fromUserId = 1;
  string toUserId = 2;
  MoneyPO amount = 3;
}

// Define the TransactionPrepared event
message TransactionPreparedPO {
  string id = 1;
}

// Define the TransactionCompleted event
message TransactionCompletedPO {
  string id = 1;
}

// Define the TransactionFailed event
message TransactionFailedPO {
  string id = 1;
  string reason = 2;
}

==================================================
文件路径: target\scala-2.13\routes\main\controllers\ReverseRoutes.scala
==================================================

// @GENERATOR:play-routes-compiler
// @SOURCE:conf/routes

import play.api.mvc.Call


import _root_.controllers.Assets.Asset

// @LINE:7
package controllers {

  // @LINE:7
  class ReverseHomeController(_prefix: => String) {
    def _defaultPrefix: String = {
      if (_prefix.endsWith("/")) "" else "/"
    }

  
    // @LINE:14
    def transfer(fromUserId:String, toUserId:String, amount:Double): Call = {
      
      Call("POST", _prefix + { _defaultPrefix } + "transfer/" + play.core.routing.dynamicString(implicitly[play.api.mvc.PathBindable[String]].unbind("fromUserId", fromUserId)) + "/" + play.core.routing.dynamicString(implicitly[play.api.mvc.PathBindable[String]].unbind("toUserId", toUserId)) + "/" + play.core.routing.dynamicString(implicitly[play.api.mvc.PathBindable[Double]].unbind("amount", amount)))
    }
  
    // @LINE:12
    def deposit(userId:String, amount:Double): Call = {
      
      Call("POST", _prefix + { _defaultPrefix } + "deposit/" + play.core.routing.dynamicString(implicitly[play.api.mvc.PathBindable[String]].unbind("userId", userId)) + "/" + play.core.routing.dynamicString(implicitly[play.api.mvc.PathBindable[Double]].unbind("amount", amount)))
    }
  
    // @LINE:13
    def withdraw(userId:String, amount:Double): Call = {
      
      Call("POST", _prefix + { _defaultPrefix } + "withdraw/" + play.core.routing.dynamicString(implicitly[play.api.mvc.PathBindable[String]].unbind("userId", userId)) + "/" + play.core.routing.dynamicString(implicitly[play.api.mvc.PathBindable[Double]].unbind("amount", amount)))
    }
  
    // @LINE:11
    def getBalance(userId:String): Call = {
      
      Call("GET", _prefix + { _defaultPrefix } + "balance/" + play.core.routing.dynamicString(implicitly[play.api.mvc.PathBindable[String]].unbind("userId", userId)))
    }
  
    // @LINE:7
    def index(): Call = {
      
      Call("GET", _prefix)
    }
  
  }

  // @LINE:10
  class ReverseAssets(_prefix: => String) {
    def _defaultPrefix: String = {
      if (_prefix.endsWith("/")) "" else "/"
    }

  
    // @LINE:10
    def versioned(file:Asset): Call = {
      implicit lazy val _rrc = new play.core.routing.ReverseRouteContext(Map(("path", "/public"))); _rrc
      Call("GET", _prefix + { _defaultPrefix } + "assets/" + implicitly[play.api.mvc.PathBindable[Asset]].unbind("file", file))
    }
  
  }


}


==================================================
文件路径: target\scala-2.13\routes\main\controllers\routes.java
==================================================

// @GENERATOR:play-routes-compiler
// @SOURCE:conf/routes

package controllers;

import router.RoutesPrefix;

public class routes {
  
  public static final controllers.ReverseHomeController HomeController = new controllers.ReverseHomeController(RoutesPrefix.byNamePrefix());
  public static final controllers.ReverseAssets Assets = new controllers.ReverseAssets(RoutesPrefix.byNamePrefix());

  public static class javascript {
    
    public static final controllers.javascript.ReverseHomeController HomeController = new controllers.javascript.ReverseHomeController(RoutesPrefix.byNamePrefix());
    public static final controllers.javascript.ReverseAssets Assets = new controllers.javascript.ReverseAssets(RoutesPrefix.byNamePrefix());
  }

}


==================================================
文件路径: target\scala-2.13\routes\main\controllers\javascript\JavaScriptReverseRoutes.scala
==================================================

// @GENERATOR:play-routes-compiler
// @SOURCE:conf/routes

import play.api.routing.JavaScriptReverseRoute


import _root_.controllers.Assets.Asset

// @LINE:7
package controllers.javascript {

  // @LINE:7
  class ReverseHomeController(_prefix: => String) {

    def _defaultPrefix: String = {
      if (_prefix.endsWith("/")) "" else "/"
    }

  
    // @LINE:14
    def transfer: JavaScriptReverseRoute = JavaScriptReverseRoute(
      "controllers.HomeController.transfer",
      """
        function(fromUserId0,toUserId1,amount2) {
          return _wA({method:"POST", url:"""" + _prefix + { _defaultPrefix } + """" + "transfer/" + encodeURIComponent((""" + implicitly[play.api.mvc.PathBindable[String]].javascriptUnbind + """)("fromUserId", fromUserId0)) + "/" + encodeURIComponent((""" + implicitly[play.api.mvc.PathBindable[String]].javascriptUnbind + """)("toUserId", toUserId1)) + "/" + encodeURIComponent((""" + implicitly[play.api.mvc.PathBindable[Double]].javascriptUnbind + """)("amount", amount2))})
        }
      """
    )
  
    // @LINE:12
    def deposit: JavaScriptReverseRoute = JavaScriptReverseRoute(
      "controllers.HomeController.deposit",
      """
        function(userId0,amount1) {
          return _wA({method:"POST", url:"""" + _prefix + { _defaultPrefix } + """" + "deposit/" + encodeURIComponent((""" + implicitly[play.api.mvc.PathBindable[String]].javascriptUnbind + """)("userId", userId0)) + "/" + encodeURIComponent((""" + implicitly[play.api.mvc.PathBindable[Double]].javascriptUnbind + """)("amount", amount1))})
        }
      """
    )
  
    // @LINE:13
    def withdraw: JavaScriptReverseRoute = JavaScriptReverseRoute(
      "controllers.HomeController.withdraw",
      """
        function(userId0,amount1) {
          return _wA({method:"POST", url:"""" + _prefix + { _defaultPrefix } + """" + "withdraw/" + encodeURIComponent((""" + implicitly[play.api.mvc.PathBindable[String]].javascriptUnbind + """)("userId", userId0)) + "/" + encodeURIComponent((""" + implicitly[play.api.mvc.PathBindable[Double]].javascriptUnbind + """)("amount", amount1))})
        }
      """
    )
  
    // @LINE:11
    def getBalance: JavaScriptReverseRoute = JavaScriptReverseRoute(
      "controllers.HomeController.getBalance",
      """
        function(userId0) {
          return _wA({method:"GET", url:"""" + _prefix + { _defaultPrefix } + """" + "balance/" + encodeURIComponent((""" + implicitly[play.api.mvc.PathBindable[String]].javascriptUnbind + """)("userId", userId0))})
        }
      """
    )
  
    // @LINE:7
    def index: JavaScriptReverseRoute = JavaScriptReverseRoute(
      "controllers.HomeController.index",
      """
        function() {
          return _wA({method:"GET", url:"""" + _prefix + """"})
        }
      """
    )
  
  }

  // @LINE:10
  class ReverseAssets(_prefix: => String) {

    def _defaultPrefix: String = {
      if (_prefix.endsWith("/")) "" else "/"
    }

  
    // @LINE:10
    def versioned: JavaScriptReverseRoute = JavaScriptReverseRoute(
      "controllers.Assets.versioned",
      """
        function(file1) {
          return _wA({method:"GET", url:"""" + _prefix + { _defaultPrefix } + """" + "assets/" + (""" + implicitly[play.api.mvc.PathBindable[Asset]].javascriptUnbind + """)("file", file1)})
        }
      """
    )
  
  }


}


==================================================
文件路径: target\scala-2.13\routes\main\router\Routes.scala
==================================================

// @GENERATOR:play-routes-compiler
// @SOURCE:conf/routes

package router

import play.core.routing._
import play.core.routing.HandlerInvokerFactory._

import play.api.mvc._

import _root_.controllers.Assets.Asset

class Routes(
  override val errorHandler: play.api.http.HttpErrorHandler, 
  // @LINE:7
  HomeController_1: controllers.HomeController,
  // @LINE:10
  Assets_0: controllers.Assets,
  val prefix: String
) extends GeneratedRouter {

   @javax.inject.Inject()
   def this(errorHandler: play.api.http.HttpErrorHandler,
    // @LINE:7
    HomeController_1: controllers.HomeController,
    // @LINE:10
    Assets_0: controllers.Assets
  ) = this(errorHandler, HomeController_1, Assets_0, "/")

  def withPrefix(addPrefix: String): Routes = {
    val prefix = play.api.routing.Router.concatPrefix(addPrefix, this.prefix)
    router.RoutesPrefix.setPrefix(prefix)
    new Routes(errorHandler, HomeController_1, Assets_0, prefix)
  }

  private[this] val defaultPrefix: String = {
    if (this.prefix.endsWith("/")) "" else "/"
  }

  def documentation = List(
    ("""GET""", this.prefix, """controllers.HomeController.index()"""),
    ("""GET""", this.prefix + (if(this.prefix.endsWith("/")) "" else "/") + """assets/""" + "$" + """file<.+>""", """controllers.Assets.versioned(path:String = "/public", file:Asset)"""),
    ("""GET""", this.prefix + (if(this.prefix.endsWith("/")) "" else "/") + """balance/""" + "$" + """userId<[^/]+>""", """controllers.HomeController.getBalance(userId:String)"""),
    ("""POST""", this.prefix + (if(this.prefix.endsWith("/")) "" else "/") + """deposit/""" + "$" + """userId<[^/]+>/""" + "$" + """amount<[^/]+>""", """controllers.HomeController.deposit(userId:String, amount:Double)"""),
    ("""POST""", this.prefix + (if(this.prefix.endsWith("/")) "" else "/") + """withdraw/""" + "$" + """userId<[^/]+>/""" + "$" + """amount<[^/]+>""", """controllers.HomeController.withdraw(userId:String, amount:Double)"""),
    ("""POST""", this.prefix + (if(this.prefix.endsWith("/")) "" else "/") + """transfer/""" + "$" + """fromUserId<[^/]+>/""" + "$" + """toUserId<[^/]+>/""" + "$" + """amount<[^/]+>""", """controllers.HomeController.transfer(fromUserId:String, toUserId:String, amount:Double)"""),
    Nil
  ).foldLeft(List.empty[(String,String,String)]) { (s,e) => e.asInstanceOf[Any] match {
    case r @ (_,_,_) => s :+ r.asInstanceOf[(String,String,String)]
    case l => s ++ l.asInstanceOf[List[(String,String,String)]]
  }}


  // @LINE:7
  private[this] lazy val controllers_HomeController_index0_route = Route("GET",
    PathPattern(List(StaticPart(this.prefix)))
  )
  private[this] lazy val controllers_HomeController_index0_invoker = createInvoker(
    HomeController_1.index(),
    play.api.routing.HandlerDef(this.getClass.getClassLoader,
      "router",
      "controllers.HomeController",
      "index",
      Nil,
      "GET",
      this.prefix + """""",
      """ An example controller showing a sample home page""",
      Seq()
    )
  )

  // @LINE:10
  private[this] lazy val controllers_Assets_versioned1_route = Route("GET",
    PathPattern(List(StaticPart(this.prefix), StaticPart(this.defaultPrefix), StaticPart("assets/"), DynamicPart("file", """.+""",false)))
  )
  private[this] lazy val controllers_Assets_versioned1_invoker = createInvoker(
    Assets_0.versioned(fakeValue[String], fakeValue[Asset]),
    play.api.routing.HandlerDef(this.getClass.getClassLoader,
      "router",
      "controllers.Assets",
      "versioned",
      Seq(classOf[String], classOf[Asset]),
      "GET",
      this.prefix + """assets/""" + "$" + """file<.+>""",
      """ Map static resources from the /public folder to the /assets URL path""",
      Seq()
    )
  )

  // @LINE:11
  private[this] lazy val controllers_HomeController_getBalance2_route = Route("GET",
    PathPattern(List(StaticPart(this.prefix), StaticPart(this.defaultPrefix), StaticPart("balance/"), DynamicPart("userId", """[^/]+""",true)))
  )
  private[this] lazy val controllers_HomeController_getBalance2_invoker = createInvoker(
    HomeController_1.getBalance(fakeValue[String]),
    play.api.routing.HandlerDef(this.getClass.getClassLoader,
      "router",
      "controllers.HomeController",
      "getBalance",
      Seq(classOf[String]),
      "GET",
      this.prefix + """balance/""" + "$" + """userId<[^/]+>""",
      """""",
      Seq()
    )
  )

  // @LINE:12
  private[this] lazy val controllers_HomeController_deposit3_route = Route("POST",
    PathPattern(List(StaticPart(this.prefix), StaticPart(this.defaultPrefix), StaticPart("deposit/"), DynamicPart("userId", """[^/]+""",true), StaticPart("/"), DynamicPart("amount", """[^/]+""",true)))
  )
  private[this] lazy val controllers_HomeController_deposit3_invoker = createInvoker(
    HomeController_1.deposit(fakeValue[String], fakeValue[Double]),
    play.api.routing.HandlerDef(this.getClass.getClassLoader,
      "router",
      "controllers.HomeController",
      "deposit",
      Seq(classOf[String], classOf[Double]),
      "POST",
      this.prefix + """deposit/""" + "$" + """userId<[^/]+>/""" + "$" + """amount<[^/]+>""",
      """""",
      Seq()
    )
  )

  // @LINE:13
  private[this] lazy val controllers_HomeController_withdraw4_route = Route("POST",
    PathPattern(List(StaticPart(this.prefix), StaticPart(this.defaultPrefix), StaticPart("withdraw/"), DynamicPart("userId", """[^/]+""",true), StaticPart("/"), DynamicPart("amount", """[^/]+""",true)))
  )
  private[this] lazy val controllers_HomeController_withdraw4_invoker = createInvoker(
    HomeController_1.withdraw(fakeValue[String], fakeValue[Double]),
    play.api.routing.HandlerDef(this.getClass.getClassLoader,
      "router",
      "controllers.HomeController",
      "withdraw",
      Seq(classOf[String], classOf[Double]),
      "POST",
      this.prefix + """withdraw/""" + "$" + """userId<[^/]+>/""" + "$" + """amount<[^/]+>""",
      """""",
      Seq()
    )
  )

  // @LINE:14
  private[this] lazy val controllers_HomeController_transfer5_route = Route("POST",
    PathPattern(List(StaticPart(this.prefix), StaticPart(this.defaultPrefix), StaticPart("transfer/"), DynamicPart("fromUserId", """[^/]+""",true), StaticPart("/"), DynamicPart("toUserId", """[^/]+""",true), StaticPart("/"), DynamicPart("amount", """[^/]+""",true)))
  )
  private[this] lazy val controllers_HomeController_transfer5_invoker = createInvoker(
    HomeController_1.transfer(fakeValue[String], fakeValue[String], fakeValue[Double]),
    play.api.routing.HandlerDef(this.getClass.getClassLoader,
      "router",
      "controllers.HomeController",
      "transfer",
      Seq(classOf[String], classOf[String], classOf[Double]),
      "POST",
      this.prefix + """transfer/""" + "$" + """fromUserId<[^/]+>/""" + "$" + """toUserId<[^/]+>/""" + "$" + """amount<[^/]+>""",
      """""",
      Seq()
    )
  )


  def routes: PartialFunction[RequestHeader, Handler] = {
  
    // @LINE:7
    case controllers_HomeController_index0_route(params@_) =>
      call { 
        controllers_HomeController_index0_invoker.call(HomeController_1.index())
      }
  
    // @LINE:10
    case controllers_Assets_versioned1_route(params@_) =>
      call(Param[String]("path", Right("/public")), params.fromPath[Asset]("file", None)) { (path, file) =>
        controllers_Assets_versioned1_invoker.call(Assets_0.versioned(path, file))
      }
  
    // @LINE:11
    case controllers_HomeController_getBalance2_route(params@_) =>
      call(params.fromPath[String]("userId", None)) { (userId) =>
        controllers_HomeController_getBalance2_invoker.call(HomeController_1.getBalance(userId))
      }
  
    // @LINE:12
    case controllers_HomeController_deposit3_route(params@_) =>
      call(params.fromPath[String]("userId", None), params.fromPath[Double]("amount", None)) { (userId, amount) =>
        controllers_HomeController_deposit3_invoker.call(HomeController_1.deposit(userId, amount))
      }
  
    // @LINE:13
    case controllers_HomeController_withdraw4_route(params@_) =>
      call(params.fromPath[String]("userId", None), params.fromPath[Double]("amount", None)) { (userId, amount) =>
        controllers_HomeController_withdraw4_invoker.call(HomeController_1.withdraw(userId, amount))
      }
  
    // @LINE:14
    case controllers_HomeController_transfer5_route(params@_) =>
      call(params.fromPath[String]("fromUserId", None), params.fromPath[String]("toUserId", None), params.fromPath[Double]("amount", None)) { (fromUserId, toUserId, amount) =>
        controllers_HomeController_transfer5_invoker.call(HomeController_1.transfer(fromUserId, toUserId, amount))
      }
  }
}


==================================================
文件路径: target\scala-2.13\routes\main\router\RoutesPrefix.scala
==================================================

// @GENERATOR:play-routes-compiler
// @SOURCE:conf/routes


package router {
  object RoutesPrefix {
    private var _prefix: String = "/"
    def setPrefix(p: String): Unit = {
      _prefix = p
    }
    def prefix: String = _prefix
    val byNamePrefix: Function0[String] = { () => prefix }
  }
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\CoordinatorStatePO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

/** State
  */
@SerialVersionUID(0L)
final case class CoordinatorStatePO(
    transactionId: _root_.scala.Predef.String = "",
    steps: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.Seq.empty,
    currentPhase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    status: net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO.TRANSACTION_CREATED,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[CoordinatorStatePO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transactionId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      steps.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      
      {
        val __value = currentPhase.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(3, __value)
        }
      };
      
      {
        val __value = status.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(4, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transactionId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      steps.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = currentPhase.value
        if (__v != 0) {
          _output__.writeEnum(3, __v)
        }
      };
      {
        val __v = status.value
        if (__v != 0) {
          _output__.writeEnum(4, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withTransactionId(__v: _root_.scala.Predef.String): CoordinatorStatePO = copy(transactionId = __v)
    def clearSteps = copy(steps = _root_.scala.Seq.empty)
    def addSteps(__vs: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO *): CoordinatorStatePO = addAllSteps(__vs)
    def addAllSteps(__vs: Iterable[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]): CoordinatorStatePO = copy(steps = steps ++ __vs)
    def withSteps(__v: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]): CoordinatorStatePO = copy(steps = __v)
    def withCurrentPhase(__v: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO): CoordinatorStatePO = copy(currentPhase = __v)
    def withStatus(__v: net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO): CoordinatorStatePO = copy(status = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transactionId
          if (__t != "") __t else null
        }
        case 2 => steps
        case 3 => {
          val __t = currentPhase.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
        case 4 => {
          val __t = status.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transactionId)
        case 2 => _root_.scalapb.descriptors.PRepeated(steps.iterator.map(_.toPMessage).toVector)
        case 3 => _root_.scalapb.descriptors.PEnum(currentPhase.scalaValueDescriptor)
        case 4 => _root_.scalapb.descriptors.PEnum(status.scalaValueDescriptor)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO.type = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.CoordinatorStatePO])
}

object CoordinatorStatePO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO = {
    var __transactionId: _root_.scala.Predef.String = ""
    val __steps: _root_.scala.collection.immutable.VectorBuilder[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = new _root_.scala.collection.immutable.VectorBuilder[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]
    var __currentPhase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
    var __status: net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO.TRANSACTION_CREATED
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transactionId = _input__.readStringRequireUtf8()
        case 18 =>
          __steps += _root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO](_input__)
        case 24 =>
          __currentPhase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(_input__.readEnum())
        case 32 =>
          __status = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO.fromValue(_input__.readEnum())
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO(
        transactionId = __transactionId,
        steps = __steps.result(),
        currentPhase = __currentPhase,
        status = __status,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO(
        transactionId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        steps = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]]).getOrElse(_root_.scala.Seq.empty),
        currentPhase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE.scalaValueDescriptor).number),
        status = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO.TRANSACTION_CREATED.scalaValueDescriptor).number)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(26)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(26)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 3 => net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
      case 4 => net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO
    }
  }
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO(
    transactionId = "",
    steps = _root_.scala.Seq.empty,
    currentPhase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    status = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO.TRANSACTION_CREATED
  )
  implicit class CoordinatorStatePOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO](_l) {
    def transactionId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transactionId)((c_, f_) => c_.copy(transactionId = f_))
    def steps: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]] = field(_.steps)((c_, f_) => c_.copy(steps = f_))
    def currentPhase: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO] = field(_.currentPhase)((c_, f_) => c_.copy(currentPhase = f_))
    def status: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO] = field(_.status)((c_, f_) => c_.copy(status = f_))
  }
  final val TRANSACTION_ID_FIELD_NUMBER = 1
  final val STEPS_FIELD_NUMBER = 2
  final val CURRENT_PHASE_FIELD_NUMBER = 3
  final val STATUS_FIELD_NUMBER = 4
  def of(
    transactionId: _root_.scala.Predef.String,
    steps: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO],
    currentPhase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO,
    status: net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO
  ): _root_.net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO = _root_.net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO(
    transactionId,
    steps,
    currentPhase,
    status
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.CoordinatorStatePO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\CoordinatorStatusPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

sealed abstract class CoordinatorStatusPO(val value: _root_.scala.Int) extends _root_.scalapb.GeneratedEnum {
  type EnumType = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO
  type RecognizedType = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO.Recognized
  def isTransactionCreated: _root_.scala.Boolean = false
  def isTransactionInProgress: _root_.scala.Boolean = false
  def isTransactionCompleted: _root_.scala.Boolean = false
  def isTransactionFailed: _root_.scala.Boolean = false
  def companion: _root_.scalapb.GeneratedEnumCompanion[CoordinatorStatusPO] = net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO
  final def asRecognized: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO.Recognized] = if (isUnrecognized) _root_.scala.None else _root_.scala.Some(this.asInstanceOf[net.imadz.infra.saga.proto.saga_v2.CoordinatorStatusPO.Recognized])
}

object CoordinatorStatusPO extends _root_.scalapb.GeneratedEnumCompanion[CoordinatorStatusPO] {
  sealed trait Recognized extends CoordinatorStatusPO
  implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[CoordinatorStatusPO] = this
  
  @SerialVersionUID(0L)
  case object TRANSACTION_CREATED extends CoordinatorStatusPO(0) with CoordinatorStatusPO.Recognized {
    val index = 0
    val name = "TRANSACTION_CREATED"
    override def isTransactionCreated: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TRANSACTION_IN_PROGRESS extends CoordinatorStatusPO(1) with CoordinatorStatusPO.Recognized {
    val index = 1
    val name = "TRANSACTION_IN_PROGRESS"
    override def isTransactionInProgress: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TRANSACTION_COMPLETED extends CoordinatorStatusPO(2) with CoordinatorStatusPO.Recognized {
    val index = 2
    val name = "TRANSACTION_COMPLETED"
    override def isTransactionCompleted: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TRANSACTION_FAILED extends CoordinatorStatusPO(3) with CoordinatorStatusPO.Recognized {
    val index = 3
    val name = "TRANSACTION_FAILED"
    override def isTransactionFailed: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  final case class Unrecognized(unrecognizedValue: _root_.scala.Int) extends CoordinatorStatusPO(unrecognizedValue) with _root_.scalapb.UnrecognizedEnum
  lazy val values: scala.collection.immutable.Seq[ValueType] = scala.collection.immutable.Seq(TRANSACTION_CREATED, TRANSACTION_IN_PROGRESS, TRANSACTION_COMPLETED, TRANSACTION_FAILED)
  def fromValue(__value: _root_.scala.Int): CoordinatorStatusPO = __value match {
    case 0 => TRANSACTION_CREATED
    case 1 => TRANSACTION_IN_PROGRESS
    case 2 => TRANSACTION_COMPLETED
    case 3 => TRANSACTION_FAILED
    case __other => Unrecognized(__other)
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = SagaV2Proto.javaDescriptor.getEnumTypes().get(2)
  def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = SagaV2Proto.scalaDescriptor.enums(2)
}

==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\ExecutionStartedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

/** Events
  */
@SerialVersionUID(0L)
final case class ExecutionStartedPO(
    transactionId: _root_.scala.Predef.String = "",
    transactionStep: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.None,
    replyToPath: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[ExecutionStartedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transactionId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (transactionStep.isDefined) {
        val __value = transactionStep.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      
      {
        val __value = replyToPath
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(3, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transactionId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      transactionStep.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = replyToPath
        if (!__v.isEmpty) {
          _output__.writeString(3, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withTransactionId(__v: _root_.scala.Predef.String): ExecutionStartedPO = copy(transactionId = __v)
    def getTransactionStep: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO = transactionStep.getOrElse(net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO.defaultInstance)
    def clearTransactionStep: ExecutionStartedPO = copy(transactionStep = _root_.scala.None)
    def withTransactionStep(__v: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO): ExecutionStartedPO = copy(transactionStep = Option(__v))
    def withReplyToPath(__v: _root_.scala.Predef.String): ExecutionStartedPO = copy(replyToPath = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transactionId
          if (__t != "") __t else null
        }
        case 2 => transactionStep.orNull
        case 3 => {
          val __t = replyToPath
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transactionId)
        case 2 => transactionStep.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => _root_.scalapb.descriptors.PString(replyToPath)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO.type = net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.ExecutionStartedPO])
}

object ExecutionStartedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO = {
    var __transactionId: _root_.scala.Predef.String = ""
    var __transactionStep: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.None
    var __replyToPath: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transactionId = _input__.readStringRequireUtf8()
        case 18 =>
          __transactionStep = Option(__transactionStep.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 26 =>
          __replyToPath = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO(
        transactionId = __transactionId,
        transactionStep = __transactionStep,
        replyToPath = __replyToPath,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO(
        transactionId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        transactionStep = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]]),
        replyToPath = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(4)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(4)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO(
    transactionId = "",
    transactionStep = _root_.scala.None,
    replyToPath = ""
  )
  implicit class ExecutionStartedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO](_l) {
    def transactionId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transactionId)((c_, f_) => c_.copy(transactionId = f_))
    def transactionStep: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = field(_.getTransactionStep)((c_, f_) => c_.copy(transactionStep = Option(f_)))
    def optionalTransactionStep: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]] = field(_.transactionStep)((c_, f_) => c_.copy(transactionStep = f_))
    def replyToPath: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.replyToPath)((c_, f_) => c_.copy(replyToPath = f_))
  }
  final val TRANSACTION_ID_FIELD_NUMBER = 1
  final val TRANSACTION_STEP_FIELD_NUMBER = 2
  final val REPLYTOPATH_FIELD_NUMBER = 3
  def of(
    transactionId: _root_.scala.Predef.String,
    transactionStep: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO],
    replyToPath: _root_.scala.Predef.String
  ): _root_.net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO = _root_.net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO(
    transactionId,
    transactionStep,
    replyToPath
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.ExecutionStartedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\OperationFailedCommandPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class OperationFailedCommandPO(
    error: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[OperationFailedCommandPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (error.isDefined) {
        val __value = error.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      error.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getError: net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO = error.getOrElse(net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO.defaultInstance)
    def clearError: OperationFailedCommandPO = copy(error = _root_.scala.None)
    def withError(__v: net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO): OperationFailedCommandPO = copy(error = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => error.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => error.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO.type = net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.OperationFailedCommandPO])
}

object OperationFailedCommandPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO = {
    var __error: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __error = Option(__error.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO(
        error = __error,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO(
        error = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(12)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(12)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO(
    error = _root_.scala.None
  )
  implicit class OperationFailedCommandPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO](_l) {
    def error: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = field(_.getError)((c_, f_) => c_.copy(error = Option(f_)))
    def optionalError: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO]] = field(_.error)((c_, f_) => c_.copy(error = f_))
  }
  final val ERROR_FIELD_NUMBER = 1
  def of(
    error: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO]
  ): _root_.net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO = _root_.net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO(
    error
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.OperationFailedCommandPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\OperationFailedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class OperationFailedPO(
    error: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[OperationFailedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (error.isDefined) {
        val __value = error.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      error.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getError: net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO = error.getOrElse(net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO.defaultInstance)
    def clearError: OperationFailedPO = copy(error = _root_.scala.None)
    def withError(__v: net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO): OperationFailedPO = copy(error = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => error.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => error.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.OperationFailedPO.type = net.imadz.infra.saga.proto.saga_v2.OperationFailedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.OperationFailedPO])
}

object OperationFailedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationFailedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationFailedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.OperationFailedPO = {
    var __error: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __error = Option(__error.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.OperationFailedPO(
        error = __error,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.OperationFailedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.OperationFailedPO(
        error = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(6)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(6)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.OperationFailedPO(
    error = _root_.scala.None
  )
  implicit class OperationFailedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationFailedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationFailedPO](_l) {
    def error: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = field(_.getError)((c_, f_) => c_.copy(error = Option(f_)))
    def optionalError: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO]] = field(_.error)((c_, f_) => c_.copy(error = f_))
  }
  final val ERROR_FIELD_NUMBER = 1
  def of(
    error: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO]
  ): _root_.net.imadz.infra.saga.proto.saga_v2.OperationFailedPO = _root_.net.imadz.infra.saga.proto.saga_v2.OperationFailedPO(
    error
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.OperationFailedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\OperationResponseCommandPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class OperationResponseCommandPO(
    result: net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[OperationResponseCommandPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (result.succeed.isDefined) {
        val __value = result.succeed.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (result.error.isDefined) {
        val __value = result.error.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      result.succeed.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      result.error.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getSucceed: net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO = result.succeed.getOrElse(net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO.defaultInstance)
    def withSucceed(__v: net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO): OperationResponseCommandPO = copy(result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Succeed(__v))
    def getError: net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO = result.error.getOrElse(net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO.defaultInstance)
    def withError(__v: net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO): OperationResponseCommandPO = copy(result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Error(__v))
    def clearResult: OperationResponseCommandPO = copy(result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Empty)
    def withResult(__v: net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result): OperationResponseCommandPO = copy(result = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => result.succeed.orNull
        case 2 => result.error.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => result.succeed.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => result.error.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.type = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.OperationResponseCommandPO])
}

object OperationResponseCommandPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO = {
    var __result: net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Empty
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Succeed(__result.succeed.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 18 =>
          __result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Error(__result.error.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO(
        result = __result,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO(
        result = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO]]).map(net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Succeed(_))
            .orElse[net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result](__fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO]]).map(net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Error(_)))
            .getOrElse(net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(13)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(13)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO(
    result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Empty
  )
  sealed trait Result extends _root_.scalapb.GeneratedOneof {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isSucceed: _root_.scala.Boolean = false
    def isError: _root_.scala.Boolean = false
    def succeed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO] = _root_.scala.None
    def error: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO] = _root_.scala.None
  }
  object Result {
    @SerialVersionUID(0L)
    case object Empty extends net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class Succeed(value: net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO) extends net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO
      override def isSucceed: _root_.scala.Boolean = true
      override def succeed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO] = Some(value)
      override def number: _root_.scala.Int = 1
    }
    @SerialVersionUID(0L)
    final case class Error(value: net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO) extends net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO
      override def isError: _root_.scala.Boolean = true
      override def error: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO] = Some(value)
      override def number: _root_.scala.Int = 2
    }
  }
  implicit class OperationResponseCommandPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO](_l) {
    def succeed: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO] = field(_.getSucceed)((c_, f_) => c_.copy(result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Succeed(f_)))
    def error: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO] = field(_.getError)((c_, f_) => c_.copy(result = net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result.Error(f_)))
    def result: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result] = field(_.result)((c_, f_) => c_.copy(result = f_))
  }
  final val SUCCEED_FIELD_NUMBER = 1
  final val ERROR_FIELD_NUMBER = 2
  def of(
    result: net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO.Result
  ): _root_.net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO = _root_.net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO(
    result
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.OperationResponseCommandPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\OperationSucceedCommandPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class OperationSucceedCommandPO(
    successMessageType: _root_.scala.Predef.String = "",
    success: _root_.com.google.protobuf.ByteString = _root_.com.google.protobuf.ByteString.EMPTY,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[OperationSucceedCommandPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = successMessageType
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = success
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(2, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = successMessageType
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = success
        if (!__v.isEmpty) {
          _output__.writeBytes(2, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withSuccessMessageType(__v: _root_.scala.Predef.String): OperationSucceedCommandPO = copy(successMessageType = __v)
    def withSuccess(__v: _root_.com.google.protobuf.ByteString): OperationSucceedCommandPO = copy(success = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = successMessageType
          if (__t != "") __t else null
        }
        case 2 => {
          val __t = success
          if (__t != _root_.com.google.protobuf.ByteString.EMPTY) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(successMessageType)
        case 2 => _root_.scalapb.descriptors.PByteString(success)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO.type = net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.OperationSucceedCommandPO])
}

object OperationSucceedCommandPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO = {
    var __successMessageType: _root_.scala.Predef.String = ""
    var __success: _root_.com.google.protobuf.ByteString = _root_.com.google.protobuf.ByteString.EMPTY
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __successMessageType = _input__.readStringRequireUtf8()
        case 18 =>
          __success = _input__.readBytes()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO(
        successMessageType = __successMessageType,
        success = __success,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO(
        successMessageType = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        success = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.com.google.protobuf.ByteString]).getOrElse(_root_.com.google.protobuf.ByteString.EMPTY)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(11)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(11)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO(
    successMessageType = "",
    success = _root_.com.google.protobuf.ByteString.EMPTY
  )
  implicit class OperationSucceedCommandPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO](_l) {
    def successMessageType: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.successMessageType)((c_, f_) => c_.copy(successMessageType = f_))
    def success: _root_.scalapb.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.success)((c_, f_) => c_.copy(success = f_))
  }
  final val SUCCESSMESSAGETYPE_FIELD_NUMBER = 1
  final val SUCCESS_FIELD_NUMBER = 2
  def of(
    successMessageType: _root_.scala.Predef.String,
    success: _root_.com.google.protobuf.ByteString
  ): _root_.net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO = _root_.net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO(
    successMessageType,
    success
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.OperationSucceedCommandPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\OperationSucceededPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

/** @param result
  *   Use bytes to store serialized result
  */
@SerialVersionUID(0L)
final case class OperationSucceededPO(
    resultType: _root_.scala.Predef.String = "",
    result: _root_.com.google.protobuf.ByteString = _root_.com.google.protobuf.ByteString.EMPTY,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[OperationSucceededPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = resultType
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = result
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(2, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = resultType
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = result
        if (!__v.isEmpty) {
          _output__.writeBytes(2, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withResultType(__v: _root_.scala.Predef.String): OperationSucceededPO = copy(resultType = __v)
    def withResult(__v: _root_.com.google.protobuf.ByteString): OperationSucceededPO = copy(result = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = resultType
          if (__t != "") __t else null
        }
        case 2 => {
          val __t = result
          if (__t != _root_.com.google.protobuf.ByteString.EMPTY) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(resultType)
        case 2 => _root_.scalapb.descriptors.PByteString(result)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO.type = net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.OperationSucceededPO])
}

object OperationSucceededPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO = {
    var __resultType: _root_.scala.Predef.String = ""
    var __result: _root_.com.google.protobuf.ByteString = _root_.com.google.protobuf.ByteString.EMPTY
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __resultType = _input__.readStringRequireUtf8()
        case 18 =>
          __result = _input__.readBytes()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO(
        resultType = __resultType,
        result = __result,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO(
        resultType = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        result = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.com.google.protobuf.ByteString]).getOrElse(_root_.com.google.protobuf.ByteString.EMPTY)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(5)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(5)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO(
    resultType = "",
    result = _root_.com.google.protobuf.ByteString.EMPTY
  )
  implicit class OperationSucceededPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO](_l) {
    def resultType: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.resultType)((c_, f_) => c_.copy(resultType = f_))
    def result: _root_.scalapb.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.result)((c_, f_) => c_.copy(result = f_))
  }
  final val RESULTTYPE_FIELD_NUMBER = 1
  final val RESULT_FIELD_NUMBER = 2
  def of(
    resultType: _root_.scala.Predef.String,
    result: _root_.com.google.protobuf.ByteString
  ): _root_.net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO = _root_.net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO(
    resultType,
    result
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.OperationSucceededPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\PhaseCompletedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class PhaseCompletedPO(
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    results: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO] = _root_.scala.Seq.empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[PhaseCompletedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = phase.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, __value)
        }
      };
      results.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = phase.value
        if (__v != 0) {
          _output__.writeEnum(1, __v)
        }
      };
      results.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withPhase(__v: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO): PhaseCompletedPO = copy(phase = __v)
    def clearResults = copy(results = _root_.scala.Seq.empty)
    def addResults(__vs: net.imadz.infra.saga.proto.saga_v2.PhaseResultPO *): PhaseCompletedPO = addAllResults(__vs)
    def addAllResults(__vs: Iterable[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO]): PhaseCompletedPO = copy(results = results ++ __vs)
    def withResults(__v: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO]): PhaseCompletedPO = copy(results = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = phase.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
        case 2 => results
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PEnum(phase.scalaValueDescriptor)
        case 2 => _root_.scalapb.descriptors.PRepeated(results.iterator.map(_.toPMessage).toVector)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO.type = net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.PhaseCompletedPO])
}

object PhaseCompletedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO = {
    var __phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
    val __results: _root_.scala.collection.immutable.VectorBuilder[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO] = new _root_.scala.collection.immutable.VectorBuilder[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO]
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 8 =>
          __phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(_input__.readEnum())
        case 18 =>
          __results += _root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO](_input__)
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO(
        phase = __phase,
        results = __results.result(),
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO(
        phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE.scalaValueDescriptor).number),
        results = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO]]).getOrElse(_root_.scala.Seq.empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(17)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(17)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
    }
  }
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO(
    phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    results = _root_.scala.Seq.empty
  )
  implicit class PhaseCompletedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO](_l) {
    def phase: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO] = field(_.phase)((c_, f_) => c_.copy(phase = f_))
    def results: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO]] = field(_.results)((c_, f_) => c_.copy(results = f_))
  }
  final val PHASE_FIELD_NUMBER = 1
  final val RESULTS_FIELD_NUMBER = 2
  def of(
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO,
    results: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO]
  ): _root_.net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO = _root_.net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO(
    phase,
    results
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.PhaseCompletedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\PhaseFailedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class PhaseFailedPO(
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[PhaseFailedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = phase.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = phase.value
        if (__v != 0) {
          _output__.writeEnum(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withPhase(__v: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO): PhaseFailedPO = copy(phase = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = phase.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PEnum(phase.scalaValueDescriptor)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO.type = net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.PhaseFailedPO])
}

object PhaseFailedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO = {
    var __phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 8 =>
          __phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(_input__.readEnum())
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO(
        phase = __phase,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO(
        phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE.scalaValueDescriptor).number)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(22)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(22)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
    }
  }
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO(
    phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
  )
  implicit class PhaseFailedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO](_l) {
    def phase: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO] = field(_.phase)((c_, f_) => c_.copy(phase = f_))
  }
  final val PHASE_FIELD_NUMBER = 1
  def of(
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
  ): _root_.net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO = _root_.net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO(
    phase
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.PhaseFailedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\PhaseFailurePO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class PhaseFailurePO(
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    errorMessage: _root_.scala.Predef.String = "",
    isRetryable: _root_.scala.Boolean = false,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[PhaseFailurePO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = phase.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, __value)
        }
      };
      
      {
        val __value = errorMessage
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      
      {
        val __value = isRetryable
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(3, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = phase.value
        if (__v != 0) {
          _output__.writeEnum(1, __v)
        }
      };
      {
        val __v = errorMessage
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      {
        val __v = isRetryable
        if (__v != false) {
          _output__.writeBool(3, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withPhase(__v: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO): PhaseFailurePO = copy(phase = __v)
    def withErrorMessage(__v: _root_.scala.Predef.String): PhaseFailurePO = copy(errorMessage = __v)
    def withIsRetryable(__v: _root_.scala.Boolean): PhaseFailurePO = copy(isRetryable = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = phase.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
        case 2 => {
          val __t = errorMessage
          if (__t != "") __t else null
        }
        case 3 => {
          val __t = isRetryable
          if (__t != false) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PEnum(phase.scalaValueDescriptor)
        case 2 => _root_.scalapb.descriptors.PString(errorMessage)
        case 3 => _root_.scalapb.descriptors.PBoolean(isRetryable)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO.type = net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.PhaseFailurePO])
}

object PhaseFailurePO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO = {
    var __phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
    var __errorMessage: _root_.scala.Predef.String = ""
    var __isRetryable: _root_.scala.Boolean = false
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 8 =>
          __phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(_input__.readEnum())
        case 18 =>
          __errorMessage = _input__.readStringRequireUtf8()
        case 24 =>
          __isRetryable = _input__.readBool()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO(
        phase = __phase,
        errorMessage = __errorMessage,
        isRetryable = __isRetryable,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO(
        phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE.scalaValueDescriptor).number),
        errorMessage = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        isRetryable = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Boolean]).getOrElse(false)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(18)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(18)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
    }
  }
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO(
    phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    errorMessage = "",
    isRetryable = false
  )
  implicit class PhaseFailurePOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO](_l) {
    def phase: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO] = field(_.phase)((c_, f_) => c_.copy(phase = f_))
    def errorMessage: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.errorMessage)((c_, f_) => c_.copy(errorMessage = f_))
    def isRetryable: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.isRetryable)((c_, f_) => c_.copy(isRetryable = f_))
  }
  final val PHASE_FIELD_NUMBER = 1
  final val ERROR_MESSAGE_FIELD_NUMBER = 2
  final val IS_RETRYABLE_FIELD_NUMBER = 3
  def of(
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO,
    errorMessage: _root_.scala.Predef.String,
    isRetryable: _root_.scala.Boolean
  ): _root_.net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO = _root_.net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO(
    phase,
    errorMessage,
    isRetryable
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.PhaseFailurePO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\PhaseResultPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class PhaseResultPO(
    result: net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[PhaseResultPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (result.error.isDefined) {
        val __value = result.error.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
      };
      if (result.success.isDefined) {
        val __value = result.success.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(2, __value)
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      result.error.foreach { __v =>
        val __m = __v
        _output__.writeString(1, __m)
      };
      result.success.foreach { __v =>
        val __m = __v
        _output__.writeBytes(2, __m)
      };
      unknownFields.writeTo(_output__)
    }
    def getError: _root_.scala.Predef.String = result.error.getOrElse("")
    def withError(__v: _root_.scala.Predef.String): PhaseResultPO = copy(result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Error(__v))
    def getSuccess: _root_.com.google.protobuf.ByteString = result.success.getOrElse(_root_.com.google.protobuf.ByteString.EMPTY)
    def withSuccess(__v: _root_.com.google.protobuf.ByteString): PhaseResultPO = copy(result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Success(__v))
    def clearResult: PhaseResultPO = copy(result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Empty)
    def withResult(__v: net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result): PhaseResultPO = copy(result = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => result.error.orNull
        case 2 => result.success.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => result.error.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => result.success.map(_root_.scalapb.descriptors.PByteString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.type = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.PhaseResultPO])
}

object PhaseResultPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.PhaseResultPO = {
    var __result: net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Empty
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Error(_input__.readStringRequireUtf8())
        case 18 =>
          __result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Success(_input__.readBytes())
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.PhaseResultPO(
        result = __result,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.PhaseResultPO(
        result = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]).map(net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Error(_))
            .orElse[net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result](__fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[_root_.com.google.protobuf.ByteString]]).map(net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Success(_)))
            .getOrElse(net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(19)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(19)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO(
    result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Empty
  )
  sealed trait Result extends _root_.scalapb.GeneratedOneof {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isError: _root_.scala.Boolean = false
    def isSuccess: _root_.scala.Boolean = false
    def error: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None
    def success: _root_.scala.Option[_root_.com.google.protobuf.ByteString] = _root_.scala.None
  }
  object Result {
    @SerialVersionUID(0L)
    case object Empty extends net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class Error(value: _root_.scala.Predef.String) extends net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result {
      type ValueType = _root_.scala.Predef.String
      override def isError: _root_.scala.Boolean = true
      override def error: _root_.scala.Option[_root_.scala.Predef.String] = Some(value)
      override def number: _root_.scala.Int = 1
    }
    @SerialVersionUID(0L)
    final case class Success(value: _root_.com.google.protobuf.ByteString) extends net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result {
      type ValueType = _root_.com.google.protobuf.ByteString
      override def isSuccess: _root_.scala.Boolean = true
      override def success: _root_.scala.Option[_root_.com.google.protobuf.ByteString] = Some(value)
      override def number: _root_.scala.Int = 2
    }
  }
  implicit class PhaseResultPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseResultPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseResultPO](_l) {
    def error: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getError)((c_, f_) => c_.copy(result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Error(f_)))
    def success: _root_.scalapb.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.getSuccess)((c_, f_) => c_.copy(result = net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result.Success(f_)))
    def result: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result] = field(_.result)((c_, f_) => c_.copy(result = f_))
  }
  final val ERROR_FIELD_NUMBER = 1
  final val SUCCESS_FIELD_NUMBER = 2
  def of(
    result: net.imadz.infra.saga.proto.saga_v2.PhaseResultPO.Result
  ): _root_.net.imadz.infra.saga.proto.saga_v2.PhaseResultPO = _root_.net.imadz.infra.saga.proto.saga_v2.PhaseResultPO(
    result
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.PhaseResultPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\PhaseSucceededPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class PhaseSucceededPO(
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[PhaseSucceededPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = phase.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = phase.value
        if (__v != 0) {
          _output__.writeEnum(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withPhase(__v: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO): PhaseSucceededPO = copy(phase = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = phase.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PEnum(phase.scalaValueDescriptor)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO.type = net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.PhaseSucceededPO])
}

object PhaseSucceededPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO = {
    var __phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 8 =>
          __phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(_input__.readEnum())
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO(
        phase = __phase,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO(
        phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE.scalaValueDescriptor).number)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(21)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(21)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
    }
  }
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO(
    phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
  )
  implicit class PhaseSucceededPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO](_l) {
    def phase: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO] = field(_.phase)((c_, f_) => c_.copy(phase = f_))
  }
  final val PHASE_FIELD_NUMBER = 1
  def of(
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
  ): _root_.net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO = _root_.net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO(
    phase
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.PhaseSucceededPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\RecoverExecutionCommandPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class RecoverExecutionCommandPO(
    transactionId: _root_.scala.Predef.String = "",
    sagaStep: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[RecoverExecutionCommandPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transactionId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (sagaStep.isDefined) {
        val __value = sagaStep.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transactionId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      sagaStep.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withTransactionId(__v: _root_.scala.Predef.String): RecoverExecutionCommandPO = copy(transactionId = __v)
    def getSagaStep: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO = sagaStep.getOrElse(net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO.defaultInstance)
    def clearSagaStep: RecoverExecutionCommandPO = copy(sagaStep = _root_.scala.None)
    def withSagaStep(__v: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO): RecoverExecutionCommandPO = copy(sagaStep = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transactionId
          if (__t != "") __t else null
        }
        case 2 => sagaStep.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transactionId)
        case 2 => sagaStep.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO.type = net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.RecoverExecutionCommandPO])
}

object RecoverExecutionCommandPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO = {
    var __transactionId: _root_.scala.Predef.String = ""
    var __sagaStep: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transactionId = _input__.readStringRequireUtf8()
        case 18 =>
          __sagaStep = Option(__sagaStep.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO(
        transactionId = __transactionId,
        sagaStep = __sagaStep,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO(
        transactionId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        sagaStep = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(10)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(10)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO(
    transactionId = "",
    sagaStep = _root_.scala.None
  )
  implicit class RecoverExecutionCommandPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO](_l) {
    def transactionId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transactionId)((c_, f_) => c_.copy(transactionId = f_))
    def sagaStep: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = field(_.getSagaStep)((c_, f_) => c_.copy(sagaStep = Option(f_)))
    def optionalSagaStep: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]] = field(_.sagaStep)((c_, f_) => c_.copy(sagaStep = f_))
  }
  final val TRANSACTION_ID_FIELD_NUMBER = 1
  final val SAGA_STEP_FIELD_NUMBER = 2
  def of(
    transactionId: _root_.scala.Predef.String,
    sagaStep: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]
  ): _root_.net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO = _root_.net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO(
    transactionId,
    sagaStep
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.RecoverExecutionCommandPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\RetryOperationCommandPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class RetryOperationCommandPO(
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[RetryOperationCommandPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      unknownFields.writeTo(_output__)
    }
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = throw new MatchError(__fieldNumber)
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = throw new MatchError(__field)
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO.type = net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.RetryOperationCommandPO])
}

object RetryOperationCommandPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO = {
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO(
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO(
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(14)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(14)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO(
  )
  implicit class RetryOperationCommandPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO](_l) {
  }
  def of(
  ): _root_.net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO = _root_.net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO(
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.RetryOperationCommandPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\RetryScheduledPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class RetryScheduledPO(
    retryCount: _root_.scala.Int = 0,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[RetryScheduledPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = retryCount
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = retryCount
        if (__v != 0) {
          _output__.writeInt32(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withRetryCount(__v: _root_.scala.Int): RetryScheduledPO = copy(retryCount = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = retryCount
          if (__t != 0) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PInt(retryCount)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO.type = net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.RetryScheduledPO])
}

object RetryScheduledPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO = {
    var __retryCount: _root_.scala.Int = 0
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 8 =>
          __retryCount = _input__.readInt32()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO(
        retryCount = __retryCount,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO(
        retryCount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Int]).getOrElse(0)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(7)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(7)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO(
    retryCount = 0
  )
  implicit class RetryScheduledPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO](_l) {
    def retryCount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.retryCount)((c_, f_) => c_.copy(retryCount = f_))
  }
  final val RETRY_COUNT_FIELD_NUMBER = 1
  def of(
    retryCount: _root_.scala.Int
  ): _root_.net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO = _root_.net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO(
    retryCount
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.RetryScheduledPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\RetryableOrNotExceptionPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class RetryableOrNotExceptionPO(
    isRetryable: _root_.scala.Boolean = false,
    message: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[RetryableOrNotExceptionPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = isRetryable
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(1, __value)
        }
      };
      
      {
        val __value = message
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = isRetryable
        if (__v != false) {
          _output__.writeBool(1, __v)
        }
      };
      {
        val __v = message
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withIsRetryable(__v: _root_.scala.Boolean): RetryableOrNotExceptionPO = copy(isRetryable = __v)
    def withMessage(__v: _root_.scala.Predef.String): RetryableOrNotExceptionPO = copy(message = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = isRetryable
          if (__t != false) __t else null
        }
        case 2 => {
          val __t = message
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PBoolean(isRetryable)
        case 2 => _root_.scalapb.descriptors.PString(message)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO.type = net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.RetryableOrNotExceptionPO])
}

object RetryableOrNotExceptionPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO = {
    var __isRetryable: _root_.scala.Boolean = false
    var __message: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 8 =>
          __isRetryable = _input__.readBool()
        case 18 =>
          __message = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO(
        isRetryable = __isRetryable,
        message = __message,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO(
        isRetryable = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Boolean]).getOrElse(false),
        message = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(3)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(3)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO(
    isRetryable = false,
    message = ""
  )
  implicit class RetryableOrNotExceptionPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO](_l) {
    def isRetryable: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.isRetryable)((c_, f_) => c_.copy(isRetryable = f_))
    def message: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.message)((c_, f_) => c_.copy(message = f_))
  }
  final val IS_RETRYABLE_FIELD_NUMBER = 1
  final val MESSAGE_FIELD_NUMBER = 2
  def of(
    isRetryable: _root_.scala.Boolean,
    message: _root_.scala.Predef.String
  ): _root_.net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO = _root_.net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO(
    isRetryable,
    message
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.RetryableOrNotExceptionPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\SagaParticipantPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

/** [关键修改]：通用的参与者容器
  *
  * @param typeName
  *   业务参与者的全限定类名，例如 "net.imadz.infra.proto.FromAccountParticipantPO"
  *   或者对应的 Scala 类名，取决于你序列化策略的映射方式
  * @param payload
  *   业务参与者序列化后的二进制数据
  */
@SerialVersionUID(0L)
final case class SagaParticipantPO(
    typeName: _root_.scala.Predef.String = "",
    payload: _root_.com.google.protobuf.ByteString = _root_.com.google.protobuf.ByteString.EMPTY,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[SagaParticipantPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = typeName
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = payload
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(2, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = typeName
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = payload
        if (!__v.isEmpty) {
          _output__.writeBytes(2, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withTypeName(__v: _root_.scala.Predef.String): SagaParticipantPO = copy(typeName = __v)
    def withPayload(__v: _root_.com.google.protobuf.ByteString): SagaParticipantPO = copy(payload = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = typeName
          if (__t != "") __t else null
        }
        case 2 => {
          val __t = payload
          if (__t != _root_.com.google.protobuf.ByteString.EMPTY) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(typeName)
        case 2 => _root_.scalapb.descriptors.PByteString(payload)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO.type = net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.SagaParticipantPO])
}

object SagaParticipantPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO = {
    var __typeName: _root_.scala.Predef.String = ""
    var __payload: _root_.com.google.protobuf.ByteString = _root_.com.google.protobuf.ByteString.EMPTY
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __typeName = _input__.readStringRequireUtf8()
        case 18 =>
          __payload = _input__.readBytes()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO(
        typeName = __typeName,
        payload = __payload,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO(
        typeName = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        payload = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.com.google.protobuf.ByteString]).getOrElse(_root_.com.google.protobuf.ByteString.EMPTY)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(0)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO(
    typeName = "",
    payload = _root_.com.google.protobuf.ByteString.EMPTY
  )
  implicit class SagaParticipantPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO](_l) {
    def typeName: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.typeName)((c_, f_) => c_.copy(typeName = f_))
    def payload: _root_.scalapb.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.payload)((c_, f_) => c_.copy(payload = f_))
  }
  final val TYPE_NAME_FIELD_NUMBER = 1
  final val PAYLOAD_FIELD_NUMBER = 2
  def of(
    typeName: _root_.scala.Predef.String,
    payload: _root_.com.google.protobuf.ByteString
  ): _root_.net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO = _root_.net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO(
    typeName,
    payload
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.SagaParticipantPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\SagaTransactionCoordinatorEventPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class SagaTransactionCoordinatorEventPO(
    event: net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.Empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[SagaTransactionCoordinatorEventPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (event.started.isDefined) {
        val __value = event.started.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.phaseSucceeded.isDefined) {
        val __value = event.phaseSucceeded.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.phaseFailed.isDefined) {
        val __value = event.phaseFailed.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.transactionCompleted.isDefined) {
        val __value = event.transactionCompleted.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.transactionFailed.isDefined) {
        val __value = event.transactionFailed.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      event.started.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.phaseSucceeded.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.phaseFailed.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.transactionCompleted.foreach { __v =>
        val __m = __v
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.transactionFailed.foreach { __v =>
        val __m = __v
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getStarted: net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO = event.started.getOrElse(net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO.defaultInstance)
    def withStarted(__v: net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO): SagaTransactionCoordinatorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.Started(__v))
    def getPhaseSucceeded: net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO = event.phaseSucceeded.getOrElse(net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO.defaultInstance)
    def withPhaseSucceeded(__v: net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO): SagaTransactionCoordinatorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.PhaseSucceeded(__v))
    def getPhaseFailed: net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO = event.phaseFailed.getOrElse(net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO.defaultInstance)
    def withPhaseFailed(__v: net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO): SagaTransactionCoordinatorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.PhaseFailed(__v))
    def getTransactionCompleted: net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO = event.transactionCompleted.getOrElse(net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO.defaultInstance)
    def withTransactionCompleted(__v: net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO): SagaTransactionCoordinatorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.TransactionCompleted(__v))
    def getTransactionFailed: net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO = event.transactionFailed.getOrElse(net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO.defaultInstance)
    def withTransactionFailed(__v: net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO): SagaTransactionCoordinatorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.TransactionFailed(__v))
    def clearEvent: SagaTransactionCoordinatorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.Empty)
    def withEvent(__v: net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event): SagaTransactionCoordinatorEventPO = copy(event = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => event.started.orNull
        case 2 => event.phaseSucceeded.orNull
        case 3 => event.phaseFailed.orNull
        case 4 => event.transactionCompleted.orNull
        case 5 => event.transactionFailed.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => event.started.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => event.phaseSucceeded.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => event.phaseFailed.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => event.transactionCompleted.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => event.transactionFailed.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.type = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.SagaTransactionCoordinatorEventPO])
}

object SagaTransactionCoordinatorEventPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO = {
    var __event: net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.Empty
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.Started(__event.started.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 18 =>
          __event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.PhaseSucceeded(__event.phaseSucceeded.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 26 =>
          __event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.PhaseFailed(__event.phaseFailed.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 34 =>
          __event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.TransactionCompleted(__event.transactionCompleted.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 42 =>
          __event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.TransactionFailed(__event.transactionFailed.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO(
        event = __event,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO(
        event = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO]]).map(net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.Started(_))
            .orElse[net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO]]).map(net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.PhaseSucceeded(_)))
            .orElse[net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO]]).map(net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.PhaseFailed(_)))
            .orElse[net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO]]).map(net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.TransactionCompleted(_)))
            .orElse[net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO]]).map(net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.TransactionFailed(_)))
            .getOrElse(net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.Empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(25)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(25)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO
      case 3 => __out = net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO
      case 4 => __out = net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO
      case 5 => __out = net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO(
    event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.Empty
  )
  sealed trait Event extends _root_.scalapb.GeneratedOneof {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isStarted: _root_.scala.Boolean = false
    def isPhaseSucceeded: _root_.scala.Boolean = false
    def isPhaseFailed: _root_.scala.Boolean = false
    def isTransactionCompleted: _root_.scala.Boolean = false
    def isTransactionFailed: _root_.scala.Boolean = false
    def started: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO] = _root_.scala.None
    def phaseSucceeded: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO] = _root_.scala.None
    def phaseFailed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO] = _root_.scala.None
    def transactionCompleted: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO] = _root_.scala.None
    def transactionFailed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO] = _root_.scala.None
  }
  object Event {
    @SerialVersionUID(0L)
    case object Empty extends net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class Started(value: net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO) extends net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO
      override def isStarted: _root_.scala.Boolean = true
      override def started: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO] = Some(value)
      override def number: _root_.scala.Int = 1
    }
    @SerialVersionUID(0L)
    final case class PhaseSucceeded(value: net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO) extends net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO
      override def isPhaseSucceeded: _root_.scala.Boolean = true
      override def phaseSucceeded: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO] = Some(value)
      override def number: _root_.scala.Int = 2
    }
    @SerialVersionUID(0L)
    final case class PhaseFailed(value: net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO) extends net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO
      override def isPhaseFailed: _root_.scala.Boolean = true
      override def phaseFailed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO] = Some(value)
      override def number: _root_.scala.Int = 3
    }
    @SerialVersionUID(0L)
    final case class TransactionCompleted(value: net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO) extends net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO
      override def isTransactionCompleted: _root_.scala.Boolean = true
      override def transactionCompleted: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO] = Some(value)
      override def number: _root_.scala.Int = 4
    }
    @SerialVersionUID(0L)
    final case class TransactionFailed(value: net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO) extends net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO
      override def isTransactionFailed: _root_.scala.Boolean = true
      override def transactionFailed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO] = Some(value)
      override def number: _root_.scala.Int = 5
    }
  }
  implicit class SagaTransactionCoordinatorEventPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO](_l) {
    def started: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO] = field(_.getStarted)((c_, f_) => c_.copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.Started(f_)))
    def phaseSucceeded: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO] = field(_.getPhaseSucceeded)((c_, f_) => c_.copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.PhaseSucceeded(f_)))
    def phaseFailed: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO] = field(_.getPhaseFailed)((c_, f_) => c_.copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.PhaseFailed(f_)))
    def transactionCompleted: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO] = field(_.getTransactionCompleted)((c_, f_) => c_.copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.TransactionCompleted(f_)))
    def transactionFailed: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO] = field(_.getTransactionFailed)((c_, f_) => c_.copy(event = net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event.TransactionFailed(f_)))
    def event: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event] = field(_.event)((c_, f_) => c_.copy(event = f_))
  }
  final val STARTED_FIELD_NUMBER = 1
  final val PHASESUCCEEDED_FIELD_NUMBER = 2
  final val PHASEFAILED_FIELD_NUMBER = 3
  final val TRANSACTIONCOMPLETED_FIELD_NUMBER = 4
  final val TRANSACTIONFAILED_FIELD_NUMBER = 5
  def of(
    event: net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO.Event
  ): _root_.net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO = _root_.net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO(
    event
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.SagaTransactionCoordinatorEventPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\SagaTransactionStepPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

/** Messages
  *
  * @param participantType
  *   This will be used to identify the participant implementation
  */
@SerialVersionUID(0L)
final case class SagaTransactionStepPO(
    stepId: _root_.scala.Predef.String = "",
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    maxRetries: _root_.scala.Int = 0,
    timeoutDurationMillis: _root_.scala.Long = 0L,
    retryWhenRecoveredOngoing: _root_.scala.Boolean = false,
    participant: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO] = _root_.scala.None,
    participantType: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[SagaTransactionStepPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = stepId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = phase.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(2, __value)
        }
      };
      
      {
        val __value = maxRetries
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(3, __value)
        }
      };
      
      {
        val __value = timeoutDurationMillis
        if (__value != 0L) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(4, __value)
        }
      };
      
      {
        val __value = retryWhenRecoveredOngoing
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(5, __value)
        }
      };
      if (participant.isDefined) {
        val __value = participant.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      
      {
        val __value = participantType
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(7, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = stepId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = phase.value
        if (__v != 0) {
          _output__.writeEnum(2, __v)
        }
      };
      {
        val __v = maxRetries
        if (__v != 0) {
          _output__.writeInt32(3, __v)
        }
      };
      {
        val __v = timeoutDurationMillis
        if (__v != 0L) {
          _output__.writeInt64(4, __v)
        }
      };
      {
        val __v = retryWhenRecoveredOngoing
        if (__v != false) {
          _output__.writeBool(5, __v)
        }
      };
      participant.foreach { __v =>
        val __m = __v
        _output__.writeTag(6, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = participantType
        if (!__v.isEmpty) {
          _output__.writeString(7, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withStepId(__v: _root_.scala.Predef.String): SagaTransactionStepPO = copy(stepId = __v)
    def withPhase(__v: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO): SagaTransactionStepPO = copy(phase = __v)
    def withMaxRetries(__v: _root_.scala.Int): SagaTransactionStepPO = copy(maxRetries = __v)
    def withTimeoutDurationMillis(__v: _root_.scala.Long): SagaTransactionStepPO = copy(timeoutDurationMillis = __v)
    def withRetryWhenRecoveredOngoing(__v: _root_.scala.Boolean): SagaTransactionStepPO = copy(retryWhenRecoveredOngoing = __v)
    def getParticipant: net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO = participant.getOrElse(net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO.defaultInstance)
    def clearParticipant: SagaTransactionStepPO = copy(participant = _root_.scala.None)
    def withParticipant(__v: net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO): SagaTransactionStepPO = copy(participant = Option(__v))
    def withParticipantType(__v: _root_.scala.Predef.String): SagaTransactionStepPO = copy(participantType = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = stepId
          if (__t != "") __t else null
        }
        case 2 => {
          val __t = phase.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
        case 3 => {
          val __t = maxRetries
          if (__t != 0) __t else null
        }
        case 4 => {
          val __t = timeoutDurationMillis
          if (__t != 0L) __t else null
        }
        case 5 => {
          val __t = retryWhenRecoveredOngoing
          if (__t != false) __t else null
        }
        case 6 => participant.orNull
        case 7 => {
          val __t = participantType
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(stepId)
        case 2 => _root_.scalapb.descriptors.PEnum(phase.scalaValueDescriptor)
        case 3 => _root_.scalapb.descriptors.PInt(maxRetries)
        case 4 => _root_.scalapb.descriptors.PLong(timeoutDurationMillis)
        case 5 => _root_.scalapb.descriptors.PBoolean(retryWhenRecoveredOngoing)
        case 6 => participant.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 7 => _root_.scalapb.descriptors.PString(participantType)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO.type = net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.SagaTransactionStepPO])
}

object SagaTransactionStepPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO = {
    var __stepId: _root_.scala.Predef.String = ""
    var __phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
    var __maxRetries: _root_.scala.Int = 0
    var __timeoutDurationMillis: _root_.scala.Long = 0L
    var __retryWhenRecoveredOngoing: _root_.scala.Boolean = false
    var __participant: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO] = _root_.scala.None
    var __participantType: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __stepId = _input__.readStringRequireUtf8()
        case 16 =>
          __phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(_input__.readEnum())
        case 24 =>
          __maxRetries = _input__.readInt32()
        case 32 =>
          __timeoutDurationMillis = _input__.readInt64()
        case 40 =>
          __retryWhenRecoveredOngoing = _input__.readBool()
        case 50 =>
          __participant = Option(__participant.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 58 =>
          __participantType = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO(
        stepId = __stepId,
        phase = __phase,
        maxRetries = __maxRetries,
        timeoutDurationMillis = __timeoutDurationMillis,
        retryWhenRecoveredOngoing = __retryWhenRecoveredOngoing,
        participant = __participant,
        participantType = __participantType,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO(
        stepId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE.scalaValueDescriptor).number),
        maxRetries = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Int]).getOrElse(0),
        timeoutDurationMillis = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        retryWhenRecoveredOngoing = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).map(_.as[_root_.scala.Boolean]).getOrElse(false),
        participant = __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO]]),
        participantType = __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(1)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(1)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 6 => __out = net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 2 => net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
    }
  }
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO(
    stepId = "",
    phase = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.PREPARE_PHASE,
    maxRetries = 0,
    timeoutDurationMillis = 0L,
    retryWhenRecoveredOngoing = false,
    participant = _root_.scala.None,
    participantType = ""
  )
  implicit class SagaTransactionStepPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO](_l) {
    def stepId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.stepId)((c_, f_) => c_.copy(stepId = f_))
    def phase: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO] = field(_.phase)((c_, f_) => c_.copy(phase = f_))
    def maxRetries: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.maxRetries)((c_, f_) => c_.copy(maxRetries = f_))
    def timeoutDurationMillis: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.timeoutDurationMillis)((c_, f_) => c_.copy(timeoutDurationMillis = f_))
    def retryWhenRecoveredOngoing: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.retryWhenRecoveredOngoing)((c_, f_) => c_.copy(retryWhenRecoveredOngoing = f_))
    def participant: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO] = field(_.getParticipant)((c_, f_) => c_.copy(participant = Option(f_)))
    def optionalParticipant: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO]] = field(_.participant)((c_, f_) => c_.copy(participant = f_))
    def participantType: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.participantType)((c_, f_) => c_.copy(participantType = f_))
  }
  final val STEP_ID_FIELD_NUMBER = 1
  final val PHASE_FIELD_NUMBER = 2
  final val MAX_RETRIES_FIELD_NUMBER = 3
  final val TIMEOUT_DURATION_MILLIS_FIELD_NUMBER = 4
  final val RETRY_WHEN_RECOVERED_ONGOING_FIELD_NUMBER = 5
  final val PARTICIPANT_FIELD_NUMBER = 6
  final val PARTICIPANT_TYPE_FIELD_NUMBER = 7
  def of(
    stepId: _root_.scala.Predef.String,
    phase: net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO,
    maxRetries: _root_.scala.Int,
    timeoutDurationMillis: _root_.scala.Long,
    retryWhenRecoveredOngoing: _root_.scala.Boolean,
    participant: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO],
    participantType: _root_.scala.Predef.String
  ): _root_.net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO = _root_.net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO(
    stepId,
    phase,
    maxRetries,
    timeoutDurationMillis,
    retryWhenRecoveredOngoing,
    participant,
    participantType
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.SagaTransactionStepPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\SagaV2Proto.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

object SagaV2Proto extends _root_.scalapb.GeneratedFileObject {
  lazy val dependencies: Seq[_root_.scalapb.GeneratedFileObject] = Seq.empty
  lazy val messagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] =
    Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]](
      net.imadz.infra.saga.proto.saga_v2.SagaParticipantPO,
      net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO,
      net.imadz.infra.saga.proto.saga_v2.StepStatePO,
      net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO,
      net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO,
      net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO,
      net.imadz.infra.saga.proto.saga_v2.OperationFailedPO,
      net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO,
      net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO,
      net.imadz.infra.saga.proto.saga_v2.StartCommandPO,
      net.imadz.infra.saga.proto.saga_v2.RecoverExecutionCommandPO,
      net.imadz.infra.saga.proto.saga_v2.OperationSucceedCommandPO,
      net.imadz.infra.saga.proto.saga_v2.OperationFailedCommandPO,
      net.imadz.infra.saga.proto.saga_v2.OperationResponseCommandPO,
      net.imadz.infra.saga.proto.saga_v2.RetryOperationCommandPO,
      net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO,
      net.imadz.infra.saga.proto.saga_v2.StartTransactionPO,
      net.imadz.infra.saga.proto.saga_v2.PhaseCompletedPO,
      net.imadz.infra.saga.proto.saga_v2.PhaseFailurePO,
      net.imadz.infra.saga.proto.saga_v2.PhaseResultPO,
      net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO,
      net.imadz.infra.saga.proto.saga_v2.PhaseSucceededPO,
      net.imadz.infra.saga.proto.saga_v2.PhaseFailedPO,
      net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO,
      net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO,
      net.imadz.infra.saga.proto.saga_v2.SagaTransactionCoordinatorEventPO,
      net.imadz.infra.saga.proto.saga_v2.CoordinatorStatePO
    )
  private lazy val ProtoBytes: _root_.scala.Array[Byte] =
      scalapb.Encoding.fromBase64(scala.collection.immutable.Seq(
  """Cg1zYWdhX3YyLnByb3RvEhRuZXQuaW1hZHouaW5mcmEuc2FnYSJnChFTYWdhUGFydGljaXBhbnRQTxIqCgl0eXBlX25hbWUYA
  SABKAlCDeI/ChIIdHlwZU5hbWVSCHR5cGVOYW1lEiYKB3BheWxvYWQYAiABKAxCDOI/CRIHcGF5bG9hZFIHcGF5bG9hZCKOBAoVU
  2FnYVRyYW5zYWN0aW9uU3RlcFBPEiQKB3N0ZXBfaWQYASABKAlCC+I/CBIGc3RlcElkUgZzdGVwSWQSSgoFcGhhc2UYAiABKA4yK
  C5uZXQuaW1hZHouaW5mcmEuc2FnYS5UcmFuc2FjdGlvblBoYXNlUE9CCuI/BxIFcGhhc2VSBXBoYXNlEjAKC21heF9yZXRyaWVzG
  AMgASgFQg/iPwwSCm1heFJldHJpZXNSCm1heFJldHJpZXMSUgoXdGltZW91dF9kdXJhdGlvbl9taWxsaXMYBCABKANCGuI/FxIVd
  GltZW91dER1cmF0aW9uTWlsbGlzUhV0aW1lb3V0RHVyYXRpb25NaWxsaXMSXwoccmV0cnlfd2hlbl9yZWNvdmVyZWRfb25nb2luZ
  xgFIAEoCEIe4j8bEhlyZXRyeVdoZW5SZWNvdmVyZWRPbmdvaW5nUhlyZXRyeVdoZW5SZWNvdmVyZWRPbmdvaW5nElsKC3BhcnRpY
  2lwYW50GAYgASgLMicubmV0LmltYWR6LmluZnJhLnNhZ2EuU2FnYVBhcnRpY2lwYW50UE9CEOI/DRILcGFydGljaXBhbnRSC3Bhc
  nRpY2lwYW50Ej8KEHBhcnRpY2lwYW50X3R5cGUYByABKAlCFOI/ERIPcGFydGljaXBhbnRUeXBlUg9wYXJ0aWNpcGFudFR5cGUi5
  AMKC1N0ZXBTdGF0ZVBPEkoKBHN0ZXAYASABKAsyKy5uZXQuaW1hZHouaW5mcmEuc2FnYS5TYWdhVHJhbnNhY3Rpb25TdGVwUE9CC
  eI/BhIEc3RlcFIEc3RlcBI5Cg50cmFuc2FjdGlvbl9pZBgCIAEoCUIS4j8PEg10cmFuc2FjdGlvbklkUg10cmFuc2FjdGlvbklkE
  kcKBnN0YXR1cxgDIAEoDjIiLm5ldC5pbWFkei5pbmZyYS5zYWdhLlN0ZXBTdGF0dXNQT0IL4j8IEgZzdGF0dXNSBnN0YXR1cxImC
  gdyZXRyaWVzGAQgASgFQgziPwkSB3JldHJpZXNSB3JldHJpZXMSXgoKbGFzdF9lcnJvchgFIAEoCzIvLm5ldC5pbWFkei5pbmZyY
  S5zYWdhLlJldHJ5YWJsZU9yTm90RXhjZXB0aW9uUE9CDuI/CxIJbGFzdEVycm9yUglsYXN0RXJyb3ISSQoUY2lyY3VpdF9icmVha
  2VyX29wZW4YBiABKAhCF+I/FBISY2lyY3VpdEJyZWFrZXJPcGVuUhJjaXJjdWl0QnJlYWtlck9wZW4SMgoLcmVwbHlUb1BhdGgYB
  yABKAlCEOI/DRILcmVwbHlUb1BhdGhSC3JlcGx5VG9QYXRoIngKGVJldHJ5YWJsZU9yTm90RXhjZXB0aW9uUE8SMwoMaXNfcmV0c
  nlhYmxlGAEgASgIQhDiPw0SC2lzUmV0cnlhYmxlUgtpc1JldHJ5YWJsZRImCgdtZXNzYWdlGAIgASgJQgziPwkSB21lc3NhZ2VSB
  21lc3NhZ2Ui8QEKEkV4ZWN1dGlvblN0YXJ0ZWRQTxI5Cg50cmFuc2FjdGlvbl9pZBgBIAEoCUIS4j8PEg10cmFuc2FjdGlvbklkU
  g10cmFuc2FjdGlvbklkEmwKEHRyYW5zYWN0aW9uX3N0ZXAYAiABKAsyKy5uZXQuaW1hZHouaW5mcmEuc2FnYS5TYWdhVHJhbnNhY
  3Rpb25TdGVwUE9CFOI/ERIPdHJhbnNhY3Rpb25TdGVwUg90cmFuc2FjdGlvblN0ZXASMgoLcmVwbHlUb1BhdGgYAyABKAlCEOI/D
  RILcmVwbHlUb1BhdGhSC3JlcGx5VG9QYXRoImwKFE9wZXJhdGlvblN1Y2NlZWRlZFBPEi8KCnJlc3VsdFR5cGUYASABKAlCD+I/D
  BIKcmVzdWx0VHlwZVIKcmVzdWx0VHlwZRIjCgZyZXN1bHQYAiABKAxCC+I/CBIGcmVzdWx0UgZyZXN1bHQiZgoRT3BlcmF0aW9uR
  mFpbGVkUE8SUQoFZXJyb3IYASABKAsyLy5uZXQuaW1hZHouaW5mcmEuc2FnYS5SZXRyeWFibGVPck5vdEV4Y2VwdGlvblBPQgriP
  wcSBWVycm9yUgVlcnJvciJEChBSZXRyeVNjaGVkdWxlZFBPEjAKC3JldHJ5X2NvdW50GAEgASgFQg/iPwwSCnJldHJ5Q291bnRSC
  nJldHJ5Q291bnQi9gIKE1N0ZXBFeGVjdXRvckV2ZW50UE8SUgoHc3RhcnRlZBgBIAEoCzIoLm5ldC5pbWFkei5pbmZyYS5zYWdhL
  kV4ZWN1dGlvblN0YXJ0ZWRQT0IM4j8JEgdzdGFydGVkSABSB3N0YXJ0ZWQSVAoHc3VjY2VlZBgCIAEoCzIqLm5ldC5pbWFkei5pb
  mZyYS5zYWdhLk9wZXJhdGlvblN1Y2NlZWRlZFBPQgziPwkSB3N1Y2NlZWRIAFIHc3VjY2VlZBJOCgZmYWlsZWQYAyABKAsyJy5uZ
  XQuaW1hZHouaW5mcmEuc2FnYS5PcGVyYXRpb25GYWlsZWRQT0IL4j8IEgZmYWlsZWRIAFIGZmFpbGVkElwKC3Jlc2NoZWR1bGVkG
  AQgASgLMiYubmV0LmltYWR6LmluZnJhLnNhZ2EuUmV0cnlTY2hlZHVsZWRQT0IQ4j8NEgtyZXNjaGVkdWxlZEgAUgtyZXNjaGVkd
  WxlZEIHCgVldmVudCLYAQoOU3RhcnRDb21tYW5kUE8SOQoOdHJhbnNhY3Rpb25faWQYASABKAlCEuI/DxINdHJhbnNhY3Rpb25JZ
  FINdHJhbnNhY3Rpb25JZBJXCglzYWdhX3N0ZXAYAiABKAsyKy5uZXQuaW1hZHouaW5mcmEuc2FnYS5TYWdhVHJhbnNhY3Rpb25Td
  GVwUE9CDeI/ChIIc2FnYVN0ZXBSCHNhZ2FTdGVwEjIKC3JlcGx5VG9QYXRoGAMgASgJQhDiPw0SC3JlcGx5VG9QYXRoUgtyZXBse
  VRvUGF0aCKvAQoZUmVjb3ZlckV4ZWN1dGlvbkNvbW1hbmRQTxI5Cg50cmFuc2FjdGlvbl9pZBgBIAEoCUIS4j8PEg10cmFuc2Fjd
  GlvbklkUg10cmFuc2FjdGlvbklkElcKCXNhZ2Ffc3RlcBgCIAEoCzIrLm5ldC5pbWFkei5pbmZyYS5zYWdhLlNhZ2FUcmFuc2Fjd
  GlvblN0ZXBQT0IN4j8KEghzYWdhU3RlcFIIc2FnYVN0ZXAijAEKGU9wZXJhdGlvblN1Y2NlZWRDb21tYW5kUE8SRwoSc3VjY2Vzc
  01lc3NhZ2VUeXBlGAEgASgJQhfiPxQSEnN1Y2Nlc3NNZXNzYWdlVHlwZVISc3VjY2Vzc01lc3NhZ2VUeXBlEiYKB3N1Y2Nlc3MYA
  iABKAxCDOI/CRIHc3VjY2Vzc1IHc3VjY2VzcyJtChhPcGVyYXRpb25GYWlsZWRDb21tYW5kUE8SUQoFZXJyb3IYASABKAsyLy5uZ
  XQuaW1hZHouaW5mcmEuc2FnYS5SZXRyeWFibGVPck5vdEV4Y2VwdGlvblBPQgriPwcSBWVycm9yUgVlcnJvciLVAQoaT3BlcmF0a
  W9uUmVzcG9uc2VDb21tYW5kUE8SWQoHc3VjY2VlZBgBIAEoCzIvLm5ldC5pbWFkei5pbmZyYS5zYWdhLk9wZXJhdGlvblN1Y2NlZ
  WRDb21tYW5kUE9CDOI/CRIHc3VjY2VlZEgAUgdzdWNjZWVkElIKBWVycm9yGAIgASgLMi4ubmV0LmltYWR6LmluZnJhLnNhZ2EuT
  3BlcmF0aW9uRmFpbGVkQ29tbWFuZFBPQgriPwcSBWVycm9ySABSBWVycm9yQggKBnJlc3VsdCIZChdSZXRyeU9wZXJhdGlvbkNvb
  W1hbmRQTyITChFUaW1lZE91dENvbW1hbmRQTyKeAQoSU3RhcnRUcmFuc2FjdGlvblBPEjkKDnRyYW5zYWN0aW9uX2lkGAEgASgJQ
  hLiPw8SDXRyYW5zYWN0aW9uSWRSDXRyYW5zYWN0aW9uSWQSTQoFc3RlcHMYAiADKAsyKy5uZXQuaW1hZHouaW5mcmEuc2FnYS5TY
  WdhVHJhbnNhY3Rpb25TdGVwUE9CCuI/BxIFc3RlcHNSBXN0ZXBzIqsBChBQaGFzZUNvbXBsZXRlZFBPEkoKBXBoYXNlGAEgASgOM
  igubmV0LmltYWR6LmluZnJhLnNhZ2EuVHJhbnNhY3Rpb25QaGFzZVBPQgriPwcSBXBoYXNlUgVwaGFzZRJLCgdyZXN1bHRzGAIgA
  ygLMiMubmV0LmltYWR6LmluZnJhLnNhZ2EuUGhhc2VSZXN1bHRQT0IM4j8JEgdyZXN1bHRzUgdyZXN1bHRzIskBCg5QaGFzZUZha
  Wx1cmVQTxJKCgVwaGFzZRgBIAEoDjIoLm5ldC5pbWFkei5pbmZyYS5zYWdhLlRyYW5zYWN0aW9uUGhhc2VQT0IK4j8HEgVwaGFzZ
  VIFcGhhc2USNgoNZXJyb3JfbWVzc2FnZRgCIAEoCUIR4j8OEgxlcnJvck1lc3NhZ2VSDGVycm9yTWVzc2FnZRIzCgxpc19yZXRye
  WFibGUYAyABKAhCEOI/DRILaXNSZXRyeWFibGVSC2lzUmV0cnlhYmxlImcKDVBoYXNlUmVzdWx0UE8SIgoFZXJyb3IYASABKAlCC
  uI/BxIFZXJyb3JIAFIFZXJyb3ISKAoHc3VjY2VzcxgCIAEoDEIM4j8JEgdzdWNjZXNzSABSB3N1Y2Nlc3NCCAoGcmVzdWx0IqABC
  hRUcmFuc2FjdGlvblN0YXJ0ZWRQTxI5Cg50cmFuc2FjdGlvbl9pZBgBIAEoCUIS4j8PEg10cmFuc2FjdGlvbklkUg10cmFuc2Fjd
  GlvbklkEk0KBXN0ZXBzGAIgAygLMisubmV0LmltYWR6LmluZnJhLnNhZ2EuU2FnYVRyYW5zYWN0aW9uU3RlcFBPQgriPwcSBXN0Z
  XBzUgVzdGVwcyJeChBQaGFzZVN1Y2NlZWRlZFBPEkoKBXBoYXNlGAEgASgOMigubmV0LmltYWR6LmluZnJhLnNhZ2EuVHJhbnNhY
  3Rpb25QaGFzZVBPQgriPwcSBXBoYXNlUgVwaGFzZSJbCg1QaGFzZUZhaWxlZFBPEkoKBXBoYXNlGAEgASgOMigubmV0LmltYWR6L
  mluZnJhLnNhZ2EuVHJhbnNhY3Rpb25QaGFzZVBPQgriPwcSBXBoYXNlUgVwaGFzZSJTChZUcmFuc2FjdGlvbkNvbXBsZXRlZFBPE
  jkKDnRyYW5zYWN0aW9uX2lkGAEgASgJQhLiPw8SDXRyYW5zYWN0aW9uSWRSDXRyYW5zYWN0aW9uSWQidQoTVHJhbnNhY3Rpb25GY
  WlsZWRQTxI5Cg50cmFuc2FjdGlvbl9pZBgBIAEoCUIS4j8PEg10cmFuc2FjdGlvbklkUg10cmFuc2FjdGlvbklkEiMKBnJlYXNvb
  hgCIAEoCUIL4j8IEgZyZWFzb25SBnJlYXNvbiK2BAohU2FnYVRyYW5zYWN0aW9uQ29vcmRpbmF0b3JFdmVudFBPElQKB3N0YXJ0Z
  WQYASABKAsyKi5uZXQuaW1hZHouaW5mcmEuc2FnYS5UcmFuc2FjdGlvblN0YXJ0ZWRQT0IM4j8JEgdzdGFydGVkSABSB3N0YXJ0Z
  WQSZQoOcGhhc2VTdWNjZWVkZWQYAiABKAsyJi5uZXQuaW1hZHouaW5mcmEuc2FnYS5QaGFzZVN1Y2NlZWRlZFBPQhPiPxASDnBoY
  XNlU3VjY2VlZGVkSABSDnBoYXNlU3VjY2VlZGVkElkKC3BoYXNlRmFpbGVkGAMgASgLMiMubmV0LmltYWR6LmluZnJhLnNhZ2EuU
  Ghhc2VGYWlsZWRQT0IQ4j8NEgtwaGFzZUZhaWxlZEgAUgtwaGFzZUZhaWxlZBJ9ChR0cmFuc2FjdGlvbkNvbXBsZXRlZBgEIAEoC
  zIsLm5ldC5pbWFkei5pbmZyYS5zYWdhLlRyYW5zYWN0aW9uQ29tcGxldGVkUE9CGeI/FhIUdHJhbnNhY3Rpb25Db21wbGV0ZWRIA
  FIUdHJhbnNhY3Rpb25Db21wbGV0ZWQScQoRdHJhbnNhY3Rpb25GYWlsZWQYBSABKAsyKS5uZXQuaW1hZHouaW5mcmEuc2FnYS5Uc
  mFuc2FjdGlvbkZhaWxlZFBPQhbiPxMSEXRyYW5zYWN0aW9uRmFpbGVkSABSEXRyYW5zYWN0aW9uRmFpbGVkQgcKBWV2ZW50ItACC
  hJDb29yZGluYXRvclN0YXRlUE8SOQoOdHJhbnNhY3Rpb25faWQYASABKAlCEuI/DxINdHJhbnNhY3Rpb25JZFINdHJhbnNhY3Rpb
  25JZBJNCgVzdGVwcxgCIAMoCzIrLm5ldC5pbWFkei5pbmZyYS5zYWdhLlNhZ2FUcmFuc2FjdGlvblN0ZXBQT0IK4j8HEgVzdGVwc
  1IFc3RlcHMSYAoNY3VycmVudF9waGFzZRgDIAEoDjIoLm5ldC5pbWFkei5pbmZyYS5zYWdhLlRyYW5zYWN0aW9uUGhhc2VQT0IR4
  j8OEgxjdXJyZW50UGhhc2VSDGN1cnJlbnRQaGFzZRJOCgZzdGF0dXMYBCABKA4yKS5uZXQuaW1hZHouaW5mcmEuc2FnYS5Db29yZ
  GluYXRvclN0YXR1c1BPQgviPwgSBnN0YXR1c1IGc3RhdHVzKo0BChJUcmFuc2FjdGlvblBoYXNlUE8SJQoNUFJFUEFSRV9QSEFTR
  RAAGhLiPw8SDVBSRVBBUkVfUEhBU0USIwoMQ09NTUlUX1BIQVNFEAEaEeI/DhIMQ09NTUlUX1BIQVNFEisKEENPTVBFTlNBVEVfU
  EhBU0UQAhoV4j8SEhBDT01QRU5TQVRFX1BIQVNFKngKDFN0ZXBTdGF0dXNQTxIZCgdDUkVBVEVEEAAaDOI/CRIHQ1JFQVRFRBIZC
  gdPTkdPSU5HEAEaDOI/CRIHT05HT0lORxIZCgdTVUNDRUVEEAIaDOI/CRIHU1VDQ0VFRBIXCgZGQUlMRUQQAxoL4j8IEgZGQUlMR
  UQq6wEKE0Nvb3JkaW5hdG9yU3RhdHVzUE8SMQoTVFJBTlNBQ1RJT05fQ1JFQVRFRBAAGhjiPxUSE1RSQU5TQUNUSU9OX0NSRUFUR
  UQSOQoXVFJBTlNBQ1RJT05fSU5fUFJPR1JFU1MQARoc4j8ZEhdUUkFOU0FDVElPTl9JTl9QUk9HUkVTUxI1ChVUUkFOU0FDVElPT
  l9DT01QTEVURUQQAhoa4j8XEhVUUkFOU0FDVElPTl9DT01QTEVURUQSLwoSVFJBTlNBQ1RJT05fRkFJTEVEEAMaF+I/FBISVFJBT
  lNBQ1RJT05fRkFJTEVEQh4KGm5ldC5pbWFkei5pbmZyYS5zYWdhLnByb3RvUAFiBnByb3RvMw=="""
      ).mkString)
  lazy val scalaDescriptor: _root_.scalapb.descriptors.FileDescriptor = {
    val scalaProto = com.google.protobuf.descriptor.FileDescriptorProto.parseFrom(ProtoBytes)
    _root_.scalapb.descriptors.FileDescriptor.buildFrom(scalaProto, dependencies.map(_.scalaDescriptor))
  }
  lazy val javaDescriptor: com.google.protobuf.Descriptors.FileDescriptor = {
    val javaProto = com.google.protobuf.DescriptorProtos.FileDescriptorProto.parseFrom(ProtoBytes)
    com.google.protobuf.Descriptors.FileDescriptor.buildFrom(javaProto, _root_.scala.Array(
    ))
  }
  @deprecated("Use javaDescriptor instead. In a future version this will refer to scalaDescriptor.", "ScalaPB 0.5.47")
  def descriptor: com.google.protobuf.Descriptors.FileDescriptor = javaDescriptor
}

==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\StartCommandPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

/** Commands
  */
@SerialVersionUID(0L)
final case class StartCommandPO(
    transactionId: _root_.scala.Predef.String = "",
    sagaStep: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.None,
    replyToPath: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[StartCommandPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transactionId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (sagaStep.isDefined) {
        val __value = sagaStep.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      
      {
        val __value = replyToPath
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(3, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transactionId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      sagaStep.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = replyToPath
        if (!__v.isEmpty) {
          _output__.writeString(3, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withTransactionId(__v: _root_.scala.Predef.String): StartCommandPO = copy(transactionId = __v)
    def getSagaStep: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO = sagaStep.getOrElse(net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO.defaultInstance)
    def clearSagaStep: StartCommandPO = copy(sagaStep = _root_.scala.None)
    def withSagaStep(__v: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO): StartCommandPO = copy(sagaStep = Option(__v))
    def withReplyToPath(__v: _root_.scala.Predef.String): StartCommandPO = copy(replyToPath = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transactionId
          if (__t != "") __t else null
        }
        case 2 => sagaStep.orNull
        case 3 => {
          val __t = replyToPath
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transactionId)
        case 2 => sagaStep.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => _root_.scalapb.descriptors.PString(replyToPath)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.StartCommandPO.type = net.imadz.infra.saga.proto.saga_v2.StartCommandPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.StartCommandPO])
}

object StartCommandPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.StartCommandPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.StartCommandPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.StartCommandPO = {
    var __transactionId: _root_.scala.Predef.String = ""
    var __sagaStep: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.None
    var __replyToPath: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transactionId = _input__.readStringRequireUtf8()
        case 18 =>
          __sagaStep = Option(__sagaStep.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 26 =>
          __replyToPath = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.StartCommandPO(
        transactionId = __transactionId,
        sagaStep = __sagaStep,
        replyToPath = __replyToPath,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.StartCommandPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.StartCommandPO(
        transactionId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        sagaStep = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]]),
        replyToPath = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(9)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(9)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.StartCommandPO(
    transactionId = "",
    sagaStep = _root_.scala.None,
    replyToPath = ""
  )
  implicit class StartCommandPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StartCommandPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StartCommandPO](_l) {
    def transactionId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transactionId)((c_, f_) => c_.copy(transactionId = f_))
    def sagaStep: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = field(_.getSagaStep)((c_, f_) => c_.copy(sagaStep = Option(f_)))
    def optionalSagaStep: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]] = field(_.sagaStep)((c_, f_) => c_.copy(sagaStep = f_))
    def replyToPath: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.replyToPath)((c_, f_) => c_.copy(replyToPath = f_))
  }
  final val TRANSACTION_ID_FIELD_NUMBER = 1
  final val SAGA_STEP_FIELD_NUMBER = 2
  final val REPLYTOPATH_FIELD_NUMBER = 3
  def of(
    transactionId: _root_.scala.Predef.String,
    sagaStep: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO],
    replyToPath: _root_.scala.Predef.String
  ): _root_.net.imadz.infra.saga.proto.saga_v2.StartCommandPO = _root_.net.imadz.infra.saga.proto.saga_v2.StartCommandPO(
    transactionId,
    sagaStep,
    replyToPath
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.StartCommandPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\StartTransactionPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

/** Commands
  */
@SerialVersionUID(0L)
final case class StartTransactionPO(
    transactionId: _root_.scala.Predef.String = "",
    steps: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.Seq.empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[StartTransactionPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transactionId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      steps.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transactionId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      steps.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withTransactionId(__v: _root_.scala.Predef.String): StartTransactionPO = copy(transactionId = __v)
    def clearSteps = copy(steps = _root_.scala.Seq.empty)
    def addSteps(__vs: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO *): StartTransactionPO = addAllSteps(__vs)
    def addAllSteps(__vs: Iterable[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]): StartTransactionPO = copy(steps = steps ++ __vs)
    def withSteps(__v: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]): StartTransactionPO = copy(steps = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transactionId
          if (__t != "") __t else null
        }
        case 2 => steps
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transactionId)
        case 2 => _root_.scalapb.descriptors.PRepeated(steps.iterator.map(_.toPMessage).toVector)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.StartTransactionPO.type = net.imadz.infra.saga.proto.saga_v2.StartTransactionPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.StartTransactionPO])
}

object StartTransactionPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.StartTransactionPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.StartTransactionPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.StartTransactionPO = {
    var __transactionId: _root_.scala.Predef.String = ""
    val __steps: _root_.scala.collection.immutable.VectorBuilder[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = new _root_.scala.collection.immutable.VectorBuilder[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transactionId = _input__.readStringRequireUtf8()
        case 18 =>
          __steps += _root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO](_input__)
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.StartTransactionPO(
        transactionId = __transactionId,
        steps = __steps.result(),
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.StartTransactionPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.StartTransactionPO(
        transactionId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        steps = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]]).getOrElse(_root_.scala.Seq.empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(16)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(16)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.StartTransactionPO(
    transactionId = "",
    steps = _root_.scala.Seq.empty
  )
  implicit class StartTransactionPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StartTransactionPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StartTransactionPO](_l) {
    def transactionId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transactionId)((c_, f_) => c_.copy(transactionId = f_))
    def steps: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]] = field(_.steps)((c_, f_) => c_.copy(steps = f_))
  }
  final val TRANSACTION_ID_FIELD_NUMBER = 1
  final val STEPS_FIELD_NUMBER = 2
  def of(
    transactionId: _root_.scala.Predef.String,
    steps: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]
  ): _root_.net.imadz.infra.saga.proto.saga_v2.StartTransactionPO = _root_.net.imadz.infra.saga.proto.saga_v2.StartTransactionPO(
    transactionId,
    steps
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.StartTransactionPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\StepExecutorEventPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class StepExecutorEventPO(
    event: net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[StepExecutorEventPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (event.started.isDefined) {
        val __value = event.started.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.succeed.isDefined) {
        val __value = event.succeed.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.failed.isDefined) {
        val __value = event.failed.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.rescheduled.isDefined) {
        val __value = event.rescheduled.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      event.started.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.succeed.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.failed.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.rescheduled.foreach { __v =>
        val __m = __v
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getStarted: net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO = event.started.getOrElse(net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO.defaultInstance)
    def withStarted(__v: net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO): StepExecutorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Started(__v))
    def getSucceed: net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO = event.succeed.getOrElse(net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO.defaultInstance)
    def withSucceed(__v: net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO): StepExecutorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Succeed(__v))
    def getFailed: net.imadz.infra.saga.proto.saga_v2.OperationFailedPO = event.failed.getOrElse(net.imadz.infra.saga.proto.saga_v2.OperationFailedPO.defaultInstance)
    def withFailed(__v: net.imadz.infra.saga.proto.saga_v2.OperationFailedPO): StepExecutorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Failed(__v))
    def getRescheduled: net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO = event.rescheduled.getOrElse(net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO.defaultInstance)
    def withRescheduled(__v: net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO): StepExecutorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Rescheduled(__v))
    def clearEvent: StepExecutorEventPO = copy(event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Empty)
    def withEvent(__v: net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event): StepExecutorEventPO = copy(event = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => event.started.orNull
        case 2 => event.succeed.orNull
        case 3 => event.failed.orNull
        case 4 => event.rescheduled.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => event.started.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => event.succeed.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => event.failed.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => event.rescheduled.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.type = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.StepExecutorEventPO])
}

object StepExecutorEventPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO = {
    var __event: net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Empty
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Started(__event.started.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 18 =>
          __event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Succeed(__event.succeed.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 26 =>
          __event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Failed(__event.failed.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.OperationFailedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 34 =>
          __event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Rescheduled(__event.rescheduled.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO(
        event = __event,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO(
        event = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO]]).map(net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Started(_))
            .orElse[net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO]]).map(net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Succeed(_)))
            .orElse[net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationFailedPO]]).map(net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Failed(_)))
            .orElse[net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO]]).map(net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Rescheduled(_)))
            .getOrElse(net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(8)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(8)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO
      case 3 => __out = net.imadz.infra.saga.proto.saga_v2.OperationFailedPO
      case 4 => __out = net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO(
    event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Empty
  )
  sealed trait Event extends _root_.scalapb.GeneratedOneof {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isStarted: _root_.scala.Boolean = false
    def isSucceed: _root_.scala.Boolean = false
    def isFailed: _root_.scala.Boolean = false
    def isRescheduled: _root_.scala.Boolean = false
    def started: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO] = _root_.scala.None
    def succeed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO] = _root_.scala.None
    def failed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationFailedPO] = _root_.scala.None
    def rescheduled: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO] = _root_.scala.None
  }
  object Event {
    @SerialVersionUID(0L)
    case object Empty extends net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class Started(value: net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO) extends net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO
      override def isStarted: _root_.scala.Boolean = true
      override def started: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO] = Some(value)
      override def number: _root_.scala.Int = 1
    }
    @SerialVersionUID(0L)
    final case class Succeed(value: net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO) extends net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO
      override def isSucceed: _root_.scala.Boolean = true
      override def succeed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO] = Some(value)
      override def number: _root_.scala.Int = 2
    }
    @SerialVersionUID(0L)
    final case class Failed(value: net.imadz.infra.saga.proto.saga_v2.OperationFailedPO) extends net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.OperationFailedPO
      override def isFailed: _root_.scala.Boolean = true
      override def failed: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.OperationFailedPO] = Some(value)
      override def number: _root_.scala.Int = 3
    }
    @SerialVersionUID(0L)
    final case class Rescheduled(value: net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO) extends net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event {
      type ValueType = net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO
      override def isRescheduled: _root_.scala.Boolean = true
      override def rescheduled: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO] = Some(value)
      override def number: _root_.scala.Int = 4
    }
  }
  implicit class StepExecutorEventPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO](_l) {
    def started: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.ExecutionStartedPO] = field(_.getStarted)((c_, f_) => c_.copy(event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Started(f_)))
    def succeed: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationSucceededPO] = field(_.getSucceed)((c_, f_) => c_.copy(event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Succeed(f_)))
    def failed: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.OperationFailedPO] = field(_.getFailed)((c_, f_) => c_.copy(event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Failed(f_)))
    def rescheduled: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryScheduledPO] = field(_.getRescheduled)((c_, f_) => c_.copy(event = net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event.Rescheduled(f_)))
    def event: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event] = field(_.event)((c_, f_) => c_.copy(event = f_))
  }
  final val STARTED_FIELD_NUMBER = 1
  final val SUCCEED_FIELD_NUMBER = 2
  final val FAILED_FIELD_NUMBER = 3
  final val RESCHEDULED_FIELD_NUMBER = 4
  def of(
    event: net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO.Event
  ): _root_.net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO = _root_.net.imadz.infra.saga.proto.saga_v2.StepExecutorEventPO(
    event
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.StepExecutorEventPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\StepStatePO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class StepStatePO(
    step: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.None,
    transactionId: _root_.scala.Predef.String = "",
    status: net.imadz.infra.saga.proto.saga_v2.StepStatusPO = net.imadz.infra.saga.proto.saga_v2.StepStatusPO.CREATED,
    retries: _root_.scala.Int = 0,
    lastError: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = _root_.scala.None,
    circuitBreakerOpen: _root_.scala.Boolean = false,
    replyToPath: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[StepStatePO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (step.isDefined) {
        val __value = step.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      
      {
        val __value = transactionId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      
      {
        val __value = status.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(3, __value)
        }
      };
      
      {
        val __value = retries
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(4, __value)
        }
      };
      if (lastError.isDefined) {
        val __value = lastError.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      
      {
        val __value = circuitBreakerOpen
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(6, __value)
        }
      };
      
      {
        val __value = replyToPath
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(7, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      step.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = transactionId
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      {
        val __v = status.value
        if (__v != 0) {
          _output__.writeEnum(3, __v)
        }
      };
      {
        val __v = retries
        if (__v != 0) {
          _output__.writeInt32(4, __v)
        }
      };
      lastError.foreach { __v =>
        val __m = __v
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = circuitBreakerOpen
        if (__v != false) {
          _output__.writeBool(6, __v)
        }
      };
      {
        val __v = replyToPath
        if (!__v.isEmpty) {
          _output__.writeString(7, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def getStep: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO = step.getOrElse(net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO.defaultInstance)
    def clearStep: StepStatePO = copy(step = _root_.scala.None)
    def withStep(__v: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO): StepStatePO = copy(step = Option(__v))
    def withTransactionId(__v: _root_.scala.Predef.String): StepStatePO = copy(transactionId = __v)
    def withStatus(__v: net.imadz.infra.saga.proto.saga_v2.StepStatusPO): StepStatePO = copy(status = __v)
    def withRetries(__v: _root_.scala.Int): StepStatePO = copy(retries = __v)
    def getLastError: net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO = lastError.getOrElse(net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO.defaultInstance)
    def clearLastError: StepStatePO = copy(lastError = _root_.scala.None)
    def withLastError(__v: net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO): StepStatePO = copy(lastError = Option(__v))
    def withCircuitBreakerOpen(__v: _root_.scala.Boolean): StepStatePO = copy(circuitBreakerOpen = __v)
    def withReplyToPath(__v: _root_.scala.Predef.String): StepStatePO = copy(replyToPath = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => step.orNull
        case 2 => {
          val __t = transactionId
          if (__t != "") __t else null
        }
        case 3 => {
          val __t = status.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
        case 4 => {
          val __t = retries
          if (__t != 0) __t else null
        }
        case 5 => lastError.orNull
        case 6 => {
          val __t = circuitBreakerOpen
          if (__t != false) __t else null
        }
        case 7 => {
          val __t = replyToPath
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => step.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => _root_.scalapb.descriptors.PString(transactionId)
        case 3 => _root_.scalapb.descriptors.PEnum(status.scalaValueDescriptor)
        case 4 => _root_.scalapb.descriptors.PInt(retries)
        case 5 => lastError.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 6 => _root_.scalapb.descriptors.PBoolean(circuitBreakerOpen)
        case 7 => _root_.scalapb.descriptors.PString(replyToPath)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.StepStatePO.type = net.imadz.infra.saga.proto.saga_v2.StepStatePO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.StepStatePO])
}

object StepStatePO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.StepStatePO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.StepStatePO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.StepStatePO = {
    var __step: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.None
    var __transactionId: _root_.scala.Predef.String = ""
    var __status: net.imadz.infra.saga.proto.saga_v2.StepStatusPO = net.imadz.infra.saga.proto.saga_v2.StepStatusPO.CREATED
    var __retries: _root_.scala.Int = 0
    var __lastError: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = _root_.scala.None
    var __circuitBreakerOpen: _root_.scala.Boolean = false
    var __replyToPath: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __step = Option(__step.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 18 =>
          __transactionId = _input__.readStringRequireUtf8()
        case 24 =>
          __status = net.imadz.infra.saga.proto.saga_v2.StepStatusPO.fromValue(_input__.readEnum())
        case 32 =>
          __retries = _input__.readInt32()
        case 42 =>
          __lastError = Option(__lastError.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 48 =>
          __circuitBreakerOpen = _input__.readBool()
        case 58 =>
          __replyToPath = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.StepStatePO(
        step = __step,
        transactionId = __transactionId,
        status = __status,
        retries = __retries,
        lastError = __lastError,
        circuitBreakerOpen = __circuitBreakerOpen,
        replyToPath = __replyToPath,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.StepStatePO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.StepStatePO(
        step = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]]),
        transactionId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        status = net.imadz.infra.saga.proto.saga_v2.StepStatusPO.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(net.imadz.infra.saga.proto.saga_v2.StepStatusPO.CREATED.scalaValueDescriptor).number),
        retries = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scala.Int]).getOrElse(0),
        lastError = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[_root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO]]),
        circuitBreakerOpen = __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).map(_.as[_root_.scala.Boolean]).getOrElse(false),
        replyToPath = __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(2)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(2)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO
      case 5 => __out = net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 3 => net.imadz.infra.saga.proto.saga_v2.StepStatusPO
    }
  }
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.StepStatePO(
    step = _root_.scala.None,
    transactionId = "",
    status = net.imadz.infra.saga.proto.saga_v2.StepStatusPO.CREATED,
    retries = 0,
    lastError = _root_.scala.None,
    circuitBreakerOpen = false,
    replyToPath = ""
  )
  implicit class StepStatePOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StepStatePO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StepStatePO](_l) {
    def step: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = field(_.getStep)((c_, f_) => c_.copy(step = Option(f_)))
    def optionalStep: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]] = field(_.step)((c_, f_) => c_.copy(step = f_))
    def transactionId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transactionId)((c_, f_) => c_.copy(transactionId = f_))
    def status: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.StepStatusPO] = field(_.status)((c_, f_) => c_.copy(status = f_))
    def retries: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.retries)((c_, f_) => c_.copy(retries = f_))
    def lastError: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO] = field(_.getLastError)((c_, f_) => c_.copy(lastError = Option(f_)))
    def optionalLastError: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO]] = field(_.lastError)((c_, f_) => c_.copy(lastError = f_))
    def circuitBreakerOpen: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.circuitBreakerOpen)((c_, f_) => c_.copy(circuitBreakerOpen = f_))
    def replyToPath: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.replyToPath)((c_, f_) => c_.copy(replyToPath = f_))
  }
  final val STEP_FIELD_NUMBER = 1
  final val TRANSACTION_ID_FIELD_NUMBER = 2
  final val STATUS_FIELD_NUMBER = 3
  final val RETRIES_FIELD_NUMBER = 4
  final val LAST_ERROR_FIELD_NUMBER = 5
  final val CIRCUIT_BREAKER_OPEN_FIELD_NUMBER = 6
  final val REPLYTOPATH_FIELD_NUMBER = 7
  def of(
    step: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO],
    transactionId: _root_.scala.Predef.String,
    status: net.imadz.infra.saga.proto.saga_v2.StepStatusPO,
    retries: _root_.scala.Int,
    lastError: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.RetryableOrNotExceptionPO],
    circuitBreakerOpen: _root_.scala.Boolean,
    replyToPath: _root_.scala.Predef.String
  ): _root_.net.imadz.infra.saga.proto.saga_v2.StepStatePO = _root_.net.imadz.infra.saga.proto.saga_v2.StepStatePO(
    step,
    transactionId,
    status,
    retries,
    lastError,
    circuitBreakerOpen,
    replyToPath
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.StepStatePO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\StepStatusPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

sealed abstract class StepStatusPO(val value: _root_.scala.Int) extends _root_.scalapb.GeneratedEnum {
  type EnumType = net.imadz.infra.saga.proto.saga_v2.StepStatusPO
  type RecognizedType = net.imadz.infra.saga.proto.saga_v2.StepStatusPO.Recognized
  def isCreated: _root_.scala.Boolean = false
  def isOngoing: _root_.scala.Boolean = false
  def isSucceed: _root_.scala.Boolean = false
  def isFailed: _root_.scala.Boolean = false
  def companion: _root_.scalapb.GeneratedEnumCompanion[StepStatusPO] = net.imadz.infra.saga.proto.saga_v2.StepStatusPO
  final def asRecognized: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.StepStatusPO.Recognized] = if (isUnrecognized) _root_.scala.None else _root_.scala.Some(this.asInstanceOf[net.imadz.infra.saga.proto.saga_v2.StepStatusPO.Recognized])
}

object StepStatusPO extends _root_.scalapb.GeneratedEnumCompanion[StepStatusPO] {
  sealed trait Recognized extends StepStatusPO
  implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[StepStatusPO] = this
  
  @SerialVersionUID(0L)
  case object CREATED extends StepStatusPO(0) with StepStatusPO.Recognized {
    val index = 0
    val name = "CREATED"
    override def isCreated: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object ONGOING extends StepStatusPO(1) with StepStatusPO.Recognized {
    val index = 1
    val name = "ONGOING"
    override def isOngoing: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object SUCCEED extends StepStatusPO(2) with StepStatusPO.Recognized {
    val index = 2
    val name = "SUCCEED"
    override def isSucceed: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object FAILED extends StepStatusPO(3) with StepStatusPO.Recognized {
    val index = 3
    val name = "FAILED"
    override def isFailed: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  final case class Unrecognized(unrecognizedValue: _root_.scala.Int) extends StepStatusPO(unrecognizedValue) with _root_.scalapb.UnrecognizedEnum
  lazy val values: scala.collection.immutable.Seq[ValueType] = scala.collection.immutable.Seq(CREATED, ONGOING, SUCCEED, FAILED)
  def fromValue(__value: _root_.scala.Int): StepStatusPO = __value match {
    case 0 => CREATED
    case 1 => ONGOING
    case 2 => SUCCEED
    case 3 => FAILED
    case __other => Unrecognized(__other)
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = SagaV2Proto.javaDescriptor.getEnumTypes().get(1)
  def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = SagaV2Proto.scalaDescriptor.enums(1)
}

==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\TimedOutCommandPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class TimedOutCommandPO(
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TimedOutCommandPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      unknownFields.writeTo(_output__)
    }
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = throw new MatchError(__fieldNumber)
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = throw new MatchError(__field)
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO.type = net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.TimedOutCommandPO])
}

object TimedOutCommandPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO = {
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO(
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO(
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(15)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(15)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO(
  )
  implicit class TimedOutCommandPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO](_l) {
  }
  def of(
  ): _root_.net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO = _root_.net.imadz.infra.saga.proto.saga_v2.TimedOutCommandPO(
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.TimedOutCommandPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\TransactionCompletedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class TransactionCompletedPO(
    transactionId: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionCompletedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transactionId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transactionId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withTransactionId(__v: _root_.scala.Predef.String): TransactionCompletedPO = copy(transactionId = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transactionId
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transactionId)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO.type = net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.TransactionCompletedPO])
}

object TransactionCompletedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO = {
    var __transactionId: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transactionId = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO(
        transactionId = __transactionId,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO(
        transactionId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(23)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(23)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO(
    transactionId = ""
  )
  implicit class TransactionCompletedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO](_l) {
    def transactionId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transactionId)((c_, f_) => c_.copy(transactionId = f_))
  }
  final val TRANSACTION_ID_FIELD_NUMBER = 1
  def of(
    transactionId: _root_.scala.Predef.String
  ): _root_.net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO = _root_.net.imadz.infra.saga.proto.saga_v2.TransactionCompletedPO(
    transactionId
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.TransactionCompletedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\TransactionFailedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

@SerialVersionUID(0L)
final case class TransactionFailedPO(
    transactionId: _root_.scala.Predef.String = "",
    reason: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionFailedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transactionId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = reason
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transactionId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = reason
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withTransactionId(__v: _root_.scala.Predef.String): TransactionFailedPO = copy(transactionId = __v)
    def withReason(__v: _root_.scala.Predef.String): TransactionFailedPO = copy(reason = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transactionId
          if (__t != "") __t else null
        }
        case 2 => {
          val __t = reason
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transactionId)
        case 2 => _root_.scalapb.descriptors.PString(reason)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO.type = net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.TransactionFailedPO])
}

object TransactionFailedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO = {
    var __transactionId: _root_.scala.Predef.String = ""
    var __reason: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transactionId = _input__.readStringRequireUtf8()
        case 18 =>
          __reason = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO(
        transactionId = __transactionId,
        reason = __reason,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO(
        transactionId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        reason = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(24)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(24)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO(
    transactionId = "",
    reason = ""
  )
  implicit class TransactionFailedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO](_l) {
    def transactionId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transactionId)((c_, f_) => c_.copy(transactionId = f_))
    def reason: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.reason)((c_, f_) => c_.copy(reason = f_))
  }
  final val TRANSACTION_ID_FIELD_NUMBER = 1
  final val REASON_FIELD_NUMBER = 2
  def of(
    transactionId: _root_.scala.Predef.String,
    reason: _root_.scala.Predef.String
  ): _root_.net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO = _root_.net.imadz.infra.saga.proto.saga_v2.TransactionFailedPO(
    transactionId,
    reason
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.TransactionFailedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\TransactionPhasePO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

/** Enums
  */
sealed abstract class TransactionPhasePO(val value: _root_.scala.Int) extends _root_.scalapb.GeneratedEnum {
  type EnumType = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
  type RecognizedType = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.Recognized
  def isPreparePhase: _root_.scala.Boolean = false
  def isCommitPhase: _root_.scala.Boolean = false
  def isCompensatePhase: _root_.scala.Boolean = false
  def companion: _root_.scalapb.GeneratedEnumCompanion[TransactionPhasePO] = net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO
  final def asRecognized: _root_.scala.Option[net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.Recognized] = if (isUnrecognized) _root_.scala.None else _root_.scala.Some(this.asInstanceOf[net.imadz.infra.saga.proto.saga_v2.TransactionPhasePO.Recognized])
}

object TransactionPhasePO extends _root_.scalapb.GeneratedEnumCompanion[TransactionPhasePO] {
  sealed trait Recognized extends TransactionPhasePO
  implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[TransactionPhasePO] = this
  
  @SerialVersionUID(0L)
  case object PREPARE_PHASE extends TransactionPhasePO(0) with TransactionPhasePO.Recognized {
    val index = 0
    val name = "PREPARE_PHASE"
    override def isPreparePhase: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object COMMIT_PHASE extends TransactionPhasePO(1) with TransactionPhasePO.Recognized {
    val index = 1
    val name = "COMMIT_PHASE"
    override def isCommitPhase: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object COMPENSATE_PHASE extends TransactionPhasePO(2) with TransactionPhasePO.Recognized {
    val index = 2
    val name = "COMPENSATE_PHASE"
    override def isCompensatePhase: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  final case class Unrecognized(unrecognizedValue: _root_.scala.Int) extends TransactionPhasePO(unrecognizedValue) with _root_.scalapb.UnrecognizedEnum
  lazy val values: scala.collection.immutable.Seq[ValueType] = scala.collection.immutable.Seq(PREPARE_PHASE, COMMIT_PHASE, COMPENSATE_PHASE)
  def fromValue(__value: _root_.scala.Int): TransactionPhasePO = __value match {
    case 0 => PREPARE_PHASE
    case 1 => COMMIT_PHASE
    case 2 => COMPENSATE_PHASE
    case __other => Unrecognized(__other)
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = SagaV2Proto.javaDescriptor.getEnumTypes().get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = SagaV2Proto.scalaDescriptor.enums(0)
}

==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2\TransactionStartedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2

/** Events
  */
@SerialVersionUID(0L)
final case class TransactionStartedPO(
    transactionId: _root_.scala.Predef.String = "",
    steps: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = _root_.scala.Seq.empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionStartedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transactionId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      steps.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transactionId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      steps.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withTransactionId(__v: _root_.scala.Predef.String): TransactionStartedPO = copy(transactionId = __v)
    def clearSteps = copy(steps = _root_.scala.Seq.empty)
    def addSteps(__vs: net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO *): TransactionStartedPO = addAllSteps(__vs)
    def addAllSteps(__vs: Iterable[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]): TransactionStartedPO = copy(steps = steps ++ __vs)
    def withSteps(__v: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]): TransactionStartedPO = copy(steps = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transactionId
          if (__t != "") __t else null
        }
        case 2 => steps
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transactionId)
        case 2 => _root_.scalapb.descriptors.PRepeated(steps.iterator.map(_.toPMessage).toVector)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO.type = net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.TransactionStartedPO])
}

object TransactionStartedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO = {
    var __transactionId: _root_.scala.Predef.String = ""
    val __steps: _root_.scala.collection.immutable.VectorBuilder[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO] = new _root_.scala.collection.immutable.VectorBuilder[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transactionId = _input__.readStringRequireUtf8()
        case 18 =>
          __steps += _root_.scalapb.LiteParser.readMessage[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO](_input__)
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO(
        transactionId = __transactionId,
        steps = __steps.result(),
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO(
        transactionId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        steps = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]]).getOrElse(_root_.scala.Seq.empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2Proto.javaDescriptor.getMessageTypes().get(20)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2Proto.scalaDescriptor.messages(20)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO(
    transactionId = "",
    steps = _root_.scala.Seq.empty
  )
  implicit class TransactionStartedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO](_l) {
    def transactionId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transactionId)((c_, f_) => c_.copy(transactionId = f_))
    def steps: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]] = field(_.steps)((c_, f_) => c_.copy(steps = f_))
  }
  final val TRANSACTION_ID_FIELD_NUMBER = 1
  final val STEPS_FIELD_NUMBER = 2
  def of(
    transactionId: _root_.scala.Predef.String,
    steps: _root_.scala.Seq[net.imadz.infra.saga.proto.saga_v2.SagaTransactionStepPO]
  ): _root_.net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO = _root_.net.imadz.infra.saga.proto.saga_v2.TransactionStartedPO(
    transactionId,
    steps
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.TransactionStartedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2_test\AlwaysFailingParticipant.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2_test

@SerialVersionUID(0L)
final case class AlwaysFailingParticipant(
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[AlwaysFailingParticipant] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      unknownFields.writeTo(_output__)
    }
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = throw new MatchError(__fieldNumber)
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = throw new MatchError(__field)
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant.type = net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.AlwaysFailingParticipant])
}

object AlwaysFailingParticipant extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant = {
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant(
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant(
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2TestProto.javaDescriptor.getMessageTypes().get(3)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2TestProto.scalaDescriptor.messages(3)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant(
  )
  implicit class AlwaysFailingParticipantLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant](_l) {
  }
  def of(
  ): _root_.net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant = _root_.net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant(
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.AlwaysFailingParticipant])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2_test\NonRetryableFailingParticipant.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2_test

@SerialVersionUID(0L)
final case class NonRetryableFailingParticipant(
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[NonRetryableFailingParticipant] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      unknownFields.writeTo(_output__)
    }
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = throw new MatchError(__fieldNumber)
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = throw new MatchError(__field)
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant.type = net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.NonRetryableFailingParticipant])
}

object NonRetryableFailingParticipant extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant = {
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant(
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant(
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2TestProto.javaDescriptor.getMessageTypes().get(4)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2TestProto.scalaDescriptor.messages(4)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant(
  )
  implicit class NonRetryableFailingParticipantLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant](_l) {
  }
  def of(
  ): _root_.net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant = _root_.net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant(
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.NonRetryableFailingParticipant])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2_test\RetryingParticipant.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2_test

@SerialVersionUID(0L)
final case class RetryingParticipant(
    succeedAfter: _root_.scala.Int = 0,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[RetryingParticipant] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = succeedAfter
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = succeedAfter
        if (__v != 0) {
          _output__.writeInt32(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withSucceedAfter(__v: _root_.scala.Int): RetryingParticipant = copy(succeedAfter = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = succeedAfter
          if (__t != 0) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PInt(succeedAfter)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant.type = net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.RetryingParticipant])
}

object RetryingParticipant extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant = {
    var __succeedAfter: _root_.scala.Int = 0
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 8 =>
          __succeedAfter = _input__.readInt32()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant(
        succeedAfter = __succeedAfter,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant(
        succeedAfter = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Int]).getOrElse(0)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2TestProto.javaDescriptor.getMessageTypes().get(1)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2TestProto.scalaDescriptor.messages(1)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant(
    succeedAfter = 0
  )
  implicit class RetryingParticipantLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant](_l) {
    def succeedAfter: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.succeedAfter)((c_, f_) => c_.copy(succeedAfter = f_))
  }
  final val SUCCEED_AFTER_FIELD_NUMBER = 1
  def of(
    succeedAfter: _root_.scala.Int
  ): _root_.net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant = _root_.net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant(
    succeedAfter
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.RetryingParticipant])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2_test\SagaV2TestProto.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2_test

object SagaV2TestProto extends _root_.scalapb.GeneratedFileObject {
  lazy val dependencies: Seq[_root_.scalapb.GeneratedFileObject] = Seq.empty
  lazy val messagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] =
    Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]](
      net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant,
      net.imadz.infra.saga.proto.saga_v2_test.RetryingParticipant,
      net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant,
      net.imadz.infra.saga.proto.saga_v2_test.AlwaysFailingParticipant,
      net.imadz.infra.saga.proto.saga_v2_test.NonRetryableFailingParticipant
    )
  private lazy val ProtoBytes: _root_.scala.Array[Byte] =
      scalapb.Encoding.fromBase64(scala.collection.immutable.Seq(
  """ChJzYWdhX3YyX3Rlc3QucHJvdG8SFG5ldC5pbWFkei5pbmZyYS5zYWdhIhcKFVN1Y2Nlc3NmdWxQYXJ0aWNpcGFudCJNChNSZ
  XRyeWluZ1BhcnRpY2lwYW50EjYKDXN1Y2NlZWRfYWZ0ZXIYASABKAVCEeI/DhIMc3VjY2VlZEFmdGVyUgxzdWNjZWVkQWZ0ZXIiF
  AoSVGltZW91dFBhcnRpY2lwYW50IhoKGEFsd2F5c0ZhaWxpbmdQYXJ0aWNpcGFudCIgCh5Ob25SZXRyeWFibGVGYWlsaW5nUGFyd
  GljaXBhbnRCHgoabmV0LmltYWR6LmluZnJhLnNhZ2EucHJvdG9QAWIGcHJvdG8z"""
      ).mkString)
  lazy val scalaDescriptor: _root_.scalapb.descriptors.FileDescriptor = {
    val scalaProto = com.google.protobuf.descriptor.FileDescriptorProto.parseFrom(ProtoBytes)
    _root_.scalapb.descriptors.FileDescriptor.buildFrom(scalaProto, dependencies.map(_.scalaDescriptor))
  }
  lazy val javaDescriptor: com.google.protobuf.Descriptors.FileDescriptor = {
    val javaProto = com.google.protobuf.DescriptorProtos.FileDescriptorProto.parseFrom(ProtoBytes)
    com.google.protobuf.Descriptors.FileDescriptor.buildFrom(javaProto, _root_.scala.Array(
    ))
  }
  @deprecated("Use javaDescriptor instead. In a future version this will refer to scalaDescriptor.", "ScalaPB 0.5.47")
  def descriptor: com.google.protobuf.Descriptors.FileDescriptor = javaDescriptor
}

==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2_test\SuccessfulParticipant.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2_test

/** Participant definitions for testing
  */
@SerialVersionUID(0L)
final case class SuccessfulParticipant(
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[SuccessfulParticipant] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      unknownFields.writeTo(_output__)
    }
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = throw new MatchError(__fieldNumber)
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = throw new MatchError(__field)
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant.type = net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.SuccessfulParticipant])
}

object SuccessfulParticipant extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant = {
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant(
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant(
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2TestProto.javaDescriptor.getMessageTypes().get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2TestProto.scalaDescriptor.messages(0)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant(
  )
  implicit class SuccessfulParticipantLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant](_l) {
  }
  def of(
  ): _root_.net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant = _root_.net.imadz.infra.saga.proto.saga_v2_test.SuccessfulParticipant(
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.SuccessfulParticipant])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infra\saga\proto\saga_v2_test\TimeoutParticipant.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infra.saga.proto.saga_v2_test

@SerialVersionUID(0L)
final case class TimeoutParticipant(
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TimeoutParticipant] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      unknownFields.writeTo(_output__)
    }
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = throw new MatchError(__fieldNumber)
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = throw new MatchError(__field)
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant.type = net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infra.saga.TimeoutParticipant])
}

object TimeoutParticipant extends scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant = {
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant(
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant(
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaV2TestProto.javaDescriptor.getMessageTypes().get(2)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaV2TestProto.scalaDescriptor.messages(2)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant(
  )
  implicit class TimeoutParticipantLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant](_l) {
  }
  def of(
  ): _root_.net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant = _root_.net.imadz.infra.saga.proto.saga_v2_test.TimeoutParticipant(
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infra.saga.TimeoutParticipant])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\BalanceChanged.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the BalanceChanged event
  */
@SerialVersionUID(0L)
final case class BalanceChanged(
    update: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
    timestamp: _root_.scala.Long = 0L,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[BalanceChanged] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (update.isDefined) {
        val __value = update.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      
      {
        val __value = timestamp
        if (__value != 0L) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(2, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      update.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = timestamp
        if (__v != 0L) {
          _output__.writeInt64(2, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def getUpdate: net.imadz.infrastructure.proto.credits.MoneyPO = update.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
    def clearUpdate: BalanceChanged = copy(update = _root_.scala.None)
    def withUpdate(__v: net.imadz.infrastructure.proto.credits.MoneyPO): BalanceChanged = copy(update = Option(__v))
    def withTimestamp(__v: _root_.scala.Long): BalanceChanged = copy(timestamp = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => update.orNull
        case 2 => {
          val __t = timestamp
          if (__t != 0L) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => update.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => _root_.scalapb.descriptors.PLong(timestamp)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.BalanceChanged.type = net.imadz.infrastructure.proto.credits.BalanceChanged
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.BalanceChanged])
}

object BalanceChanged extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.BalanceChanged] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.BalanceChanged] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.BalanceChanged = {
    var __update: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
    var __timestamp: _root_.scala.Long = 0L
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __update = Option(__update.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 16 =>
          __timestamp = _input__.readInt64()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.BalanceChanged(
        update = __update,
        timestamp = __timestamp,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.BalanceChanged] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.BalanceChanged(
        update = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]]),
        timestamp = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Long]).getOrElse(0L)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(1)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(1)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.BalanceChanged(
    update = _root_.scala.None,
    timestamp = 0L
  )
  implicit class BalanceChangedLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.BalanceChanged]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.BalanceChanged](_l) {
    def update: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getUpdate)((c_, f_) => c_.copy(update = Option(f_)))
    def optionalUpdate: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.update)((c_, f_) => c_.copy(update = f_))
    def timestamp: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.timestamp)((c_, f_) => c_.copy(timestamp = f_))
  }
  final val UPDATE_FIELD_NUMBER = 1
  final val TIMESTAMP_FIELD_NUMBER = 2
  def of(
    update: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO],
    timestamp: _root_.scala.Long
  ): _root_.net.imadz.infrastructure.proto.credits.BalanceChanged = _root_.net.imadz.infrastructure.proto.credits.BalanceChanged(
    update,
    timestamp
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.BalanceChanged])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\CreditBalanceEventPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the CreditBalanceEvent union
  */
@SerialVersionUID(0L)
final case class CreditBalanceEventPO(
    event: net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.Empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[CreditBalanceEventPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (event.balanceChanged.isDefined) {
        val __value = event.balanceChanged.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.fundsReserved.isDefined) {
        val __value = event.fundsReserved.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.fundsDeducted.isDefined) {
        val __value = event.fundsDeducted.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.reservationReleased.isDefined) {
        val __value = event.reservationReleased.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.incomingCreditsRecorded.isDefined) {
        val __value = event.incomingCreditsRecorded.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.incomingCreditsCommited.isDefined) {
        val __value = event.incomingCreditsCommited.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.incomingCreditsCanceled.isDefined) {
        val __value = event.incomingCreditsCanceled.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      event.balanceChanged.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.fundsReserved.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.fundsDeducted.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.reservationReleased.foreach { __v =>
        val __m = __v
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.incomingCreditsRecorded.foreach { __v =>
        val __m = __v
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.incomingCreditsCommited.foreach { __v =>
        val __m = __v
        _output__.writeTag(6, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.incomingCreditsCanceled.foreach { __v =>
        val __m = __v
        _output__.writeTag(7, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getBalanceChanged: net.imadz.infrastructure.proto.credits.BalanceChanged = event.balanceChanged.getOrElse(net.imadz.infrastructure.proto.credits.BalanceChanged.defaultInstance)
    def withBalanceChanged(__v: net.imadz.infrastructure.proto.credits.BalanceChanged): CreditBalanceEventPO = copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.BalanceChanged(__v))
    def getFundsReserved: net.imadz.infrastructure.proto.credits.FundsReserved = event.fundsReserved.getOrElse(net.imadz.infrastructure.proto.credits.FundsReserved.defaultInstance)
    def withFundsReserved(__v: net.imadz.infrastructure.proto.credits.FundsReserved): CreditBalanceEventPO = copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.FundsReserved(__v))
    def getFundsDeducted: net.imadz.infrastructure.proto.credits.FundsDeducted = event.fundsDeducted.getOrElse(net.imadz.infrastructure.proto.credits.FundsDeducted.defaultInstance)
    def withFundsDeducted(__v: net.imadz.infrastructure.proto.credits.FundsDeducted): CreditBalanceEventPO = copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.FundsDeducted(__v))
    def getReservationReleased: net.imadz.infrastructure.proto.credits.ReservationReleased = event.reservationReleased.getOrElse(net.imadz.infrastructure.proto.credits.ReservationReleased.defaultInstance)
    def withReservationReleased(__v: net.imadz.infrastructure.proto.credits.ReservationReleased): CreditBalanceEventPO = copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.ReservationReleased(__v))
    def getIncomingCreditsRecorded: net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded = event.incomingCreditsRecorded.getOrElse(net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded.defaultInstance)
    def withIncomingCreditsRecorded(__v: net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded): CreditBalanceEventPO = copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsRecorded(__v))
    def getIncomingCreditsCommited: net.imadz.infrastructure.proto.credits.IncomingCreditsCommited = event.incomingCreditsCommited.getOrElse(net.imadz.infrastructure.proto.credits.IncomingCreditsCommited.defaultInstance)
    def withIncomingCreditsCommited(__v: net.imadz.infrastructure.proto.credits.IncomingCreditsCommited): CreditBalanceEventPO = copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsCommited(__v))
    def getIncomingCreditsCanceled: net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled = event.incomingCreditsCanceled.getOrElse(net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled.defaultInstance)
    def withIncomingCreditsCanceled(__v: net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled): CreditBalanceEventPO = copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsCanceled(__v))
    def clearEvent: CreditBalanceEventPO = copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.Empty)
    def withEvent(__v: net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event): CreditBalanceEventPO = copy(event = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => event.balanceChanged.orNull
        case 2 => event.fundsReserved.orNull
        case 3 => event.fundsDeducted.orNull
        case 4 => event.reservationReleased.orNull
        case 5 => event.incomingCreditsRecorded.orNull
        case 6 => event.incomingCreditsCommited.orNull
        case 7 => event.incomingCreditsCanceled.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => event.balanceChanged.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => event.fundsReserved.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => event.fundsDeducted.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => event.reservationReleased.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => event.incomingCreditsRecorded.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 6 => event.incomingCreditsCommited.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 7 => event.incomingCreditsCanceled.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.type = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.CreditBalanceEventPO])
}

object CreditBalanceEventPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceEventPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceEventPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.CreditBalanceEventPO = {
    var __event: net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.Empty
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.BalanceChanged(__event.balanceChanged.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.BalanceChanged](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 18 =>
          __event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.FundsReserved(__event.fundsReserved.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.FundsReserved](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 26 =>
          __event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.FundsDeducted(__event.fundsDeducted.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.FundsDeducted](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 34 =>
          __event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.ReservationReleased(__event.reservationReleased.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.ReservationReleased](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 42 =>
          __event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsRecorded(__event.incomingCreditsRecorded.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 50 =>
          __event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsCommited(__event.incomingCreditsCommited.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.IncomingCreditsCommited](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 58 =>
          __event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsCanceled(__event.incomingCreditsCanceled.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.CreditBalanceEventPO(
        event = __event,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.CreditBalanceEventPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.CreditBalanceEventPO(
        event = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.BalanceChanged]]).map(net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.BalanceChanged(_))
            .orElse[net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.FundsReserved]]).map(net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.FundsReserved(_)))
            .orElse[net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.FundsDeducted]]).map(net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.FundsDeducted(_)))
            .orElse[net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.ReservationReleased]]).map(net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.ReservationReleased(_)))
            .orElse[net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded]]).map(net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsRecorded(_)))
            .orElse[net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.IncomingCreditsCommited]]).map(net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsCommited(_)))
            .orElse[net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled]]).map(net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsCanceled(_)))
            .getOrElse(net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.Empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(8)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(8)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = net.imadz.infrastructure.proto.credits.BalanceChanged
      case 2 => __out = net.imadz.infrastructure.proto.credits.FundsReserved
      case 3 => __out = net.imadz.infrastructure.proto.credits.FundsDeducted
      case 4 => __out = net.imadz.infrastructure.proto.credits.ReservationReleased
      case 5 => __out = net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded
      case 6 => __out = net.imadz.infrastructure.proto.credits.IncomingCreditsCommited
      case 7 => __out = net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO(
    event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.Empty
  )
  sealed trait Event extends _root_.scalapb.GeneratedOneof {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isBalanceChanged: _root_.scala.Boolean = false
    def isFundsReserved: _root_.scala.Boolean = false
    def isFundsDeducted: _root_.scala.Boolean = false
    def isReservationReleased: _root_.scala.Boolean = false
    def isIncomingCreditsRecorded: _root_.scala.Boolean = false
    def isIncomingCreditsCommited: _root_.scala.Boolean = false
    def isIncomingCreditsCanceled: _root_.scala.Boolean = false
    def balanceChanged: _root_.scala.Option[net.imadz.infrastructure.proto.credits.BalanceChanged] = _root_.scala.None
    def fundsReserved: _root_.scala.Option[net.imadz.infrastructure.proto.credits.FundsReserved] = _root_.scala.None
    def fundsDeducted: _root_.scala.Option[net.imadz.infrastructure.proto.credits.FundsDeducted] = _root_.scala.None
    def reservationReleased: _root_.scala.Option[net.imadz.infrastructure.proto.credits.ReservationReleased] = _root_.scala.None
    def incomingCreditsRecorded: _root_.scala.Option[net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded] = _root_.scala.None
    def incomingCreditsCommited: _root_.scala.Option[net.imadz.infrastructure.proto.credits.IncomingCreditsCommited] = _root_.scala.None
    def incomingCreditsCanceled: _root_.scala.Option[net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled] = _root_.scala.None
  }
  object Event {
    @SerialVersionUID(0L)
    case object Empty extends net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class BalanceChanged(value: net.imadz.infrastructure.proto.credits.BalanceChanged) extends net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.credits.BalanceChanged
      override def isBalanceChanged: _root_.scala.Boolean = true
      override def balanceChanged: _root_.scala.Option[net.imadz.infrastructure.proto.credits.BalanceChanged] = Some(value)
      override def number: _root_.scala.Int = 1
    }
    @SerialVersionUID(0L)
    final case class FundsReserved(value: net.imadz.infrastructure.proto.credits.FundsReserved) extends net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.credits.FundsReserved
      override def isFundsReserved: _root_.scala.Boolean = true
      override def fundsReserved: _root_.scala.Option[net.imadz.infrastructure.proto.credits.FundsReserved] = Some(value)
      override def number: _root_.scala.Int = 2
    }
    @SerialVersionUID(0L)
    final case class FundsDeducted(value: net.imadz.infrastructure.proto.credits.FundsDeducted) extends net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.credits.FundsDeducted
      override def isFundsDeducted: _root_.scala.Boolean = true
      override def fundsDeducted: _root_.scala.Option[net.imadz.infrastructure.proto.credits.FundsDeducted] = Some(value)
      override def number: _root_.scala.Int = 3
    }
    @SerialVersionUID(0L)
    final case class ReservationReleased(value: net.imadz.infrastructure.proto.credits.ReservationReleased) extends net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.credits.ReservationReleased
      override def isReservationReleased: _root_.scala.Boolean = true
      override def reservationReleased: _root_.scala.Option[net.imadz.infrastructure.proto.credits.ReservationReleased] = Some(value)
      override def number: _root_.scala.Int = 4
    }
    @SerialVersionUID(0L)
    final case class IncomingCreditsRecorded(value: net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded) extends net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded
      override def isIncomingCreditsRecorded: _root_.scala.Boolean = true
      override def incomingCreditsRecorded: _root_.scala.Option[net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded] = Some(value)
      override def number: _root_.scala.Int = 5
    }
    @SerialVersionUID(0L)
    final case class IncomingCreditsCommited(value: net.imadz.infrastructure.proto.credits.IncomingCreditsCommited) extends net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.credits.IncomingCreditsCommited
      override def isIncomingCreditsCommited: _root_.scala.Boolean = true
      override def incomingCreditsCommited: _root_.scala.Option[net.imadz.infrastructure.proto.credits.IncomingCreditsCommited] = Some(value)
      override def number: _root_.scala.Int = 6
    }
    @SerialVersionUID(0L)
    final case class IncomingCreditsCanceled(value: net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled) extends net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled
      override def isIncomingCreditsCanceled: _root_.scala.Boolean = true
      override def incomingCreditsCanceled: _root_.scala.Option[net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled] = Some(value)
      override def number: _root_.scala.Int = 7
    }
  }
  implicit class CreditBalanceEventPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceEventPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceEventPO](_l) {
    def balanceChanged: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.BalanceChanged] = field(_.getBalanceChanged)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.BalanceChanged(f_)))
    def fundsReserved: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.FundsReserved] = field(_.getFundsReserved)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.FundsReserved(f_)))
    def fundsDeducted: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.FundsDeducted] = field(_.getFundsDeducted)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.FundsDeducted(f_)))
    def reservationReleased: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.ReservationReleased] = field(_.getReservationReleased)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.ReservationReleased(f_)))
    def incomingCreditsRecorded: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded] = field(_.getIncomingCreditsRecorded)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsRecorded(f_)))
    def incomingCreditsCommited: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.IncomingCreditsCommited] = field(_.getIncomingCreditsCommited)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsCommited(f_)))
    def incomingCreditsCanceled: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled] = field(_.getIncomingCreditsCanceled)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event.IncomingCreditsCanceled(f_)))
    def event: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event] = field(_.event)((c_, f_) => c_.copy(event = f_))
  }
  final val BALANCECHANGED_FIELD_NUMBER = 1
  final val FUNDSRESERVED_FIELD_NUMBER = 2
  final val FUNDSDEDUCTED_FIELD_NUMBER = 3
  final val RESERVATIONRELEASED_FIELD_NUMBER = 4
  final val INCOMINGCREDITSRECORDED_FIELD_NUMBER = 5
  final val INCOMINGCREDITSCOMMITED_FIELD_NUMBER = 6
  final val INCOMINGCREDITSCANCELED_FIELD_NUMBER = 7
  def of(
    event: net.imadz.infrastructure.proto.credits.CreditBalanceEventPO.Event
  ): _root_.net.imadz.infrastructure.proto.credits.CreditBalanceEventPO = _root_.net.imadz.infrastructure.proto.credits.CreditBalanceEventPO(
    event
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.CreditBalanceEventPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\CreditBalanceStatePO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the CreditBalanceState snapshot
  *
  * @param userId
  *   UUID can be represented as a string
  */
@SerialVersionUID(0L)
final case class CreditBalanceStatePO(
    userId: _root_.scala.Predef.String = "",
    accountBalance: _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.collection.immutable.Map.empty,
    reservedAmount: _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.collection.immutable.Map.empty,
    incomingCredits: _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.collection.immutable.Map.empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[CreditBalanceStatePO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = userId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      accountBalance.foreach { __item =>
        val __value = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_accountBalance.toBase(__item)
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      reservedAmount.foreach { __item =>
        val __value = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_reservedAmount.toBase(__item)
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      incomingCredits.foreach { __item =>
        val __value = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_incomingCredits.toBase(__item)
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = userId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      accountBalance.foreach { __v =>
        val __m = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_accountBalance.toBase(__v)
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      reservedAmount.foreach { __v =>
        val __m = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_reservedAmount.toBase(__v)
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      incomingCredits.foreach { __v =>
        val __m = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_incomingCredits.toBase(__v)
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withUserId(__v: _root_.scala.Predef.String): CreditBalanceStatePO = copy(userId = __v)
    def clearAccountBalance = copy(accountBalance = _root_.scala.collection.immutable.Map.empty)
    def addAccountBalance(__vs: (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO) *): CreditBalanceStatePO = addAllAccountBalance(__vs)
    def addAllAccountBalance(__vs: Iterable[(_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)]): CreditBalanceStatePO = copy(accountBalance = accountBalance ++ __vs)
    def withAccountBalance(__v: _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]): CreditBalanceStatePO = copy(accountBalance = __v)
    def clearReservedAmount = copy(reservedAmount = _root_.scala.collection.immutable.Map.empty)
    def addReservedAmount(__vs: (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO) *): CreditBalanceStatePO = addAllReservedAmount(__vs)
    def addAllReservedAmount(__vs: Iterable[(_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)]): CreditBalanceStatePO = copy(reservedAmount = reservedAmount ++ __vs)
    def withReservedAmount(__v: _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]): CreditBalanceStatePO = copy(reservedAmount = __v)
    def clearIncomingCredits = copy(incomingCredits = _root_.scala.collection.immutable.Map.empty)
    def addIncomingCredits(__vs: (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO) *): CreditBalanceStatePO = addAllIncomingCredits(__vs)
    def addAllIncomingCredits(__vs: Iterable[(_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)]): CreditBalanceStatePO = copy(incomingCredits = incomingCredits ++ __vs)
    def withIncomingCredits(__v: _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]): CreditBalanceStatePO = copy(incomingCredits = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = userId
          if (__t != "") __t else null
        }
        case 2 => accountBalance.iterator.map(net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_accountBalance.toBase(_)).toSeq
        case 3 => reservedAmount.iterator.map(net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_reservedAmount.toBase(_)).toSeq
        case 4 => incomingCredits.iterator.map(net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_incomingCredits.toBase(_)).toSeq
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(userId)
        case 2 => _root_.scalapb.descriptors.PRepeated(accountBalance.iterator.map(net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_accountBalance.toBase(_).toPMessage).toVector)
        case 3 => _root_.scalapb.descriptors.PRepeated(reservedAmount.iterator.map(net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_reservedAmount.toBase(_).toPMessage).toVector)
        case 4 => _root_.scalapb.descriptors.PRepeated(incomingCredits.iterator.map(net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_incomingCredits.toBase(_).toPMessage).toVector)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.type = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.CreditBalanceStatePO])
}

object CreditBalanceStatePO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.CreditBalanceStatePO = {
    var __userId: _root_.scala.Predef.String = ""
    val __accountBalance: _root_.scala.collection.mutable.Builder[(_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO), _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]] = _root_.scala.collection.immutable.Map.newBuilder[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]
    val __reservedAmount: _root_.scala.collection.mutable.Builder[(_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO), _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]] = _root_.scala.collection.immutable.Map.newBuilder[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]
    val __incomingCredits: _root_.scala.collection.mutable.Builder[(_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO), _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]] = _root_.scala.collection.immutable.Map.newBuilder[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __userId = _input__.readStringRequireUtf8()
        case 18 =>
          __accountBalance += net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_accountBalance.toCustom(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry](_input__))
        case 26 =>
          __reservedAmount += net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_reservedAmount.toCustom(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry](_input__))
        case 34 =>
          __incomingCredits += net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_incomingCredits.toCustom(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry](_input__))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.CreditBalanceStatePO(
        userId = __userId,
        accountBalance = __accountBalance.result(),
        reservedAmount = __reservedAmount.result(),
        incomingCredits = __incomingCredits.result(),
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.CreditBalanceStatePO(
        userId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        accountBalance = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry]]).getOrElse(_root_.scala.Seq.empty).iterator.map(net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_accountBalance.toCustom(_)).toMap,
        reservedAmount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Seq[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry]]).getOrElse(_root_.scala.Seq.empty).iterator.map(net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_reservedAmount.toCustom(_)).toMap,
        incomingCredits = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scala.Seq[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry]]).getOrElse(_root_.scala.Seq.empty).iterator.map(net.imadz.infrastructure.proto.credits.CreditBalanceStatePO._typemapper_incomingCredits.toCustom(_)).toMap
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(9)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(9)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry
      case 3 => __out = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry
      case 4 => __out = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] =
    Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]](
      _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry,
      _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry,
      _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry
    )
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO(
    userId = "",
    accountBalance = _root_.scala.collection.immutable.Map.empty,
    reservedAmount = _root_.scala.collection.immutable.Map.empty,
    incomingCredits = _root_.scala.collection.immutable.Map.empty
  )
  @SerialVersionUID(0L)
  final case class AccountBalanceEntry(
      key: _root_.scala.Predef.String = "",
      value: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
      unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
      ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[AccountBalanceEntry] {
      @transient
      private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
      private[this] def __computeSerializedSize(): _root_.scala.Int = {
        var __size = 0
        
        {
          val __value = key
          if (!__value.isEmpty) {
            __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
          }
        };
        if (value.isDefined) {
          val __value = value.get
          __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        };
        __size += unknownFields.serializedSize
        __size
      }
      override def serializedSize: _root_.scala.Int = {
        var __size = __serializedSizeMemoized
        if (__size == 0) {
          __size = __computeSerializedSize() + 1
          __serializedSizeMemoized = __size
        }
        __size - 1
        
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
        {
          val __v = key
          if (!__v.isEmpty) {
            _output__.writeString(1, __v)
          }
        };
        value.foreach { __v =>
          val __m = __v
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__m.serializedSize)
          __m.writeTo(_output__)
        };
        unknownFields.writeTo(_output__)
      }
      def withKey(__v: _root_.scala.Predef.String): AccountBalanceEntry = copy(key = __v)
      def getValue: net.imadz.infrastructure.proto.credits.MoneyPO = value.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
      def clearValue: AccountBalanceEntry = copy(value = _root_.scala.None)
      def withValue(__v: net.imadz.infrastructure.proto.credits.MoneyPO): AccountBalanceEntry = copy(value = Option(__v))
      def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
      def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
      def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => {
            val __t = key
            if (__t != "") __t else null
          }
          case 2 => value.orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PString(key)
          case 2 => value.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
      def companion: net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry.type = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry
      // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.CreditBalanceStatePO.AccountBalanceEntry])
  }
  
  object AccountBalanceEntry extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry] {
    implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry] = this
    def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry = {
      var __key: _root_.scala.Predef.String = ""
      var __value: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
      var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __key = _input__.readStringRequireUtf8()
          case 18 =>
            __value = Option(__value.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case tag =>
            if (_unknownFields__ == null) {
              _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
            }
            _unknownFields__.parseField(tag, _input__)
        }
      }
      net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry(
          key = __key,
          value = __value,
          unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
        net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry(
          key = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
          value = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.javaDescriptor.getNestedTypes().get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.scalaDescriptor.nestedMessages(0)
    def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
      (__number: @_root_.scala.unchecked) match {
        case 2 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
      }
      __out
    }
    lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
    def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry(
      key = "",
      value = _root_.scala.None
    )
    implicit class AccountBalanceEntryLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry](_l) {
      def key: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.key)((c_, f_) => c_.copy(key = f_))
      def value: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getValue)((c_, f_) => c_.copy(value = Option(f_)))
      def optionalValue: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val KEY_FIELD_NUMBER = 1
    final val VALUE_FIELD_NUMBER = 2
    @transient
    implicit val keyValueMapper: _root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)] =
      _root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)](__m => (__m.key, __m.getValue))(__p => net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry(__p._1, Some(__p._2)))
    def of(
      key: _root_.scala.Predef.String,
      value: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
    ): _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry = _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry(
      key,
      value
    )
    // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.CreditBalanceStatePO.AccountBalanceEntry])
  }
  
  @SerialVersionUID(0L)
  final case class ReservedAmountEntry(
      key: _root_.scala.Predef.String = "",
      value: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
      unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
      ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[ReservedAmountEntry] {
      @transient
      private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
      private[this] def __computeSerializedSize(): _root_.scala.Int = {
        var __size = 0
        
        {
          val __value = key
          if (!__value.isEmpty) {
            __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
          }
        };
        if (value.isDefined) {
          val __value = value.get
          __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        };
        __size += unknownFields.serializedSize
        __size
      }
      override def serializedSize: _root_.scala.Int = {
        var __size = __serializedSizeMemoized
        if (__size == 0) {
          __size = __computeSerializedSize() + 1
          __serializedSizeMemoized = __size
        }
        __size - 1
        
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
        {
          val __v = key
          if (!__v.isEmpty) {
            _output__.writeString(1, __v)
          }
        };
        value.foreach { __v =>
          val __m = __v
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__m.serializedSize)
          __m.writeTo(_output__)
        };
        unknownFields.writeTo(_output__)
      }
      def withKey(__v: _root_.scala.Predef.String): ReservedAmountEntry = copy(key = __v)
      def getValue: net.imadz.infrastructure.proto.credits.MoneyPO = value.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
      def clearValue: ReservedAmountEntry = copy(value = _root_.scala.None)
      def withValue(__v: net.imadz.infrastructure.proto.credits.MoneyPO): ReservedAmountEntry = copy(value = Option(__v))
      def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
      def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
      def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => {
            val __t = key
            if (__t != "") __t else null
          }
          case 2 => value.orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PString(key)
          case 2 => value.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
      def companion: net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry.type = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry
      // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.CreditBalanceStatePO.ReservedAmountEntry])
  }
  
  object ReservedAmountEntry extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry] {
    implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry] = this
    def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry = {
      var __key: _root_.scala.Predef.String = ""
      var __value: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
      var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __key = _input__.readStringRequireUtf8()
          case 18 =>
            __value = Option(__value.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case tag =>
            if (_unknownFields__ == null) {
              _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
            }
            _unknownFields__.parseField(tag, _input__)
        }
      }
      net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry(
          key = __key,
          value = __value,
          unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
        net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry(
          key = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
          value = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.javaDescriptor.getNestedTypes().get(1)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.scalaDescriptor.nestedMessages(1)
    def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
      (__number: @_root_.scala.unchecked) match {
        case 2 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
      }
      __out
    }
    lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
    def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry(
      key = "",
      value = _root_.scala.None
    )
    implicit class ReservedAmountEntryLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry](_l) {
      def key: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.key)((c_, f_) => c_.copy(key = f_))
      def value: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getValue)((c_, f_) => c_.copy(value = Option(f_)))
      def optionalValue: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val KEY_FIELD_NUMBER = 1
    final val VALUE_FIELD_NUMBER = 2
    @transient
    implicit val keyValueMapper: _root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)] =
      _root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)](__m => (__m.key, __m.getValue))(__p => net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry(__p._1, Some(__p._2)))
    def of(
      key: _root_.scala.Predef.String,
      value: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
    ): _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry = _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry(
      key,
      value
    )
    // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.CreditBalanceStatePO.ReservedAmountEntry])
  }
  
  @SerialVersionUID(0L)
  final case class IncomingCreditsEntry(
      key: _root_.scala.Predef.String = "",
      value: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
      unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
      ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[IncomingCreditsEntry] {
      @transient
      private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
      private[this] def __computeSerializedSize(): _root_.scala.Int = {
        var __size = 0
        
        {
          val __value = key
          if (!__value.isEmpty) {
            __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
          }
        };
        if (value.isDefined) {
          val __value = value.get
          __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        };
        __size += unknownFields.serializedSize
        __size
      }
      override def serializedSize: _root_.scala.Int = {
        var __size = __serializedSizeMemoized
        if (__size == 0) {
          __size = __computeSerializedSize() + 1
          __serializedSizeMemoized = __size
        }
        __size - 1
        
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
        {
          val __v = key
          if (!__v.isEmpty) {
            _output__.writeString(1, __v)
          }
        };
        value.foreach { __v =>
          val __m = __v
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__m.serializedSize)
          __m.writeTo(_output__)
        };
        unknownFields.writeTo(_output__)
      }
      def withKey(__v: _root_.scala.Predef.String): IncomingCreditsEntry = copy(key = __v)
      def getValue: net.imadz.infrastructure.proto.credits.MoneyPO = value.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
      def clearValue: IncomingCreditsEntry = copy(value = _root_.scala.None)
      def withValue(__v: net.imadz.infrastructure.proto.credits.MoneyPO): IncomingCreditsEntry = copy(value = Option(__v))
      def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
      def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
      def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => {
            val __t = key
            if (__t != "") __t else null
          }
          case 2 => value.orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PString(key)
          case 2 => value.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
      def companion: net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry.type = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry
      // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.CreditBalanceStatePO.IncomingCreditsEntry])
  }
  
  object IncomingCreditsEntry extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry] {
    implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry] = this
    def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry = {
      var __key: _root_.scala.Predef.String = ""
      var __value: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
      var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __key = _input__.readStringRequireUtf8()
          case 18 =>
            __value = Option(__value.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case tag =>
            if (_unknownFields__ == null) {
              _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
            }
            _unknownFields__.parseField(tag, _input__)
        }
      }
      net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry(
          key = __key,
          value = __value,
          unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
        net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry(
          key = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
          value = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.javaDescriptor.getNestedTypes().get(2)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.scalaDescriptor.nestedMessages(2)
    def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
      (__number: @_root_.scala.unchecked) match {
        case 2 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
      }
      __out
    }
    lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
    def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry(
      key = "",
      value = _root_.scala.None
    )
    implicit class IncomingCreditsEntryLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry](_l) {
      def key: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.key)((c_, f_) => c_.copy(key = f_))
      def value: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getValue)((c_, f_) => c_.copy(value = Option(f_)))
      def optionalValue: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val KEY_FIELD_NUMBER = 1
    final val VALUE_FIELD_NUMBER = 2
    @transient
    implicit val keyValueMapper: _root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)] =
      _root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)](__m => (__m.key, __m.getValue))(__p => net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry(__p._1, Some(__p._2)))
    def of(
      key: _root_.scala.Predef.String,
      value: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
    ): _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry = _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry(
      key,
      value
    )
    // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.CreditBalanceStatePO.IncomingCreditsEntry])
  }
  
  implicit class CreditBalanceStatePOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceStatePO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.CreditBalanceStatePO](_l) {
    def userId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.userId)((c_, f_) => c_.copy(userId = f_))
    def accountBalance: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.accountBalance)((c_, f_) => c_.copy(accountBalance = f_))
    def reservedAmount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.reservedAmount)((c_, f_) => c_.copy(reservedAmount = f_))
    def incomingCredits: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.incomingCredits)((c_, f_) => c_.copy(incomingCredits = f_))
  }
  final val USERID_FIELD_NUMBER = 1
  final val ACCOUNTBALANCE_FIELD_NUMBER = 2
  final val RESERVEDAMOUNT_FIELD_NUMBER = 3
  final val INCOMINGCREDITS_FIELD_NUMBER = 4
  @transient
  private[credits] val _typemapper_accountBalance: _root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)] = implicitly[_root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.AccountBalanceEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)]]
  @transient
  private[credits] val _typemapper_reservedAmount: _root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)] = implicitly[_root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.ReservedAmountEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)]]
  @transient
  private[credits] val _typemapper_incomingCredits: _root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)] = implicitly[_root_.scalapb.TypeMapper[net.imadz.infrastructure.proto.credits.CreditBalanceStatePO.IncomingCreditsEntry, (_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO)]]
  def of(
    userId: _root_.scala.Predef.String,
    accountBalance: _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO],
    reservedAmount: _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO],
    incomingCredits: _root_.scala.collection.immutable.Map[_root_.scala.Predef.String, net.imadz.infrastructure.proto.credits.MoneyPO]
  ): _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO = _root_.net.imadz.infrastructure.proto.credits.CreditBalanceStatePO(
    userId,
    accountBalance,
    reservedAmount,
    incomingCredits
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.CreditBalanceStatePO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\CreditsProto.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

object CreditsProto extends _root_.scalapb.GeneratedFileObject {
  lazy val dependencies: Seq[_root_.scalapb.GeneratedFileObject] = Seq.empty
  lazy val messagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] =
    Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]](
      net.imadz.infrastructure.proto.credits.MoneyPO,
      net.imadz.infrastructure.proto.credits.BalanceChanged,
      net.imadz.infrastructure.proto.credits.FundsReserved,
      net.imadz.infrastructure.proto.credits.FundsDeducted,
      net.imadz.infrastructure.proto.credits.ReservationReleased,
      net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded,
      net.imadz.infrastructure.proto.credits.IncomingCreditsCommited,
      net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled,
      net.imadz.infrastructure.proto.credits.CreditBalanceEventPO,
      net.imadz.infrastructure.proto.credits.CreditBalanceStatePO
    )
  private lazy val ProtoBytes: _root_.scala.Array[Byte] =
      scalapb.Encoding.fromBase64(scala.collection.immutable.Seq(
  """Cg1jcmVkaXRzLnByb3RvEh5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8iWQoHTW9uZXlQTxIjCgZhbW91bnQYASABK
  AFCC+I/CBIGYW1vdW50UgZhbW91bnQSKQoIY3VycmVuY3kYAiABKAlCDeI/ChIIY3VycmVuY3lSCGN1cnJlbmN5IowBCg5CYWxhb
  mNlQ2hhbmdlZBJMCgZ1cGRhdGUYASABKAsyJy5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uTW9uZXlQT0IL4j8IEgZ1c
  GRhdGVSBnVwZGF0ZRIsCgl0aW1lc3RhbXAYAiABKANCDuI/CxIJdGltZXN0YW1wUgl0aW1lc3RhbXAijgEKDUZ1bmRzUmVzZXJ2Z
  WQSLwoKdHJhbnNmZXJJZBgBIAEoCUIP4j8MEgp0cmFuc2ZlcklkUgp0cmFuc2ZlcklkEkwKBmFtb3VudBgCIAEoCzInLm5ldC5pb
  WFkei5pbmZyYXN0cnVjdHVyZS5wcm90by5Nb25leVBPQgviPwgSBmFtb3VudFIGYW1vdW50Io4BCg1GdW5kc0RlZHVjdGVkEi8KC
  nRyYW5zZmVySWQYASABKAlCD+I/DBIKdHJhbnNmZXJJZFIKdHJhbnNmZXJJZBJMCgZhbW91bnQYAiABKAsyJy5uZXQuaW1hZHoua
  W5mcmFzdHJ1Y3R1cmUucHJvdG8uTW9uZXlQT0IL4j8IEgZhbW91bnRSBmFtb3VudCKUAQoTUmVzZXJ2YXRpb25SZWxlYXNlZBIvC
  gp0cmFuc2ZlcklkGAEgASgJQg/iPwwSCnRyYW5zZmVySWRSCnRyYW5zZmVySWQSTAoGYW1vdW50GAIgASgLMicubmV0LmltYWR6L
  mluZnJhc3RydWN0dXJlLnByb3RvLk1vbmV5UE9CC+I/CBIGYW1vdW50UgZhbW91bnQimAEKF0luY29taW5nQ3JlZGl0c1JlY29yZ
  GVkEi8KCnRyYW5zZmVySWQYASABKAlCD+I/DBIKdHJhbnNmZXJJZFIKdHJhbnNmZXJJZBJMCgZhbW91bnQYAiABKAsyJy5uZXQua
  W1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uTW9uZXlQT0IL4j8IEgZhbW91bnRSBmFtb3VudCJKChdJbmNvbWluZ0NyZWRpdHNDb
  21taXRlZBIvCgp0cmFuc2ZlcklkGAEgASgJQg/iPwwSCnRyYW5zZmVySWRSCnRyYW5zZmVySWQiSgoXSW5jb21pbmdDcmVkaXRzQ
  2FuY2VsZWQSLwoKdHJhbnNmZXJJZBgBIAEoCUIP4j8MEgp0cmFuc2ZlcklkUgp0cmFuc2ZlcklkIqQHChRDcmVkaXRCYWxhbmNlR
  XZlbnRQTxJtCg5iYWxhbmNlQ2hhbmdlZBgBIAEoCzIuLm5ldC5pbWFkei5pbmZyYXN0cnVjdHVyZS5wcm90by5CYWxhbmNlQ2hhb
  mdlZEIT4j8QEg5iYWxhbmNlQ2hhbmdlZEgAUg5iYWxhbmNlQ2hhbmdlZBJpCg1mdW5kc1Jlc2VydmVkGAIgASgLMi0ubmV0LmltY
  WR6LmluZnJhc3RydWN0dXJlLnByb3RvLkZ1bmRzUmVzZXJ2ZWRCEuI/DxINZnVuZHNSZXNlcnZlZEgAUg1mdW5kc1Jlc2VydmVkE
  mkKDWZ1bmRzRGVkdWN0ZWQYAyABKAsyLS5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uRnVuZHNEZWR1Y3RlZEIS4j8PE
  g1mdW5kc0RlZHVjdGVkSABSDWZ1bmRzRGVkdWN0ZWQSgQEKE3Jlc2VydmF0aW9uUmVsZWFzZWQYBCABKAsyMy5uZXQuaW1hZHoua
  W5mcmFzdHJ1Y3R1cmUucHJvdG8uUmVzZXJ2YXRpb25SZWxlYXNlZEIY4j8VEhNyZXNlcnZhdGlvblJlbGVhc2VkSABSE3Jlc2Vyd
  mF0aW9uUmVsZWFzZWQSkQEKF2luY29taW5nQ3JlZGl0c1JlY29yZGVkGAUgASgLMjcubmV0LmltYWR6LmluZnJhc3RydWN0dXJlL
  nByb3RvLkluY29taW5nQ3JlZGl0c1JlY29yZGVkQhziPxkSF2luY29taW5nQ3JlZGl0c1JlY29yZGVkSABSF2luY29taW5nQ3JlZ
  Gl0c1JlY29yZGVkEpEBChdpbmNvbWluZ0NyZWRpdHNDb21taXRlZBgGIAEoCzI3Lm5ldC5pbWFkei5pbmZyYXN0cnVjdHVyZS5wc
  m90by5JbmNvbWluZ0NyZWRpdHNDb21taXRlZEIc4j8ZEhdpbmNvbWluZ0NyZWRpdHNDb21taXRlZEgAUhdpbmNvbWluZ0NyZWRpd
  HNDb21taXRlZBKRAQoXaW5jb21pbmdDcmVkaXRzQ2FuY2VsZWQYByABKAsyNy5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvd
  G8uSW5jb21pbmdDcmVkaXRzQ2FuY2VsZWRCHOI/GRIXaW5jb21pbmdDcmVkaXRzQ2FuY2VsZWRIAFIXaW5jb21pbmdDcmVkaXRzQ
  2FuY2VsZWRCBwoFZXZlbnQi4QYKFENyZWRpdEJhbGFuY2VTdGF0ZVBPEiMKBnVzZXJJZBgBIAEoCUIL4j8IEgZ1c2VySWRSBnVzZ
  XJJZBKFAQoOYWNjb3VudEJhbGFuY2UYAiADKAsySC5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uQ3JlZGl0QmFsYW5jZ
  VN0YXRlUE8uQWNjb3VudEJhbGFuY2VFbnRyeUIT4j8QEg5hY2NvdW50QmFsYW5jZVIOYWNjb3VudEJhbGFuY2UShQEKDnJlc2Vyd
  mVkQW1vdW50GAMgAygLMkgubmV0LmltYWR6LmluZnJhc3RydWN0dXJlLnByb3RvLkNyZWRpdEJhbGFuY2VTdGF0ZVBPLlJlc2Vyd
  mVkQW1vdW50RW50cnlCE+I/EBIOcmVzZXJ2ZWRBbW91bnRSDnJlc2VydmVkQW1vdW50EokBCg9pbmNvbWluZ0NyZWRpdHMYBCADK
  AsySS5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uQ3JlZGl0QmFsYW5jZVN0YXRlUE8uSW5jb21pbmdDcmVkaXRzRW50c
  nlCFOI/ERIPaW5jb21pbmdDcmVkaXRzUg9pbmNvbWluZ0NyZWRpdHMagAEKE0FjY291bnRCYWxhbmNlRW50cnkSGgoDa2V5GAEgA
  SgJQgjiPwUSA2tleVIDa2V5EkkKBXZhbHVlGAIgASgLMicubmV0LmltYWR6LmluZnJhc3RydWN0dXJlLnByb3RvLk1vbmV5UE9CC
  uI/BxIFdmFsdWVSBXZhbHVlOgI4ARqAAQoTUmVzZXJ2ZWRBbW91bnRFbnRyeRIaCgNrZXkYASABKAlCCOI/BRIDa2V5UgNrZXkSS
  QoFdmFsdWUYAiABKAsyJy5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uTW9uZXlQT0IK4j8HEgV2YWx1ZVIFdmFsdWU6A
  jgBGoEBChRJbmNvbWluZ0NyZWRpdHNFbnRyeRIaCgNrZXkYASABKAlCCOI/BRIDa2V5UgNrZXkSSQoFdmFsdWUYAiABKAsyJy5uZ
  XQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uTW9uZXlQT0IK4j8HEgV2YWx1ZVIFdmFsdWU6AjgBYgZwcm90bzM="""
      ).mkString)
  lazy val scalaDescriptor: _root_.scalapb.descriptors.FileDescriptor = {
    val scalaProto = com.google.protobuf.descriptor.FileDescriptorProto.parseFrom(ProtoBytes)
    _root_.scalapb.descriptors.FileDescriptor.buildFrom(scalaProto, dependencies.map(_.scalaDescriptor))
  }
  lazy val javaDescriptor: com.google.protobuf.Descriptors.FileDescriptor = {
    val javaProto = com.google.protobuf.DescriptorProtos.FileDescriptorProto.parseFrom(ProtoBytes)
    com.google.protobuf.Descriptors.FileDescriptor.buildFrom(javaProto, _root_.scala.Array(
    ))
  }
  @deprecated("Use javaDescriptor instead. In a future version this will refer to scalaDescriptor.", "ScalaPB 0.5.47")
  def descriptor: com.google.protobuf.Descriptors.FileDescriptor = javaDescriptor
}

==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\FundsDeducted.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the FundsDeducted event
  */
@SerialVersionUID(0L)
final case class FundsDeducted(
    transferId: _root_.scala.Predef.String = "",
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[FundsDeducted] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transferId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (amount.isDefined) {
        val __value = amount.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transferId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      amount.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withTransferId(__v: _root_.scala.Predef.String): FundsDeducted = copy(transferId = __v)
    def getAmount: net.imadz.infrastructure.proto.credits.MoneyPO = amount.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
    def clearAmount: FundsDeducted = copy(amount = _root_.scala.None)
    def withAmount(__v: net.imadz.infrastructure.proto.credits.MoneyPO): FundsDeducted = copy(amount = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transferId
          if (__t != "") __t else null
        }
        case 2 => amount.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transferId)
        case 2 => amount.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.FundsDeducted.type = net.imadz.infrastructure.proto.credits.FundsDeducted
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.FundsDeducted])
}

object FundsDeducted extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.FundsDeducted] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.FundsDeducted] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.FundsDeducted = {
    var __transferId: _root_.scala.Predef.String = ""
    var __amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transferId = _input__.readStringRequireUtf8()
        case 18 =>
          __amount = Option(__amount.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.FundsDeducted(
        transferId = __transferId,
        amount = __amount,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.FundsDeducted] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.FundsDeducted(
        transferId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        amount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(3)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(3)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.FundsDeducted(
    transferId = "",
    amount = _root_.scala.None
  )
  implicit class FundsDeductedLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.FundsDeducted]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.FundsDeducted](_l) {
    def transferId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transferId)((c_, f_) => c_.copy(transferId = f_))
    def amount: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getAmount)((c_, f_) => c_.copy(amount = Option(f_)))
    def optionalAmount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.amount)((c_, f_) => c_.copy(amount = f_))
  }
  final val TRANSFERID_FIELD_NUMBER = 1
  final val AMOUNT_FIELD_NUMBER = 2
  def of(
    transferId: _root_.scala.Predef.String,
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
  ): _root_.net.imadz.infrastructure.proto.credits.FundsDeducted = _root_.net.imadz.infrastructure.proto.credits.FundsDeducted(
    transferId,
    amount
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.FundsDeducted])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\FundsReserved.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the FundsReserved event
  */
@SerialVersionUID(0L)
final case class FundsReserved(
    transferId: _root_.scala.Predef.String = "",
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[FundsReserved] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transferId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (amount.isDefined) {
        val __value = amount.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transferId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      amount.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withTransferId(__v: _root_.scala.Predef.String): FundsReserved = copy(transferId = __v)
    def getAmount: net.imadz.infrastructure.proto.credits.MoneyPO = amount.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
    def clearAmount: FundsReserved = copy(amount = _root_.scala.None)
    def withAmount(__v: net.imadz.infrastructure.proto.credits.MoneyPO): FundsReserved = copy(amount = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transferId
          if (__t != "") __t else null
        }
        case 2 => amount.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transferId)
        case 2 => amount.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.FundsReserved.type = net.imadz.infrastructure.proto.credits.FundsReserved
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.FundsReserved])
}

object FundsReserved extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.FundsReserved] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.FundsReserved] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.FundsReserved = {
    var __transferId: _root_.scala.Predef.String = ""
    var __amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transferId = _input__.readStringRequireUtf8()
        case 18 =>
          __amount = Option(__amount.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.FundsReserved(
        transferId = __transferId,
        amount = __amount,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.FundsReserved] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.FundsReserved(
        transferId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        amount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(2)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(2)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.FundsReserved(
    transferId = "",
    amount = _root_.scala.None
  )
  implicit class FundsReservedLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.FundsReserved]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.FundsReserved](_l) {
    def transferId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transferId)((c_, f_) => c_.copy(transferId = f_))
    def amount: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getAmount)((c_, f_) => c_.copy(amount = Option(f_)))
    def optionalAmount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.amount)((c_, f_) => c_.copy(amount = f_))
  }
  final val TRANSFERID_FIELD_NUMBER = 1
  final val AMOUNT_FIELD_NUMBER = 2
  def of(
    transferId: _root_.scala.Predef.String,
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
  ): _root_.net.imadz.infrastructure.proto.credits.FundsReserved = _root_.net.imadz.infrastructure.proto.credits.FundsReserved(
    transferId,
    amount
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.FundsReserved])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\IncomingCreditsCanceled.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the IncomingCreditsCanceled event
  */
@SerialVersionUID(0L)
final case class IncomingCreditsCanceled(
    transferId: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[IncomingCreditsCanceled] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transferId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transferId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withTransferId(__v: _root_.scala.Predef.String): IncomingCreditsCanceled = copy(transferId = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transferId
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transferId)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled.type = net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.IncomingCreditsCanceled])
}

object IncomingCreditsCanceled extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled = {
    var __transferId: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transferId = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled(
        transferId = __transferId,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled(
        transferId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(7)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(7)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled(
    transferId = ""
  )
  implicit class IncomingCreditsCanceledLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled](_l) {
    def transferId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transferId)((c_, f_) => c_.copy(transferId = f_))
  }
  final val TRANSFERID_FIELD_NUMBER = 1
  def of(
    transferId: _root_.scala.Predef.String
  ): _root_.net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled = _root_.net.imadz.infrastructure.proto.credits.IncomingCreditsCanceled(
    transferId
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.IncomingCreditsCanceled])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\IncomingCreditsCommited.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the IncomingCreditsCommited event
  */
@SerialVersionUID(0L)
final case class IncomingCreditsCommited(
    transferId: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[IncomingCreditsCommited] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transferId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transferId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withTransferId(__v: _root_.scala.Predef.String): IncomingCreditsCommited = copy(transferId = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transferId
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transferId)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.IncomingCreditsCommited.type = net.imadz.infrastructure.proto.credits.IncomingCreditsCommited
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.IncomingCreditsCommited])
}

object IncomingCreditsCommited extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.IncomingCreditsCommited] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.IncomingCreditsCommited] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.IncomingCreditsCommited = {
    var __transferId: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transferId = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.IncomingCreditsCommited(
        transferId = __transferId,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.IncomingCreditsCommited] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.IncomingCreditsCommited(
        transferId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(6)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(6)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.IncomingCreditsCommited(
    transferId = ""
  )
  implicit class IncomingCreditsCommitedLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.IncomingCreditsCommited]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.IncomingCreditsCommited](_l) {
    def transferId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transferId)((c_, f_) => c_.copy(transferId = f_))
  }
  final val TRANSFERID_FIELD_NUMBER = 1
  def of(
    transferId: _root_.scala.Predef.String
  ): _root_.net.imadz.infrastructure.proto.credits.IncomingCreditsCommited = _root_.net.imadz.infrastructure.proto.credits.IncomingCreditsCommited(
    transferId
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.IncomingCreditsCommited])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\IncomingCreditsRecorded.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the IncomingCreditsRecorded event
  */
@SerialVersionUID(0L)
final case class IncomingCreditsRecorded(
    transferId: _root_.scala.Predef.String = "",
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[IncomingCreditsRecorded] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transferId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (amount.isDefined) {
        val __value = amount.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transferId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      amount.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withTransferId(__v: _root_.scala.Predef.String): IncomingCreditsRecorded = copy(transferId = __v)
    def getAmount: net.imadz.infrastructure.proto.credits.MoneyPO = amount.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
    def clearAmount: IncomingCreditsRecorded = copy(amount = _root_.scala.None)
    def withAmount(__v: net.imadz.infrastructure.proto.credits.MoneyPO): IncomingCreditsRecorded = copy(amount = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transferId
          if (__t != "") __t else null
        }
        case 2 => amount.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transferId)
        case 2 => amount.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded.type = net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.IncomingCreditsRecorded])
}

object IncomingCreditsRecorded extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded = {
    var __transferId: _root_.scala.Predef.String = ""
    var __amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transferId = _input__.readStringRequireUtf8()
        case 18 =>
          __amount = Option(__amount.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded(
        transferId = __transferId,
        amount = __amount,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded(
        transferId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        amount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(5)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(5)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded(
    transferId = "",
    amount = _root_.scala.None
  )
  implicit class IncomingCreditsRecordedLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded](_l) {
    def transferId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transferId)((c_, f_) => c_.copy(transferId = f_))
    def amount: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getAmount)((c_, f_) => c_.copy(amount = Option(f_)))
    def optionalAmount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.amount)((c_, f_) => c_.copy(amount = f_))
  }
  final val TRANSFERID_FIELD_NUMBER = 1
  final val AMOUNT_FIELD_NUMBER = 2
  def of(
    transferId: _root_.scala.Predef.String,
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
  ): _root_.net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded = _root_.net.imadz.infrastructure.proto.credits.IncomingCreditsRecorded(
    transferId,
    amount
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.IncomingCreditsRecorded])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\MoneyPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the Money type
  */
@SerialVersionUID(0L)
final case class MoneyPO(
    amount: _root_.scala.Double = 0.0,
    currency: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[MoneyPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = amount
        if (__value != 0.0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeDoubleSize(1, __value)
        }
      };
      
      {
        val __value = currency
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = amount
        if (__v != 0.0) {
          _output__.writeDouble(1, __v)
        }
      };
      {
        val __v = currency
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withAmount(__v: _root_.scala.Double): MoneyPO = copy(amount = __v)
    def withCurrency(__v: _root_.scala.Predef.String): MoneyPO = copy(currency = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = amount
          if (__t != 0.0) __t else null
        }
        case 2 => {
          val __t = currency
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PDouble(amount)
        case 2 => _root_.scalapb.descriptors.PString(currency)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.MoneyPO.type = net.imadz.infrastructure.proto.credits.MoneyPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.MoneyPO])
}

object MoneyPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.MoneyPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.MoneyPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.MoneyPO = {
    var __amount: _root_.scala.Double = 0.0
    var __currency: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 9 =>
          __amount = _input__.readDouble()
        case 18 =>
          __currency = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.MoneyPO(
        amount = __amount,
        currency = __currency,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.MoneyPO(
        amount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Double]).getOrElse(0.0),
        currency = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(0)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.MoneyPO(
    amount = 0.0,
    currency = ""
  )
  implicit class MoneyPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO](_l) {
    def amount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Double] = field(_.amount)((c_, f_) => c_.copy(amount = f_))
    def currency: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.currency)((c_, f_) => c_.copy(currency = f_))
  }
  final val AMOUNT_FIELD_NUMBER = 1
  final val CURRENCY_FIELD_NUMBER = 2
  def of(
    amount: _root_.scala.Double,
    currency: _root_.scala.Predef.String
  ): _root_.net.imadz.infrastructure.proto.credits.MoneyPO = _root_.net.imadz.infrastructure.proto.credits.MoneyPO(
    amount,
    currency
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.MoneyPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\credits\ReservationReleased.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.credits

/** Define the ReservationReleased event
  */
@SerialVersionUID(0L)
final case class ReservationReleased(
    transferId: _root_.scala.Predef.String = "",
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[ReservationReleased] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = transferId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (amount.isDefined) {
        val __value = amount.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = transferId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      amount.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withTransferId(__v: _root_.scala.Predef.String): ReservationReleased = copy(transferId = __v)
    def getAmount: net.imadz.infrastructure.proto.credits.MoneyPO = amount.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
    def clearAmount: ReservationReleased = copy(amount = _root_.scala.None)
    def withAmount(__v: net.imadz.infrastructure.proto.credits.MoneyPO): ReservationReleased = copy(amount = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = transferId
          if (__t != "") __t else null
        }
        case 2 => amount.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(transferId)
        case 2 => amount.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.credits.ReservationReleased.type = net.imadz.infrastructure.proto.credits.ReservationReleased
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.ReservationReleased])
}

object ReservationReleased extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.ReservationReleased] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.credits.ReservationReleased] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.credits.ReservationReleased = {
    var __transferId: _root_.scala.Predef.String = ""
    var __amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __transferId = _input__.readStringRequireUtf8()
        case 18 =>
          __amount = Option(__amount.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.credits.ReservationReleased(
        transferId = __transferId,
        amount = __amount,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.credits.ReservationReleased] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.credits.ReservationReleased(
        transferId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        amount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = CreditsProto.javaDescriptor.getMessageTypes().get(4)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = CreditsProto.scalaDescriptor.messages(4)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.credits.ReservationReleased(
    transferId = "",
    amount = _root_.scala.None
  )
  implicit class ReservationReleasedLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.ReservationReleased]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.credits.ReservationReleased](_l) {
    def transferId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.transferId)((c_, f_) => c_.copy(transferId = f_))
    def amount: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getAmount)((c_, f_) => c_.copy(amount = Option(f_)))
    def optionalAmount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.amount)((c_, f_) => c_.copy(amount = f_))
  }
  final val TRANSFERID_FIELD_NUMBER = 1
  final val AMOUNT_FIELD_NUMBER = 2
  def of(
    transferId: _root_.scala.Predef.String,
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
  ): _root_.net.imadz.infrastructure.proto.credits.ReservationReleased = _root_.net.imadz.infrastructure.proto.credits.ReservationReleased(
    transferId,
    amount
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.ReservationReleased])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\saga_participant\FromAccountParticipantPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.saga_participant

/** Represents a participant that handles the from account in a transaction
  */
@SerialVersionUID(0L)
final case class FromAccountParticipantPO(
    fromUserId: _root_.scala.Predef.String = "",
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[FromAccountParticipantPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = fromUserId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (amount.isDefined) {
        val __value = amount.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = fromUserId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      amount.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withFromUserId(__v: _root_.scala.Predef.String): FromAccountParticipantPO = copy(fromUserId = __v)
    def getAmount: net.imadz.infrastructure.proto.credits.MoneyPO = amount.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
    def clearAmount: FromAccountParticipantPO = copy(amount = _root_.scala.None)
    def withAmount(__v: net.imadz.infrastructure.proto.credits.MoneyPO): FromAccountParticipantPO = copy(amount = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = fromUserId
          if (__t != "") __t else null
        }
        case 2 => amount.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(fromUserId)
        case 2 => amount.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO.type = net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.FromAccountParticipantPO])
}

object FromAccountParticipantPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO = {
    var __fromUserId: _root_.scala.Predef.String = ""
    var __amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __fromUserId = _input__.readStringRequireUtf8()
        case 18 =>
          __amount = Option(__amount.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO(
        fromUserId = __fromUserId,
        amount = __amount,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO(
        fromUserId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        amount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaParticipantProto.javaDescriptor.getMessageTypes().get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaParticipantProto.scalaDescriptor.messages(0)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO(
    fromUserId = "",
    amount = _root_.scala.None
  )
  implicit class FromAccountParticipantPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO](_l) {
    def fromUserId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.fromUserId)((c_, f_) => c_.copy(fromUserId = f_))
    def amount: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getAmount)((c_, f_) => c_.copy(amount = Option(f_)))
    def optionalAmount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.amount)((c_, f_) => c_.copy(amount = f_))
  }
  final val FROM_USER_ID_FIELD_NUMBER = 1
  final val AMOUNT_FIELD_NUMBER = 2
  def of(
    fromUserId: _root_.scala.Predef.String,
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
  ): _root_.net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO = _root_.net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO(
    fromUserId,
    amount
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.FromAccountParticipantPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\saga_participant\SagaParticipantProto.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.saga_participant

object SagaParticipantProto extends _root_.scalapb.GeneratedFileObject {
  lazy val dependencies: Seq[_root_.scalapb.GeneratedFileObject] = Seq(
    net.imadz.infrastructure.proto.credits.CreditsProto
  )
  lazy val messagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] =
    Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]](
      net.imadz.infrastructure.proto.saga_participant.FromAccountParticipantPO,
      net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO
    )
  private lazy val ProtoBytes: _root_.scala.Array[Byte] =
      scalapb.Encoding.fromBase64(scala.collection.immutable.Seq(
  """ChZzYWdhX3BhcnRpY2lwYW50LnByb3RvEh5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8aDWNyZWRpdHMucHJvdG8im
  wEKGEZyb21BY2NvdW50UGFydGljaXBhbnRQTxIxCgxmcm9tX3VzZXJfaWQYASABKAlCD+I/DBIKZnJvbVVzZXJJZFIKZnJvbVVzZ
  XJJZBJMCgZhbW91bnQYAiABKAsyJy5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uTW9uZXlQT0IL4j8IEgZhbW91bnRSB
  mFtb3VudCKTAQoWVG9BY2NvdW50UGFydGljaXBhbnRQTxIrCgp0b191c2VyX2lkGAEgASgJQg3iPwoSCHRvVXNlcklkUgh0b1VzZ
  XJJZBJMCgZhbW91bnQYAiABKAsyJy5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uTW9uZXlQT0IL4j8IEgZhbW91bnRSB
  mFtb3VudGIGcHJvdG8z"""
      ).mkString)
  lazy val scalaDescriptor: _root_.scalapb.descriptors.FileDescriptor = {
    val scalaProto = com.google.protobuf.descriptor.FileDescriptorProto.parseFrom(ProtoBytes)
    _root_.scalapb.descriptors.FileDescriptor.buildFrom(scalaProto, dependencies.map(_.scalaDescriptor))
  }
  lazy val javaDescriptor: com.google.protobuf.Descriptors.FileDescriptor = {
    val javaProto = com.google.protobuf.DescriptorProtos.FileDescriptorProto.parseFrom(ProtoBytes)
    com.google.protobuf.Descriptors.FileDescriptor.buildFrom(javaProto, _root_.scala.Array(
      net.imadz.infrastructure.proto.credits.CreditsProto.javaDescriptor
    ))
  }
  @deprecated("Use javaDescriptor instead. In a future version this will refer to scalaDescriptor.", "ScalaPB 0.5.47")
  def descriptor: com.google.protobuf.Descriptors.FileDescriptor = javaDescriptor
}

==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\saga_participant\ToAccountParticipantPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.saga_participant

@SerialVersionUID(0L)
final case class ToAccountParticipantPO(
    toUserId: _root_.scala.Predef.String = "",
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[ToAccountParticipantPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = toUserId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (amount.isDefined) {
        val __value = amount.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = toUserId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      amount.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withToUserId(__v: _root_.scala.Predef.String): ToAccountParticipantPO = copy(toUserId = __v)
    def getAmount: net.imadz.infrastructure.proto.credits.MoneyPO = amount.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
    def clearAmount: ToAccountParticipantPO = copy(amount = _root_.scala.None)
    def withAmount(__v: net.imadz.infrastructure.proto.credits.MoneyPO): ToAccountParticipantPO = copy(amount = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = toUserId
          if (__t != "") __t else null
        }
        case 2 => amount.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(toUserId)
        case 2 => amount.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO.type = net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.ToAccountParticipantPO])
}

object ToAccountParticipantPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO = {
    var __toUserId: _root_.scala.Predef.String = ""
    var __amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __toUserId = _input__.readStringRequireUtf8()
        case 18 =>
          __amount = Option(__amount.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO(
        toUserId = __toUserId,
        amount = __amount,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO(
        toUserId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        amount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = SagaParticipantProto.javaDescriptor.getMessageTypes().get(1)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = SagaParticipantProto.scalaDescriptor.messages(1)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO(
    toUserId = "",
    amount = _root_.scala.None
  )
  implicit class ToAccountParticipantPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO](_l) {
    def toUserId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.toUserId)((c_, f_) => c_.copy(toUserId = f_))
    def amount: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getAmount)((c_, f_) => c_.copy(amount = Option(f_)))
    def optionalAmount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.amount)((c_, f_) => c_.copy(amount = f_))
  }
  final val TO_USER_ID_FIELD_NUMBER = 1
  final val AMOUNT_FIELD_NUMBER = 2
  def of(
    toUserId: _root_.scala.Predef.String,
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
  ): _root_.net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO = _root_.net.imadz.infrastructure.proto.saga_participant.ToAccountParticipantPO(
    toUserId,
    amount
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.ToAccountParticipantPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\FailedStatusPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the Failed status message
  */
@SerialVersionUID(0L)
final case class FailedStatusPO(
    reason: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[FailedStatusPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = reason
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = reason
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withReason(__v: _root_.scala.Predef.String): FailedStatusPO = copy(reason = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = reason
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(reason)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.transactions.FailedStatusPO.type = net.imadz.infrastructure.proto.transactions.FailedStatusPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.FailedStatusPO])
}

object FailedStatusPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.FailedStatusPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.FailedStatusPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.transactions.FailedStatusPO = {
    var __reason: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __reason = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.transactions.FailedStatusPO(
        reason = __reason,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.transactions.FailedStatusPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.transactions.FailedStatusPO(
        reason = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TransactionsProto.javaDescriptor.getMessageTypes().get(1)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TransactionsProto.scalaDescriptor.messages(1)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.transactions.FailedStatusPO(
    reason = ""
  )
  implicit class FailedStatusPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.FailedStatusPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.transactions.FailedStatusPO](_l) {
    def reason: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.reason)((c_, f_) => c_.copy(reason = f_))
  }
  final val REASON_FIELD_NUMBER = 1
  def of(
    reason: _root_.scala.Predef.String
  ): _root_.net.imadz.infrastructure.proto.transactions.FailedStatusPO = _root_.net.imadz.infrastructure.proto.transactions.FailedStatusPO(
    reason
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.FailedStatusPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\TransactionCompletedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the TransactionCompleted event
  */
@SerialVersionUID(0L)
final case class TransactionCompletedPO(
    id: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionCompletedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = id
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = id
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withId(__v: _root_.scala.Predef.String): TransactionCompletedPO = copy(id = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = id
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(id)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.transactions.TransactionCompletedPO.type = net.imadz.infrastructure.proto.transactions.TransactionCompletedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.TransactionCompletedPO])
}

object TransactionCompletedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionCompletedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionCompletedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.transactions.TransactionCompletedPO = {
    var __id: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __id = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.transactions.TransactionCompletedPO(
        id = __id,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.transactions.TransactionCompletedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.transactions.TransactionCompletedPO(
        id = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TransactionsProto.javaDescriptor.getMessageTypes().get(7)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TransactionsProto.scalaDescriptor.messages(7)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.transactions.TransactionCompletedPO(
    id = ""
  )
  implicit class TransactionCompletedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionCompletedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionCompletedPO](_l) {
    def id: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.id)((c_, f_) => c_.copy(id = f_))
  }
  final val ID_FIELD_NUMBER = 1
  def of(
    id: _root_.scala.Predef.String
  ): _root_.net.imadz.infrastructure.proto.transactions.TransactionCompletedPO = _root_.net.imadz.infrastructure.proto.transactions.TransactionCompletedPO(
    id
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.TransactionCompletedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\TransactionEventPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the TransactionEvent union
  */
@SerialVersionUID(0L)
final case class TransactionEventPO(
    event: net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionEventPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (event.initiated.isDefined) {
        val __value = event.initiated.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.prepared.isDefined) {
        val __value = event.prepared.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.completed.isDefined) {
        val __value = event.completed.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (event.failed.isDefined) {
        val __value = event.failed.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      event.initiated.foreach { __v =>
        val __m = __v
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.prepared.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.completed.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      event.failed.foreach { __v =>
        val __m = __v
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getInitiated: net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO = event.initiated.getOrElse(net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO.defaultInstance)
    def withInitiated(__v: net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO): TransactionEventPO = copy(event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Initiated(__v))
    def getPrepared: net.imadz.infrastructure.proto.transactions.TransactionPreparedPO = event.prepared.getOrElse(net.imadz.infrastructure.proto.transactions.TransactionPreparedPO.defaultInstance)
    def withPrepared(__v: net.imadz.infrastructure.proto.transactions.TransactionPreparedPO): TransactionEventPO = copy(event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Prepared(__v))
    def getCompleted: net.imadz.infrastructure.proto.transactions.TransactionCompletedPO = event.completed.getOrElse(net.imadz.infrastructure.proto.transactions.TransactionCompletedPO.defaultInstance)
    def withCompleted(__v: net.imadz.infrastructure.proto.transactions.TransactionCompletedPO): TransactionEventPO = copy(event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Completed(__v))
    def getFailed: net.imadz.infrastructure.proto.transactions.TransactionFailedPO = event.failed.getOrElse(net.imadz.infrastructure.proto.transactions.TransactionFailedPO.defaultInstance)
    def withFailed(__v: net.imadz.infrastructure.proto.transactions.TransactionFailedPO): TransactionEventPO = copy(event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Failed(__v))
    def clearEvent: TransactionEventPO = copy(event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Empty)
    def withEvent(__v: net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event): TransactionEventPO = copy(event = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => event.initiated.orNull
        case 2 => event.prepared.orNull
        case 3 => event.completed.orNull
        case 4 => event.failed.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => event.initiated.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => event.prepared.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => event.completed.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => event.failed.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.transactions.TransactionEventPO.type = net.imadz.infrastructure.proto.transactions.TransactionEventPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.TransactionEventPO])
}

object TransactionEventPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionEventPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionEventPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.transactions.TransactionEventPO = {
    var __event: net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Empty
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Initiated(__event.initiated.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 18 =>
          __event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Prepared(__event.prepared.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.transactions.TransactionPreparedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 26 =>
          __event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Completed(__event.completed.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.transactions.TransactionCompletedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 34 =>
          __event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Failed(__event.failed.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.transactions.TransactionFailedPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.transactions.TransactionEventPO(
        event = __event,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.transactions.TransactionEventPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.transactions.TransactionEventPO(
        event = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO]]).map(net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Initiated(_))
            .orElse[net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionPreparedPO]]).map(net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Prepared(_)))
            .orElse[net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionCompletedPO]]).map(net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Completed(_)))
            .orElse[net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event](__fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionFailedPO]]).map(net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Failed(_)))
            .getOrElse(net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TransactionsProto.javaDescriptor.getMessageTypes().get(4)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TransactionsProto.scalaDescriptor.messages(4)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO
      case 2 => __out = net.imadz.infrastructure.proto.transactions.TransactionPreparedPO
      case 3 => __out = net.imadz.infrastructure.proto.transactions.TransactionCompletedPO
      case 4 => __out = net.imadz.infrastructure.proto.transactions.TransactionFailedPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.transactions.TransactionEventPO(
    event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Empty
  )
  sealed trait Event extends _root_.scalapb.GeneratedOneof {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isInitiated: _root_.scala.Boolean = false
    def isPrepared: _root_.scala.Boolean = false
    def isCompleted: _root_.scala.Boolean = false
    def isFailed: _root_.scala.Boolean = false
    def initiated: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO] = _root_.scala.None
    def prepared: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionPreparedPO] = _root_.scala.None
    def completed: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionCompletedPO] = _root_.scala.None
    def failed: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionFailedPO] = _root_.scala.None
  }
  object Event {
    @SerialVersionUID(0L)
    case object Empty extends net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class Initiated(value: net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO) extends net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO
      override def isInitiated: _root_.scala.Boolean = true
      override def initiated: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO] = Some(value)
      override def number: _root_.scala.Int = 1
    }
    @SerialVersionUID(0L)
    final case class Prepared(value: net.imadz.infrastructure.proto.transactions.TransactionPreparedPO) extends net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.transactions.TransactionPreparedPO
      override def isPrepared: _root_.scala.Boolean = true
      override def prepared: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionPreparedPO] = Some(value)
      override def number: _root_.scala.Int = 2
    }
    @SerialVersionUID(0L)
    final case class Completed(value: net.imadz.infrastructure.proto.transactions.TransactionCompletedPO) extends net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.transactions.TransactionCompletedPO
      override def isCompleted: _root_.scala.Boolean = true
      override def completed: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionCompletedPO] = Some(value)
      override def number: _root_.scala.Int = 3
    }
    @SerialVersionUID(0L)
    final case class Failed(value: net.imadz.infrastructure.proto.transactions.TransactionFailedPO) extends net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event {
      type ValueType = net.imadz.infrastructure.proto.transactions.TransactionFailedPO
      override def isFailed: _root_.scala.Boolean = true
      override def failed: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionFailedPO] = Some(value)
      override def number: _root_.scala.Int = 4
    }
  }
  implicit class TransactionEventPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionEventPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionEventPO](_l) {
    def initiated: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO] = field(_.getInitiated)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Initiated(f_)))
    def prepared: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionPreparedPO] = field(_.getPrepared)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Prepared(f_)))
    def completed: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionCompletedPO] = field(_.getCompleted)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Completed(f_)))
    def failed: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionFailedPO] = field(_.getFailed)((c_, f_) => c_.copy(event = net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event.Failed(f_)))
    def event: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event] = field(_.event)((c_, f_) => c_.copy(event = f_))
  }
  final val INITIATED_FIELD_NUMBER = 1
  final val PREPARED_FIELD_NUMBER = 2
  final val COMPLETED_FIELD_NUMBER = 3
  final val FAILED_FIELD_NUMBER = 4
  def of(
    event: net.imadz.infrastructure.proto.transactions.TransactionEventPO.Event
  ): _root_.net.imadz.infrastructure.proto.transactions.TransactionEventPO = _root_.net.imadz.infrastructure.proto.transactions.TransactionEventPO(
    event
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.TransactionEventPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\TransactionFailedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the TransactionFailed event
  */
@SerialVersionUID(0L)
final case class TransactionFailedPO(
    id: _root_.scala.Predef.String = "",
    reason: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionFailedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = id
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = reason
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = id
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = reason
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withId(__v: _root_.scala.Predef.String): TransactionFailedPO = copy(id = __v)
    def withReason(__v: _root_.scala.Predef.String): TransactionFailedPO = copy(reason = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = id
          if (__t != "") __t else null
        }
        case 2 => {
          val __t = reason
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(id)
        case 2 => _root_.scalapb.descriptors.PString(reason)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.transactions.TransactionFailedPO.type = net.imadz.infrastructure.proto.transactions.TransactionFailedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.TransactionFailedPO])
}

object TransactionFailedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionFailedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionFailedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.transactions.TransactionFailedPO = {
    var __id: _root_.scala.Predef.String = ""
    var __reason: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __id = _input__.readStringRequireUtf8()
        case 18 =>
          __reason = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.transactions.TransactionFailedPO(
        id = __id,
        reason = __reason,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.transactions.TransactionFailedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.transactions.TransactionFailedPO(
        id = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        reason = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TransactionsProto.javaDescriptor.getMessageTypes().get(8)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TransactionsProto.scalaDescriptor.messages(8)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.transactions.TransactionFailedPO(
    id = "",
    reason = ""
  )
  implicit class TransactionFailedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionFailedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionFailedPO](_l) {
    def id: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.id)((c_, f_) => c_.copy(id = f_))
    def reason: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.reason)((c_, f_) => c_.copy(reason = f_))
  }
  final val ID_FIELD_NUMBER = 1
  final val REASON_FIELD_NUMBER = 2
  def of(
    id: _root_.scala.Predef.String,
    reason: _root_.scala.Predef.String
  ): _root_.net.imadz.infrastructure.proto.transactions.TransactionFailedPO = _root_.net.imadz.infrastructure.proto.transactions.TransactionFailedPO(
    id,
    reason
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.TransactionFailedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\TransactionInitiatedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the TransactionInitiated event
  */
@SerialVersionUID(0L)
final case class TransactionInitiatedPO(
    fromUserId: _root_.scala.Predef.String = "",
    toUserId: _root_.scala.Predef.String = "",
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionInitiatedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = fromUserId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = toUserId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      if (amount.isDefined) {
        val __value = amount.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = fromUserId
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = toUserId
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      amount.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withFromUserId(__v: _root_.scala.Predef.String): TransactionInitiatedPO = copy(fromUserId = __v)
    def withToUserId(__v: _root_.scala.Predef.String): TransactionInitiatedPO = copy(toUserId = __v)
    def getAmount: net.imadz.infrastructure.proto.credits.MoneyPO = amount.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
    def clearAmount: TransactionInitiatedPO = copy(amount = _root_.scala.None)
    def withAmount(__v: net.imadz.infrastructure.proto.credits.MoneyPO): TransactionInitiatedPO = copy(amount = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = fromUserId
          if (__t != "") __t else null
        }
        case 2 => {
          val __t = toUserId
          if (__t != "") __t else null
        }
        case 3 => amount.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(fromUserId)
        case 2 => _root_.scalapb.descriptors.PString(toUserId)
        case 3 => amount.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO.type = net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.TransactionInitiatedPO])
}

object TransactionInitiatedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO = {
    var __fromUserId: _root_.scala.Predef.String = ""
    var __toUserId: _root_.scala.Predef.String = ""
    var __amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __fromUserId = _input__.readStringRequireUtf8()
        case 18 =>
          __toUserId = _input__.readStringRequireUtf8()
        case 26 =>
          __amount = Option(__amount.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO(
        fromUserId = __fromUserId,
        toUserId = __toUserId,
        amount = __amount,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO(
        fromUserId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        toUserId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        amount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TransactionsProto.javaDescriptor.getMessageTypes().get(5)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TransactionsProto.scalaDescriptor.messages(5)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 3 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO(
    fromUserId = "",
    toUserId = "",
    amount = _root_.scala.None
  )
  implicit class TransactionInitiatedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO](_l) {
    def fromUserId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.fromUserId)((c_, f_) => c_.copy(fromUserId = f_))
    def toUserId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.toUserId)((c_, f_) => c_.copy(toUserId = f_))
    def amount: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getAmount)((c_, f_) => c_.copy(amount = Option(f_)))
    def optionalAmount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.amount)((c_, f_) => c_.copy(amount = f_))
  }
  final val FROMUSERID_FIELD_NUMBER = 1
  final val TOUSERID_FIELD_NUMBER = 2
  final val AMOUNT_FIELD_NUMBER = 3
  def of(
    fromUserId: _root_.scala.Predef.String,
    toUserId: _root_.scala.Predef.String,
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]
  ): _root_.net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO = _root_.net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO(
    fromUserId,
    toUserId,
    amount
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.TransactionInitiatedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\TransactionPreparedPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the TransactionPrepared event
  */
@SerialVersionUID(0L)
final case class TransactionPreparedPO(
    id: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionPreparedPO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = id
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = id
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withId(__v: _root_.scala.Predef.String): TransactionPreparedPO = copy(id = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = id
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(id)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.transactions.TransactionPreparedPO.type = net.imadz.infrastructure.proto.transactions.TransactionPreparedPO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.TransactionPreparedPO])
}

object TransactionPreparedPO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionPreparedPO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionPreparedPO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.transactions.TransactionPreparedPO = {
    var __id: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __id = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.transactions.TransactionPreparedPO(
        id = __id,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.transactions.TransactionPreparedPO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.transactions.TransactionPreparedPO(
        id = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TransactionsProto.javaDescriptor.getMessageTypes().get(6)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TransactionsProto.scalaDescriptor.messages(6)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.transactions.TransactionPreparedPO(
    id = ""
  )
  implicit class TransactionPreparedPOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionPreparedPO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionPreparedPO](_l) {
    def id: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.id)((c_, f_) => c_.copy(id = f_))
  }
  final val ID_FIELD_NUMBER = 1
  def of(
    id: _root_.scala.Predef.String
  ): _root_.net.imadz.infrastructure.proto.transactions.TransactionPreparedPO = _root_.net.imadz.infrastructure.proto.transactions.TransactionPreparedPO(
    id
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.TransactionPreparedPO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\TransactionStatePO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the TransactionState message
  */
@SerialVersionUID(0L)
final case class TransactionStatePO(
    id: _root_.scala.Predef.String = "",
    fromUserId: _root_.scala.Predef.String = "",
    toUserId: _root_.scala.Predef.String = "",
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None,
    status: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionStatePO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = id
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = fromUserId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      
      {
        val __value = toUserId
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(3, __value)
        }
      };
      if (amount.isDefined) {
        val __value = amount.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (status.isDefined) {
        val __value = status.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = id
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = fromUserId
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      {
        val __v = toUserId
        if (!__v.isEmpty) {
          _output__.writeString(3, __v)
        }
      };
      amount.foreach { __v =>
        val __m = __v
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      status.foreach { __v =>
        val __m = __v
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withId(__v: _root_.scala.Predef.String): TransactionStatePO = copy(id = __v)
    def withFromUserId(__v: _root_.scala.Predef.String): TransactionStatePO = copy(fromUserId = __v)
    def withToUserId(__v: _root_.scala.Predef.String): TransactionStatePO = copy(toUserId = __v)
    def getAmount: net.imadz.infrastructure.proto.credits.MoneyPO = amount.getOrElse(net.imadz.infrastructure.proto.credits.MoneyPO.defaultInstance)
    def clearAmount: TransactionStatePO = copy(amount = _root_.scala.None)
    def withAmount(__v: net.imadz.infrastructure.proto.credits.MoneyPO): TransactionStatePO = copy(amount = Option(__v))
    def getStatus: net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO = status.getOrElse(net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.defaultInstance)
    def clearStatus: TransactionStatePO = copy(status = _root_.scala.None)
    def withStatus(__v: net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO): TransactionStatePO = copy(status = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = id
          if (__t != "") __t else null
        }
        case 2 => {
          val __t = fromUserId
          if (__t != "") __t else null
        }
        case 3 => {
          val __t = toUserId
          if (__t != "") __t else null
        }
        case 4 => amount.orNull
        case 5 => status.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(id)
        case 2 => _root_.scalapb.descriptors.PString(fromUserId)
        case 3 => _root_.scalapb.descriptors.PString(toUserId)
        case 4 => amount.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => status.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.transactions.TransactionStatePO.type = net.imadz.infrastructure.proto.transactions.TransactionStatePO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.TransactionStatePO])
}

object TransactionStatePO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionStatePO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionStatePO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.transactions.TransactionStatePO = {
    var __id: _root_.scala.Predef.String = ""
    var __fromUserId: _root_.scala.Predef.String = ""
    var __toUserId: _root_.scala.Predef.String = ""
    var __amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO] = _root_.scala.None
    var __status: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO] = _root_.scala.None
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __id = _input__.readStringRequireUtf8()
        case 18 =>
          __fromUserId = _input__.readStringRequireUtf8()
        case 26 =>
          __toUserId = _input__.readStringRequireUtf8()
        case 34 =>
          __amount = Option(__amount.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.credits.MoneyPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 42 =>
          __status = Option(__status.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.transactions.TransactionStatePO(
        id = __id,
        fromUserId = __fromUserId,
        toUserId = __toUserId,
        amount = __amount,
        status = __status,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.transactions.TransactionStatePO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.transactions.TransactionStatePO(
        id = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        fromUserId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        toUserId = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        amount = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]]),
        status = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TransactionsProto.javaDescriptor.getMessageTypes().get(3)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TransactionsProto.scalaDescriptor.messages(3)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 4 => __out = net.imadz.infrastructure.proto.credits.MoneyPO
      case 5 => __out = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.transactions.TransactionStatePO(
    id = "",
    fromUserId = "",
    toUserId = "",
    amount = _root_.scala.None,
    status = _root_.scala.None
  )
  implicit class TransactionStatePOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionStatePO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionStatePO](_l) {
    def id: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.id)((c_, f_) => c_.copy(id = f_))
    def fromUserId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.fromUserId)((c_, f_) => c_.copy(fromUserId = f_))
    def toUserId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.toUserId)((c_, f_) => c_.copy(toUserId = f_))
    def amount: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.credits.MoneyPO] = field(_.getAmount)((c_, f_) => c_.copy(amount = Option(f_)))
    def optionalAmount: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO]] = field(_.amount)((c_, f_) => c_.copy(amount = f_))
    def status: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO] = field(_.getStatus)((c_, f_) => c_.copy(status = Option(f_)))
    def optionalStatus: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO]] = field(_.status)((c_, f_) => c_.copy(status = f_))
  }
  final val ID_FIELD_NUMBER = 1
  final val FROMUSERID_FIELD_NUMBER = 2
  final val TOUSERID_FIELD_NUMBER = 3
  final val AMOUNT_FIELD_NUMBER = 4
  final val STATUS_FIELD_NUMBER = 5
  def of(
    id: _root_.scala.Predef.String,
    fromUserId: _root_.scala.Predef.String,
    toUserId: _root_.scala.Predef.String,
    amount: _root_.scala.Option[net.imadz.infrastructure.proto.credits.MoneyPO],
    status: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO]
  ): _root_.net.imadz.infrastructure.proto.transactions.TransactionStatePO = _root_.net.imadz.infrastructure.proto.transactions.TransactionStatePO(
    id,
    fromUserId,
    toUserId,
    amount,
    status
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.TransactionStatePO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\TransactionStatusMessagePO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the TransactionStatus union
  */
@SerialVersionUID(0L)
final case class TransactionStatusMessagePO(
    status: net.imadz.infrastructure.proto.transactions.TransactionStatusPO = net.imadz.infrastructure.proto.transactions.TransactionStatusPO.UNKNOWN,
    details: net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details.Empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TransactionStatusMessagePO] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = status.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, __value)
        }
      };
      if (details.failed.isDefined) {
        val __value = details.failed.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = status.value
        if (__v != 0) {
          _output__.writeEnum(1, __v)
        }
      };
      details.failed.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withStatus(__v: net.imadz.infrastructure.proto.transactions.TransactionStatusPO): TransactionStatusMessagePO = copy(status = __v)
    def getFailed: net.imadz.infrastructure.proto.transactions.FailedStatusPO = details.failed.getOrElse(net.imadz.infrastructure.proto.transactions.FailedStatusPO.defaultInstance)
    def withFailed(__v: net.imadz.infrastructure.proto.transactions.FailedStatusPO): TransactionStatusMessagePO = copy(details = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details.Failed(__v))
    def clearDetails: TransactionStatusMessagePO = copy(details = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details.Empty)
    def withDetails(__v: net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details): TransactionStatusMessagePO = copy(details = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = status.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
        case 2 => details.failed.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PEnum(status.scalaValueDescriptor)
        case 2 => details.failed.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.type = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.TransactionStatusMessagePO])
}

object TransactionStatusMessagePO extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO = {
    var __status: net.imadz.infrastructure.proto.transactions.TransactionStatusPO = net.imadz.infrastructure.proto.transactions.TransactionStatusPO.UNKNOWN
    var __details: net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details.Empty
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 8 =>
          __status = net.imadz.infrastructure.proto.transactions.TransactionStatusPO.fromValue(_input__.readEnum())
        case 18 =>
          __details = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details.Failed(__details.failed.fold(_root_.scalapb.LiteParser.readMessage[net.imadz.infrastructure.proto.transactions.FailedStatusPO](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO(
        status = __status,
        details = __details,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO(
        status = net.imadz.infrastructure.proto.transactions.TransactionStatusPO.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(net.imadz.infrastructure.proto.transactions.TransactionStatusPO.UNKNOWN.scalaValueDescriptor).number),
        details = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[net.imadz.infrastructure.proto.transactions.FailedStatusPO]]).map(net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details.Failed(_))
            .getOrElse(net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details.Empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TransactionsProto.javaDescriptor.getMessageTypes().get(2)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TransactionsProto.scalaDescriptor.messages(2)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = net.imadz.infrastructure.proto.transactions.FailedStatusPO
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => net.imadz.infrastructure.proto.transactions.TransactionStatusPO
    }
  }
  lazy val defaultInstance = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO(
    status = net.imadz.infrastructure.proto.transactions.TransactionStatusPO.UNKNOWN,
    details = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details.Empty
  )
  sealed trait Details extends _root_.scalapb.GeneratedOneof {
    def isEmpty: _root_.scala.Boolean = false
    def isDefined: _root_.scala.Boolean = true
    def isFailed: _root_.scala.Boolean = false
    def failed: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.FailedStatusPO] = _root_.scala.None
  }
  object Details {
    @SerialVersionUID(0L)
    case object Empty extends net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details {
      type ValueType = _root_.scala.Nothing
      override def isEmpty: _root_.scala.Boolean = true
      override def isDefined: _root_.scala.Boolean = false
      override def number: _root_.scala.Int = 0
      override def value: _root_.scala.Nothing = throw new java.util.NoSuchElementException("Empty.value")
    }
  
    @SerialVersionUID(0L)
    final case class Failed(value: net.imadz.infrastructure.proto.transactions.FailedStatusPO) extends net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details {
      type ValueType = net.imadz.infrastructure.proto.transactions.FailedStatusPO
      override def isFailed: _root_.scala.Boolean = true
      override def failed: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.FailedStatusPO] = Some(value)
      override def number: _root_.scala.Int = 2
    }
  }
  implicit class TransactionStatusMessagePOLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO](_l) {
    def status: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionStatusPO] = field(_.status)((c_, f_) => c_.copy(status = f_))
    def failed: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.FailedStatusPO] = field(_.getFailed)((c_, f_) => c_.copy(details = net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details.Failed(f_)))
    def details: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details] = field(_.details)((c_, f_) => c_.copy(details = f_))
  }
  final val STATUS_FIELD_NUMBER = 1
  final val FAILED_FIELD_NUMBER = 2
  def of(
    status: net.imadz.infrastructure.proto.transactions.TransactionStatusPO,
    details: net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO.Details
  ): _root_.net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO = _root_.net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO(
    status,
    details
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.TransactionStatusMessagePO])
}


==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\TransactionStatusPO.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the TransactionStatus enum
  */
sealed abstract class TransactionStatusPO(val value: _root_.scala.Int) extends _root_.scalapb.GeneratedEnum {
  type EnumType = net.imadz.infrastructure.proto.transactions.TransactionStatusPO
  type RecognizedType = net.imadz.infrastructure.proto.transactions.TransactionStatusPO.Recognized
  def isUnknown: _root_.scala.Boolean = false
  def isNew: _root_.scala.Boolean = false
  def isInitiated: _root_.scala.Boolean = false
  def isPrepared: _root_.scala.Boolean = false
  def isCompleted: _root_.scala.Boolean = false
  def isFailed: _root_.scala.Boolean = false
  def companion: _root_.scalapb.GeneratedEnumCompanion[TransactionStatusPO] = net.imadz.infrastructure.proto.transactions.TransactionStatusPO
  final def asRecognized: _root_.scala.Option[net.imadz.infrastructure.proto.transactions.TransactionStatusPO.Recognized] = if (isUnrecognized) _root_.scala.None else _root_.scala.Some(this.asInstanceOf[net.imadz.infrastructure.proto.transactions.TransactionStatusPO.Recognized])
}

object TransactionStatusPO extends _root_.scalapb.GeneratedEnumCompanion[TransactionStatusPO] {
  sealed trait Recognized extends TransactionStatusPO
  implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[TransactionStatusPO] = this
  
  @SerialVersionUID(0L)
  case object UNKNOWN extends TransactionStatusPO(0) with TransactionStatusPO.Recognized {
    val index = 0
    val name = "UNKNOWN"
    override def isUnknown: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object NEW extends TransactionStatusPO(1) with TransactionStatusPO.Recognized {
    val index = 1
    val name = "NEW"
    override def isNew: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object INITIATED extends TransactionStatusPO(2) with TransactionStatusPO.Recognized {
    val index = 2
    val name = "INITIATED"
    override def isInitiated: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object PREPARED extends TransactionStatusPO(3) with TransactionStatusPO.Recognized {
    val index = 3
    val name = "PREPARED"
    override def isPrepared: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object COMPLETED extends TransactionStatusPO(4) with TransactionStatusPO.Recognized {
    val index = 4
    val name = "COMPLETED"
    override def isCompleted: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object FAILED extends TransactionStatusPO(5) with TransactionStatusPO.Recognized {
    val index = 5
    val name = "FAILED"
    override def isFailed: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  final case class Unrecognized(unrecognizedValue: _root_.scala.Int) extends TransactionStatusPO(unrecognizedValue) with _root_.scalapb.UnrecognizedEnum
  lazy val values: scala.collection.immutable.Seq[ValueType] = scala.collection.immutable.Seq(UNKNOWN, NEW, INITIATED, PREPARED, COMPLETED, FAILED)
  def fromValue(__value: _root_.scala.Int): TransactionStatusPO = __value match {
    case 0 => UNKNOWN
    case 1 => NEW
    case 2 => INITIATED
    case 3 => PREPARED
    case 4 => COMPLETED
    case 5 => FAILED
    case __other => Unrecognized(__other)
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = TransactionsProto.javaDescriptor.getEnumTypes().get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = TransactionsProto.scalaDescriptor.enums(0)
}

==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\TransactionsProto.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

object TransactionsProto extends _root_.scalapb.GeneratedFileObject {
  lazy val dependencies: Seq[_root_.scalapb.GeneratedFileObject] = Seq(
    net.imadz.infrastructure.proto.credits.CreditsProto
  )
  lazy val messagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] =
    Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]](
      net.imadz.infrastructure.proto.transactions.string,
      net.imadz.infrastructure.proto.transactions.FailedStatusPO,
      net.imadz.infrastructure.proto.transactions.TransactionStatusMessagePO,
      net.imadz.infrastructure.proto.transactions.TransactionStatePO,
      net.imadz.infrastructure.proto.transactions.TransactionEventPO,
      net.imadz.infrastructure.proto.transactions.TransactionInitiatedPO,
      net.imadz.infrastructure.proto.transactions.TransactionPreparedPO,
      net.imadz.infrastructure.proto.transactions.TransactionCompletedPO,
      net.imadz.infrastructure.proto.transactions.TransactionFailedPO
    )
  private lazy val ProtoBytes: _root_.scala.Array[Byte] =
      scalapb.Encoding.fromBase64(scala.collection.immutable.Seq(
  """ChJ0cmFuc2FjdGlvbnMucHJvdG8SHm5ldC5pbWFkei5pbmZyYXN0cnVjdHVyZS5wcm90bxoNY3JlZGl0cy5wcm90byIqCgZzd
  HJpbmcSIAoFdmFsdWUYASABKAlCCuI/BxIFdmFsdWVSBXZhbHVlIjUKDkZhaWxlZFN0YXR1c1BPEiMKBnJlYXNvbhgBIAEoCUIL4
  j8IEgZyZWFzb25SBnJlYXNvbiLYAQoaVHJhbnNhY3Rpb25TdGF0dXNNZXNzYWdlUE8SWAoGc3RhdHVzGAEgASgOMjMubmV0LmltY
  WR6LmluZnJhc3RydWN0dXJlLnByb3RvLlRyYW5zYWN0aW9uU3RhdHVzUE9CC+I/CBIGc3RhdHVzUgZzdGF0dXMSVQoGZmFpbGVkG
  AIgASgLMi4ubmV0LmltYWR6LmluZnJhc3RydWN0dXJlLnByb3RvLkZhaWxlZFN0YXR1c1BPQgviPwgSBmZhaWxlZEgAUgZmYWlsZ
  WRCCQoHZGV0YWlscyK4AgoSVHJhbnNhY3Rpb25TdGF0ZVBPEhcKAmlkGAEgASgJQgfiPwQSAmlkUgJpZBIvCgpmcm9tVXNlcklkG
  AIgASgJQg/iPwwSCmZyb21Vc2VySWRSCmZyb21Vc2VySWQSKQoIdG9Vc2VySWQYAyABKAlCDeI/ChIIdG9Vc2VySWRSCHRvVXNlc
  klkEkwKBmFtb3VudBgEIAEoCzInLm5ldC5pbWFkei5pbmZyYXN0cnVjdHVyZS5wcm90by5Nb25leVBPQgviPwgSBmFtb3VudFIGY
  W1vdW50El8KBnN0YXR1cxgFIAEoCzI6Lm5ldC5pbWFkei5pbmZyYXN0cnVjdHVyZS5wcm90by5UcmFuc2FjdGlvblN0YXR1c01lc
  3NhZ2VQT0IL4j8IEgZzdGF0dXNSBnN0YXR1cyKtAwoSVHJhbnNhY3Rpb25FdmVudFBPEmYKCWluaXRpYXRlZBgBIAEoCzI2Lm5ld
  C5pbWFkei5pbmZyYXN0cnVjdHVyZS5wcm90by5UcmFuc2FjdGlvbkluaXRpYXRlZFBPQg7iPwsSCWluaXRpYXRlZEgAUglpbml0a
  WF0ZWQSYgoIcHJlcGFyZWQYAiABKAsyNS5uZXQuaW1hZHouaW5mcmFzdHJ1Y3R1cmUucHJvdG8uVHJhbnNhY3Rpb25QcmVwYXJlZ
  FBPQg3iPwoSCHByZXBhcmVkSABSCHByZXBhcmVkEmYKCWNvbXBsZXRlZBgDIAEoCzI2Lm5ldC5pbWFkei5pbmZyYXN0cnVjdHVyZ
  S5wcm90by5UcmFuc2FjdGlvbkNvbXBsZXRlZFBPQg7iPwsSCWNvbXBsZXRlZEgAUgljb21wbGV0ZWQSWgoGZmFpbGVkGAQgASgLM
  jMubmV0LmltYWR6LmluZnJhc3RydWN0dXJlLnByb3RvLlRyYW5zYWN0aW9uRmFpbGVkUE9CC+I/CBIGZmFpbGVkSABSBmZhaWxlZ
  EIHCgVldmVudCLCAQoWVHJhbnNhY3Rpb25Jbml0aWF0ZWRQTxIvCgpmcm9tVXNlcklkGAEgASgJQg/iPwwSCmZyb21Vc2VySWRSC
  mZyb21Vc2VySWQSKQoIdG9Vc2VySWQYAiABKAlCDeI/ChIIdG9Vc2VySWRSCHRvVXNlcklkEkwKBmFtb3VudBgDIAEoCzInLm5ld
  C5pbWFkei5pbmZyYXN0cnVjdHVyZS5wcm90by5Nb25leVBPQgviPwgSBmFtb3VudFIGYW1vdW50IjAKFVRyYW5zYWN0aW9uUHJlc
  GFyZWRQTxIXCgJpZBgBIAEoCUIH4j8EEgJpZFICaWQiMQoWVHJhbnNhY3Rpb25Db21wbGV0ZWRQTxIXCgJpZBgBIAEoCUIH4j8EE
  gJpZFICaWQiUwoTVHJhbnNhY3Rpb25GYWlsZWRQTxIXCgJpZBgBIAEoCUIH4j8EEgJpZFICaWQSIwoGcmVhc29uGAIgASgJQgviP
  wgSBnJlYXNvblIGcmVhc29uKrcBChNUcmFuc2FjdGlvblN0YXR1c1BPEhkKB1VOS05PV04QABoM4j8JEgdVTktOT1dOEhEKA05FV
  xABGgjiPwUSA05FVxIdCglJTklUSUFURUQQAhoO4j8LEglJTklUSUFURUQSGwoIUFJFUEFSRUQQAxoN4j8KEghQUkVQQVJFRBIdC
  glDT01QTEVURUQQBBoO4j8LEglDT01QTEVURUQSFwoGRkFJTEVEEAUaC+I/CBIGRkFJTEVEYgZwcm90bzM="""
      ).mkString)
  lazy val scalaDescriptor: _root_.scalapb.descriptors.FileDescriptor = {
    val scalaProto = com.google.protobuf.descriptor.FileDescriptorProto.parseFrom(ProtoBytes)
    _root_.scalapb.descriptors.FileDescriptor.buildFrom(scalaProto, dependencies.map(_.scalaDescriptor))
  }
  lazy val javaDescriptor: com.google.protobuf.Descriptors.FileDescriptor = {
    val javaProto = com.google.protobuf.DescriptorProtos.FileDescriptorProto.parseFrom(ProtoBytes)
    com.google.protobuf.Descriptors.FileDescriptor.buildFrom(javaProto, _root_.scala.Array(
      net.imadz.infrastructure.proto.credits.CreditsProto.javaDescriptor
    ))
  }
  @deprecated("Use javaDescriptor instead. In a future version this will refer to scalaDescriptor.", "ScalaPB 0.5.47")
  def descriptor: com.google.protobuf.Descriptors.FileDescriptor = javaDescriptor
}

==================================================
文件路径: target\scala-2.13\src_managed\main\protobuf\net\imadz\infrastructure\proto\transactions\string.scala
==================================================

// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package net.imadz.infrastructure.proto.transactions

/** Define the Id type
  */
@SerialVersionUID(0L)
final case class string(
    value: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[string] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = value
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = value
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withValue(__v: _root_.scala.Predef.String): string = copy(value = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = value
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(value)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: net.imadz.infrastructure.proto.transactions.string.type = net.imadz.infrastructure.proto.transactions.string
    // @@protoc_insertion_point(GeneratedMessage[net.imadz.infrastructure.proto.string])
}

object string extends scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.string] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[net.imadz.infrastructure.proto.transactions.string] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): net.imadz.infrastructure.proto.transactions.string = {
    var __value: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __value = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    net.imadz.infrastructure.proto.transactions.string(
        value = __value,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[net.imadz.infrastructure.proto.transactions.string] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      net.imadz.infrastructure.proto.transactions.string(
        value = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TransactionsProto.javaDescriptor.getMessageTypes().get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TransactionsProto.scalaDescriptor.messages(0)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = net.imadz.infrastructure.proto.transactions.string(
    value = ""
  )
  implicit class stringLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, net.imadz.infrastructure.proto.transactions.string]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, net.imadz.infrastructure.proto.transactions.string](_l) {
    def value: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.value)((c_, f_) => c_.copy(value = f_))
  }
  final val VALUE_FIELD_NUMBER = 1
  def of(
    value: _root_.scala.Predef.String
  ): _root_.net.imadz.infrastructure.proto.transactions.string = _root_.net.imadz.infrastructure.proto.transactions.string(
    value
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[net.imadz.infrastructure.proto.string])
}


==================================================
文件路径: target\scala-2.13\twirl\main\views\html\index.template.scala
==================================================


package views.html

import _root_.play.twirl.api.TwirlFeatureImports._
import _root_.play.twirl.api.TwirlHelperImports._
import _root_.play.twirl.api.Html
import _root_.play.twirl.api.JavaScript
import _root_.play.twirl.api.Txt
import _root_.play.twirl.api.Xml
import models._
import controllers._
import play.api.i18n._
import views.html._
import play.api.templates.PlayMagic._
import play.api.mvc._
import play.api.data._

object index extends _root_.play.twirl.api.BaseScalaTemplate[play.twirl.api.HtmlFormat.Appendable,_root_.play.twirl.api.Format[play.twirl.api.HtmlFormat.Appendable]](play.twirl.api.HtmlFormat) with _root_.play.twirl.api.Template0[play.twirl.api.HtmlFormat.Appendable] {

  /**/
  def apply/*1.2*/():play.twirl.api.HtmlFormat.Appendable = {
    _display_ {
      {


Seq[Any](format.raw/*1.4*/("""

"""),_display_(/*3.2*/main("Welcome to Play")/*3.25*/ {_display_(Seq[Any](format.raw/*3.27*/("""
  """),format.raw/*4.3*/("""<h1>Welcome to Play!</h1>
""")))}),format.raw/*5.2*/("""
"""))
      }
    }
  }

  def render(): play.twirl.api.HtmlFormat.Appendable = apply()

  def f:(() => play.twirl.api.HtmlFormat.Appendable) = () => apply()

  def ref: this.type = this

}


              /*
                  -- GENERATED --
                  SOURCE: app/views/index.scala.html
                  HASH: 571f46e69b9fc543f88ebd186b26f7e5e7a0cd9c
                  MATRIX: 722->1|818->3|848->8|879->31|918->33|948->37|1005->65
                  LINES: 21->1|26->1|28->3|28->3|28->3|29->4|30->5
                  -- GENERATED --
              */
          

==================================================
文件路径: target\scala-2.13\twirl\main\views\html\main.template.scala
==================================================


package views.html

import _root_.play.twirl.api.TwirlFeatureImports._
import _root_.play.twirl.api.TwirlHelperImports._
import _root_.play.twirl.api.Html
import _root_.play.twirl.api.JavaScript
import _root_.play.twirl.api.Txt
import _root_.play.twirl.api.Xml
import models._
import controllers._
import play.api.i18n._
import views.html._
import play.api.templates.PlayMagic._
import play.api.mvc._
import play.api.data._

object main extends _root_.play.twirl.api.BaseScalaTemplate[play.twirl.api.HtmlFormat.Appendable,_root_.play.twirl.api.Format[play.twirl.api.HtmlFormat.Appendable]](play.twirl.api.HtmlFormat) with _root_.play.twirl.api.Template2[String,Html,play.twirl.api.HtmlFormat.Appendable] {

  /*
 * This template is called from the `index` template. This template
 * handles the rendering of the page header and body tags. It takes
 * two arguments, a `String` for the title of the page and an `Html`
 * object to insert into the body of the page.
 */
  def apply/*7.2*/(title: String)(content: Html):play.twirl.api.HtmlFormat.Appendable = {
    _display_ {
      {


Seq[Any](format.raw/*7.32*/("""

"""),format.raw/*9.1*/("""<!DOCTYPE html>
<html lang="en">
    <head>
        """),format.raw/*12.62*/("""
        """),format.raw/*13.9*/("""<title>"""),_display_(/*13.17*/title),format.raw/*13.22*/("""</title>
        <link rel="stylesheet" media="screen" href=""""),_display_(/*14.54*/routes/*14.60*/.Assets.versioned("stylesheets/main.css")),format.raw/*14.101*/("""">
        <link rel="shortcut icon" type="image/png" href=""""),_display_(/*15.59*/routes/*15.65*/.Assets.versioned("images/favicon.png")),format.raw/*15.104*/("""">

    </head>
    <body>
        """),format.raw/*20.32*/("""
        """),_display_(/*21.10*/content),format.raw/*21.17*/("""

      """),format.raw/*23.7*/("""<script src=""""),_display_(/*23.21*/routes/*23.27*/.Assets.versioned("javascripts/main.js")),format.raw/*23.67*/("""" type="text/javascript"></script>
    </body>
</html>
"""))
      }
    }
  }

  def render(title:String,content:Html): play.twirl.api.HtmlFormat.Appendable = apply(title)(content)

  def f:((String) => (Html) => play.twirl.api.HtmlFormat.Appendable) = (title) => (content) => apply(title)(content)

  def ref: this.type = this

}


              /*
                  -- GENERATED --
                  SOURCE: app/views/main.scala.html
                  HASH: 2d7bb605c571dab93f940a8a3370ee8ea17610b5
                  MATRIX: 992->266|1117->296|1147->300|1230->408|1267->418|1302->426|1328->431|1418->494|1433->500|1496->541|1585->603|1600->609|1661->648|1728->778|1766->789|1794->796|1831->806|1872->820|1887->826|1948->866
                  LINES: 26->7|31->7|33->9|36->12|37->13|37->13|37->13|38->14|38->14|38->14|39->15|39->15|39->15|43->20|44->21|44->21|46->23|46->23|46->23|46->23
                  -- GENERATED --
              */
          

==================================================
文件路径: test\net\imadz\infra\saga\SagaTransactionCoordinatorSpec.scala
==================================================

package net.imadz.infra.saga

import akka.actor.testkit.typed.scaladsl.{LogCapturing, ScalaTestWithActorTestKit}
import akka.actor.typed.ActorRef
import akka.actor.typed.scaladsl.Behaviors
import akka.persistence.testkit.scaladsl.EventSourcedBehaviorTestKit
import akka.persistence.typed.PersistenceId
import com.typesafe.config.ConfigFactory
import net.imadz.infra.saga.SagaParticipant.{NonRetryableFailure, SagaResult}
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.SagaTransactionCoordinator.TransactionResult
import net.imadz.infra.saga.StepExecutor.StepResult
import org.scalatest.BeforeAndAfterEach
import org.scalatest.wordspec.AnyWordSpecLike

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.DurationInt

class SagaTransactionCoordinatorSpec extends ScalaTestWithActorTestKit(
  ConfigFactory.parseString(
    """
      |akka {
      |  actor {
      |    serializers {
      |      proto = "akka.remote.serialization.ProtobufSerializer"
      |      saga-transaction-step = "net.imadz.infra.saga.SagaTransactionStepSerializerForTest"
      |    }
      |    serialization-bindings {
      |      "com.google.protobuf.Message" = proto
      |      "net.imadz.infra.saga.SagaTransactionStep" = saga-transaction-step
      |    }
      |    allow-java-serialization = on
      |    warn-about-java-serializer-usage = off
      |  }
      |}
      |# In-memory database configuration for unit testing
      |       database {
      |         url = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"
      |         driver = org.h2.Driver
      |         connectionPool = disabled
      |         keepAliveConnection = true
      |       }
      |akka.test.single-expect-default = 100s
      |akka.actor.testkit.typed.single-expect-default = 100s
      |""".stripMargin
  ).withFallback(EventSourcedBehaviorTestKit.config)
) with AnyWordSpecLike with BeforeAndAfterEach with LogCapturing {

  private def createEventSourcedTestKit(stepExecutorCreator: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command]) = {
    EventSourcedBehaviorTestKit[
      SagaTransactionCoordinator.Command,
      SagaTransactionCoordinator.Event,
      SagaTransactionCoordinator.State
    ](
      system,
      SagaTransactionCoordinator(
        PersistenceId.ofUniqueId("test-saga-coordinator"),
        stepExecutorCreator
      )
    )
  }

  private def createSuccessfulStepExecutor[E, R](): ActorRef[StepExecutor.Command] = {
    spawn(Behaviors.receiveMessage[StepExecutor.Command] {
      case StepExecutor.Start(transactionId, step, replyTo: Option[ActorRef[StepResult[E, R]]]) =>
        replyTo.foreach(_ ! StepExecutor.StepCompleted[E, R](step.stepId, SagaResult.empty[R](), StepExecutor.State()))
        Behaviors.same
    })
  }

  private def createFailingStepExecutor(): ActorRef[StepExecutor.Command] = {
    spawn(Behaviors.receiveMessage[StepExecutor.Command] {
      case StepExecutor.Start(transactionId, step, replyTo) =>
        replyTo.foreach(_ ! StepExecutor.StepFailed(transactionId, Left(NonRetryableFailure("Test failure")), StepExecutor.State()))
        Behaviors.same
    })
  }

  "SagaTransactionCoordinator" should {
    "successfully complete a transaction" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, _) => createSuccessfulStepExecutor())
      val transactionId = "test-transaction"
      val steps = List(
        SagaTransactionStep("step1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("step2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("step3", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("step4", CommitPhase, SuccessfulParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = true,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CommitPhase,
          status = SagaTransactionCoordinator.Completed,
        ),
        stepTraces = List.fill(4)(StepExecutor.State())
      )
    }

    "handle failure during PreparePhase and initiate compensation" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        if (step.phase == PreparePhase) createFailingStepExecutor()
        else createSuccessfulStepExecutor()
      )
      val transactionId = "failed-transaction"
      val steps = List(
        SagaTransactionStep("step1", PreparePhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("step2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = false,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CompensatePhase,
          status = SagaTransactionCoordinator.Failed,
        ),
        stepTraces = List(StepExecutor.State(), StepExecutor.State())
      )
    }

    "handle non-retryable failure during CommitPhase" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        if (step.phase == CommitPhase) createFailingStepExecutor()
        else createSuccessfulStepExecutor()
      )
      val transactionId = "commit-failed-transaction"
      val steps = List(
        SagaTransactionStep("step1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("step2", CommitPhase, AlwaysFailingParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = false,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CompensatePhase,
          status = SagaTransactionCoordinator.Failed,
        ),
        stepTraces = List(StepExecutor.State(), StepExecutor.State())
      )
    }
    "handle failure during CommitPhase and successfully compensate" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        if (step.stepId == "commit1") createFailingStepExecutor()
        else createSuccessfulStepExecutor()
      )
      val transactionId = "commit-fail-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = false,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CompensatePhase,
          status = SagaTransactionCoordinator.Failed,
        ),
        stepTraces = List.fill(6)(StepExecutor.State())
      )
    }

    "handle partial failure during CompensatePhase" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        if (step.stepId == "commit2" || step.stepId == "compensate1") createFailingStepExecutor()
        else createSuccessfulStepExecutor()
      )
      val transactionId = "compensate-partial-fail-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val prob = createTestProbe[TransactionResult]()
      val result = eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(prob.ref)))

      result.event shouldBe SagaTransactionCoordinator.TransactionStarted(transactionId, steps)
      result.state.status shouldBe SagaTransactionCoordinator.InProgress

      val expected = prob.receiveMessage(10.seconds)

      expected shouldBe TransactionResult(
        successful = false,
        SagaTransactionCoordinator.State(
          transactionId = Some(transactionId),
          steps = steps,
          currentPhase = CompensatePhase,
          status = SagaTransactionCoordinator.Failed,
        ),
        stepTraces = List.fill(6)(StepExecutor.State())
      )
    }

  }
}

==================================================
文件路径: test\net\imadz\infra\saga\SagaTransactionStepSerializerForTest.scala
==================================================

package net.imadz.infra.saga

import akka.serialization.Serializer
import net.imadz.infra.saga.SagaPhase._

import scala.concurrent.duration.DurationLong

class SagaTransactionStepSerializerForTest extends Serializer {
  override def identifier: Int = 1234 // Unique identifier for this serializer

  override def toBinary(o: AnyRef): Array[Byte] = o match {
    case step: SagaTransactionStep[_, _] =>
      proto.saga_v2.SagaTransactionStepPO(
        stepId = step.stepId,
        phase = step.phase match {
          case PreparePhase => proto.saga_v2.TransactionPhasePO.PREPARE_PHASE
          case CommitPhase => proto.saga_v2.TransactionPhasePO.COMMIT_PHASE
          case CompensatePhase => proto.saga_v2.TransactionPhasePO.COMPENSATE_PHASE
        },
        maxRetries = step.maxRetries,
        timeoutDurationMillis = step.timeoutDuration.toMillis,
        retryWhenRecoveredOngoing = step.retryWhenRecoveredOngoing,
        participant = None,
        participantType = step.participant.getClass.getName
      ).toByteArray
    case _ => throw new IllegalArgumentException(s"Cannot serialize object of type ${o.getClass}")
  }

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef = {
    val protoStep = proto.saga_v2.SagaTransactionStepPO.parseFrom(bytes)
    SagaTransactionStep(
      stepId = protoStep.stepId,
      phase = protoStep.phase match {
        case proto.saga_v2.TransactionPhasePO.PREPARE_PHASE => PreparePhase
        case proto.saga_v2.TransactionPhasePO.COMMIT_PHASE => CommitPhase
        case proto.saga_v2.TransactionPhasePO.COMPENSATE_PHASE => CompensatePhase
        case _ => throw new IllegalArgumentException(s"Unknown phase: ${protoStep.phase}")
      },
      participant = createParticipant(protoStep.participantType),
      maxRetries = protoStep.maxRetries,
      timeoutDuration = protoStep.timeoutDurationMillis.millis,
      retryWhenRecoveredOngoing = protoStep.retryWhenRecoveredOngoing
    )
  }

  private def createParticipant(participantType: String): SagaParticipant[_, _] = {
    // This method should create and return the appropriate SagaParticipant based on the type
    // You'll need to implement this based on your specific participants
    participantType match {
      case "net.imadz.infra.saga.SuccessfulParticipant" => SuccessfulParticipant
      case "net.imadz.infra.saga.RetryingParticipant" => RetryingParticipant() // Default value, adjust as needed
      case "net.imadz.infra.saga.TimeoutParticipant" => TimeoutParticipant
      case "net.imadz.infra.saga.AlwaysFailingParticipant" => AlwaysFailingParticipant
      case "net.imadz.infra.saga.NonRetryableFailingParticipant" => NonRetryableFailingParticipant

      case name =>
        println(name)
        throw new IllegalArgumentException(s"Unknown participant type: $participantType")
    }
  }

  override def includeManifest: Boolean = false
}

// Implement similar serializers for other classes (State, RetryableOrNotException, etc.)

==================================================
文件路径: test\net\imadz\infra\saga\StepExecutorSagaCoordinatorIntegrationSpec.scala
==================================================

package net.imadz.infra.saga

import akka.actor.testkit.typed.scaladsl.{LogCapturing, ScalaTestWithActorTestKit}
import akka.actor.typed.ActorRef
import akka.persistence.testkit.scaladsl.EventSourcedBehaviorTestKit
import akka.persistence.typed.PersistenceId
import com.typesafe.config.ConfigFactory
import net.imadz.infra.saga.SagaParticipant.RetryableFailure
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.SagaTransactionCoordinator.TransactionResult
import net.imadz.infra.saga.StepExecutor.CircuitBreakerSettings
import org.scalatest.BeforeAndAfterEach
import org.scalatest.wordspec.AnyWordSpecLike

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._

class StepExecutorSagaCoordinatorIntegrationSpec extends ScalaTestWithActorTestKit(
  ConfigFactory.parseString(
    """
      |akka {
      |  actor {
      |    serializers {
      |      proto = "akka.remote.serialization.ProtobufSerializer"
      |      saga-transaction-step = "net.imadz.infra.saga.SagaTransactionStepSerializerForTest"
      |    }
      |    serialization-bindings {
      |      "com.google.protobuf.Message" = proto
      |      "net.imadz.infra.saga.SagaTransactionStep" = saga-transaction-step
      |    }
      |    allow-java-serialization = on
      |    warn-about-java-serializer-usage = off
      |  }
      |}
      |# In-memory database configuration for unit testing
      |database {
      |  url = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"
      |  driver = org.h2.Driver
      |  connectionPool = disabled
      |  keepAliveConnection = true
      |}
      |akka.test.single-expect-default = 100s
      |akka.actor.testkit.typed.single-expect-default = 100s
      |""".stripMargin
  ).withFallback(EventSourcedBehaviorTestKit.config)
) with AnyWordSpecLike with BeforeAndAfterEach with LogCapturing {

  private def createEventSourcedTestKit(stepExecutorCreator: (String, SagaTransactionStep[_, _]) => ActorRef[StepExecutor.Command]) = {
    EventSourcedBehaviorTestKit[
      SagaTransactionCoordinator.Command,
      SagaTransactionCoordinator.Event,
      SagaTransactionCoordinator.State
    ](
      system,
      SagaTransactionCoordinator(
        PersistenceId.ofUniqueId("test-saga-coordinator"),
        stepExecutorCreator
      )
    )
  }

  "StepExecutor and SagaTransactionCoordinator Integration" should {

    "successfully complete a transaction with multiple steps across different phases" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, _) => createStepExecutor())
      val transactionId = "multi-phase-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe true
      result.state.status shouldBe SagaTransactionCoordinator.Completed
      result.state.currentPhase shouldBe CommitPhase
      result.stepTraces should have length 4
    }

    "handle failure in Prepare phase and initiate compensation" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "prepare-fail-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.state.currentPhase shouldBe CompensatePhase
      result.stepTraces should have length 4 // prepare1, prepare2 (failed), compensate1, compensate2
    }

    "handle failure in Commit phase and compensate all steps" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "commit-fail-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.state.currentPhase shouldBe CompensatePhase
      result.stepTraces should have length 6 // prepare1, prepare2, commit1 (failed), compensate1, compensate2
    }

    "retry a step with temporary failure" in {
      val retryingParticipant = new RetryingParticipant()
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "retry-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, retryingParticipant, 5),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      println(result)

      result.successful shouldBe true
      result.state.status shouldBe SagaTransactionCoordinator.Completed
      result.orderedSteps.head.retries should be > 0
    }

    // Add more test cases here...

    "handle circuit breaker behavior" in {
      val circuitBreakerParticipant = new CircuitBreakerParticipant()
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "circuit-breaker-transaction"
      val steps = List(
        SagaTransactionStep("circuit-breaker-step", PreparePhase, circuitBreakerParticipant, 10, 1.seconds))
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(15.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.orderedSteps.head.retries should be >= 3
    }


    "handle timeout in a step" in {
      val timeoutParticipant = new TimeoutParticipant()
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) =>
        createStepExecutor()
      )
      val transactionId = "timeout-transaction"
      val steps = List(
        SagaTransactionStep("timeout-step", PreparePhase, timeoutParticipant, 2, timeoutDuration = 500.millis),
        SagaTransactionStep("compensate-step", CompensatePhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.state.currentPhase shouldBe CompensatePhase
      result.orderedSteps.head.lastError.get shouldBe a[RetryableFailure]
    }

    "handle partial compensation" in {
      val eventSourcedTestKit = createEventSourcedTestKit((_, step) => createStepExecutor())
      val transactionId = "partial-compensate-transaction"
      val steps = List(
        SagaTransactionStep("prepare1", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("prepare2", PreparePhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit1", CommitPhase, SuccessfulParticipant, 2),
        SagaTransactionStep("commit2", CommitPhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("compensate1", CompensatePhase, AlwaysFailingParticipant, 2),
        SagaTransactionStep("compensate2", CompensatePhase, SuccessfulParticipant, 2)
      )
      val probe = createTestProbe[TransactionResult]()

      eventSourcedTestKit.runCommand(SagaTransactionCoordinator.StartTransaction(transactionId, steps, Some(probe.ref)))

      val result = probe.receiveMessage(10.seconds)

      result.successful shouldBe false
      result.state.status shouldBe SagaTransactionCoordinator.Failed
      result.state.currentPhase shouldBe CompensatePhase
      result.stepTraces should have length 6 // prepare1, prepare2, commit1, commit2 (failed), compensate1 (failed), compensate2
      result.stepTraces.count(_.status == StepExecutor.Failed) shouldBe 2
    }
  }

  private def createStepExecutor(circuitBreakerSettings: CircuitBreakerSettings = CircuitBreakerSettings(5, 30.seconds, 30.seconds)) = {
    spawn(StepExecutor[Any, Any](
      PersistenceId.ofUniqueId(s"step-executor-${java.util.UUID.randomUUID()}"),
      defaultMaxRetries = 5,
      initialRetryDelay = 100.millis,
      circuitBreakerSettings = circuitBreakerSettings
    ))
  }


}


==================================================
文件路径: test\net\imadz\infra\saga\StepExecutorSpec.scala
==================================================

package net.imadz.infra.saga

import akka.actor.testkit.typed.scaladsl.{LogCapturing, ScalaTestWithActorTestKit}
import akka.persistence.testkit.scaladsl.EventSourcedBehaviorTestKit
import akka.persistence.typed.PersistenceId
import com.typesafe.config.ConfigFactory
import net.imadz.common.CborSerializable
import net.imadz.infra.saga.SagaParticipant._
import net.imadz.infra.saga.SagaPhase._
import net.imadz.infra.saga.StepExecutor._
import org.scalatest.BeforeAndAfterEach
import org.scalatest.wordspec.AnyWordSpecLike
import org.slf4j.LoggerFactory

import scala.concurrent.Future
import scala.concurrent.duration._

class StepExecutorSpec extends ScalaTestWithActorTestKit(
  ConfigFactory.parseString(
    """
akka {
       actor {
         serializers {

            proto = "akka.remote.serialization.ProtobufSerializer"
            saga-transaction-step = "net.imadz.infra.saga.SagaTransactionStepSerializerForTest"

         }
         serialization-bindings {
           "com.google.protobuf.Message" = proto
           "net.imadz.infra.saga.SagaTransactionStep" = saga-transaction-step

         }
         allow-java-serialization = on
         warn-about-java-serializer-usage = off
       }

    }
    # In-memory database configuration for unit testing
       database {
         url = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"
         driver = org.h2.Driver
         connectionPool = disabled
         keepAliveConnection = true
       }
""".stripMargin
  ).withFallback(EventSourcedBehaviorTestKit.config)
)
  with AnyWordSpecLike
  with BeforeAndAfterEach
  with LogCapturing {

  val logger = LoggerFactory.getLogger(getClass)

  private def createTestKit[E, R](id: String, defaultMaxRetries: Int = 5, initialRetryDelay: FiniteDuration = 2.seconds, circuitBreakerSettings: CircuitBreakerSettings = CircuitBreakerSettings(5, 30.seconds, 30.seconds)): EventSourcedBehaviorTestKit[Command, Event, State[E, R]] =
    EventSourcedBehaviorTestKit[
      StepExecutor.Command,
      StepExecutor.Event,
      StepExecutor.State[E, R]](
      system,
      StepExecutor(persistenceId = PersistenceId.ofUniqueId(id),
        defaultMaxRetries = defaultMaxRetries,
        initialRetryDelay = initialRetryDelay,
        circuitBreakerSettings = circuitBreakerSettings
      )
    )

  val participant = SuccessfulParticipant
  val eventSourcedTestKit: EventSourcedBehaviorTestKit[Command, Event, State[String, String]] = createTestKit("test-1")

  override protected def beforeEach(): Unit = {
    super.beforeEach()
    eventSourcedTestKit.clear()
  }


  "StepExecutor" should {

    "successfully execute Start command" in {
      val probe = createTestProbe[StepResult[String, String]]()

      val reserveFromAccount = SagaTransactionStep[String, String](
        "from-account-reservation", PreparePhase, SuccessfulParticipant
      )
      val result = eventSourcedTestKit.runCommand(Start[String, String]("trx1", reserveFromAccount, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx1", reserveFromAccount, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx1")
      result.state.step shouldBe Some(reserveFromAccount)
      result.state.status shouldBe Ongoing

      probe.expectMessage(3.seconds, StepCompleted[String, String](
        transactionId = "trx1",
        result = SagaResult("Prepared"),
        state = StepExecutor.State(step = Some(reserveFromAccount), transactionId = Some("trx1"), status = Succeed,
          replyTo = Some(probe.ref.path.toSerializationFormat))
      ))

    }

    "successfully execute Start command for PreparePhase" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val eventSourcedTestKit = createTestKit("test-prepare")

      val prepareStep = SagaTransactionStep[String, String](
        "prepare-step", PreparePhase, SuccessfulParticipant
      )
      val result = eventSourcedTestKit.runCommand(Start("trx1", prepareStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx1", prepareStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx1")
      result.state.step shouldBe Some(prepareStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(5.seconds, StepCompleted[String, String](
        transactionId = "trx1",
        result = SagaResult("Prepared"),
        state = StepExecutor.State(step = Some(prepareStep), transactionId = Some("trx1"), status = Succeed
          , replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "successfully execute Start command for CommitPhase" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val eventSourcedTestKit = createTestKit("test-commit")

      val commitStep = SagaTransactionStep[String, String](
        "commit-step", CommitPhase, SuccessfulParticipant
      )
      val result = eventSourcedTestKit.runCommand(Start("trx2", commitStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx2", commitStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx2")
      result.state.step shouldBe Some(commitStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(5.seconds, StepCompleted[String, String](
        transactionId = "trx2",
        result = SagaResult("Committed"),
        state = StepExecutor.State(step = Some(commitStep), transactionId = Some("trx2"), status = Succeed
          , replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "successfully execute Start command for CompensatePhase" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val eventSourcedTestKit = createTestKit("test-compensate")

      val compensateStep = SagaTransactionStep[String, String](
        "compensate-step", CompensatePhase, SuccessfulParticipant
      )
      val result = eventSourcedTestKit.runCommand(Start("trx3", compensateStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx3", compensateStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx3")
      result.state.step shouldBe Some(compensateStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(5.seconds, StepCompleted[String, String](
        transactionId = "trx3",
        result = SagaResult("Compensated"),
        state = StepExecutor.State(step = Some(compensateStep), transactionId = Some("trx3"), status = Succeed, replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "retry on retryable failure" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val retryingParticipant = RetryingParticipant()
      val eventSourcedTestKit = createTestKit("test-retry")

      val retryStep = SagaTransactionStep[String, String](
        "retry-step", PreparePhase, retryingParticipant, maxRetries = 5
      )
      val result = eventSourcedTestKit.runCommand(Start("trx4", retryStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx4", retryStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx4")
      result.state.step shouldBe Some(retryStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(10.seconds, StepCompleted[String, String](
        transactionId = "trx4",
        result = SagaResult("Success after retry"),
        state = StepExecutor.State(step = Some(retryStep), transactionId = Some("trx4"), status = Succeed,
          retries = 2,
          lastError = Some(RetryableFailure("Retry needed")),
          replyTo = Some(probe.ref.path.toSerializationFormat)
        )
      ))
    }

    "fail after max retries" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val alwaysFailingParticipant = AlwaysFailingParticipant
      val eventSourcedTestKit = createTestKit("test-max-retries")

      val failingStep = SagaTransactionStep[String, String](
        "failing-step", PreparePhase, alwaysFailingParticipant, maxRetries = 2
      )
      val result = eventSourcedTestKit.runCommand(Start("trx5", failingStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx5", failingStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx5")
      result.state.step shouldBe Some(failingStep)
      result.state.status shouldBe Ongoing

      probe.expectMessageType[StepFailed[String, String]](10.seconds)
    }

    "fail immediately on non-retryable failure" in {
      val probe = createTestProbe[StepResult[RetryableOrNotException, String]]()
      val nonRetryableFailingParticipant = NonRetryableFailingParticipant
      val eventSourcedTestKit = createTestKit("test-non-retryable")

      val nonRetryableStep = SagaTransactionStep[RetryableOrNotException, String](
        "non-retryable-step", PreparePhase, nonRetryableFailingParticipant, maxRetries = 5
      )
      val result = eventSourcedTestKit.runCommand(Start("trx6", nonRetryableStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx6", nonRetryableStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx6")
      result.state.step shouldBe Some(nonRetryableStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(5.seconds, StepFailed[RetryableOrNotException, String](
        transactionId = "trx6",
        error = NonRetryableFailure("Critical error"),
        state = StepExecutor.State(
          step = Some(nonRetryableStep),
          transactionId = Some("trx6"),
          status = Failed,
          lastError = Some(NonRetryableFailure("Critical error")),
          replyTo = Some(probe.ref.path.toSerializationFormat)
        )
      ))
    }

    "timeout on long-running operation" in {
      val probe = createTestProbe[StepResult[RetryableOrNotException, String]]()
      val timeoutParticipant = TimeoutParticipant
      val eventSourcedTestKit = createTestKit("test-timeout")

      val timeoutStep = SagaTransactionStep[RetryableOrNotException, String](
        "timeout-step", PreparePhase, timeoutParticipant, timeoutDuration = 1.seconds, maxRetries = 2
      )
      val result = eventSourcedTestKit.runCommand(Start("trx7", timeoutStep, Some(probe.ref)))

      result.event shouldBe ExecutionStarted("trx7", timeoutStep, probe.ref.path.toSerializationFormat)
      result.state.transactionId shouldBe Some("trx7")
      result.state.step shouldBe Some(timeoutStep)
      result.state.status shouldBe Ongoing

      probe.expectMessage(1000.seconds, StepFailed[RetryableOrNotException, String](
        transactionId = "trx7",
        error = RetryableFailure("timed out"),
        state = StepExecutor.State(step = Some(timeoutStep), transactionId = Some("trx7"), status = Failed,
          lastError = Some(RetryableFailure("timed out")),
          replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "recover execution and retry when in Ongoing state" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val retryingParticipant = RetryingParticipant()
      val eventSourcedTestKit = createTestKit("test-recover")

      val recoverStep = SagaTransactionStep[String, String](
        "recover-step", PreparePhase, retryingParticipant, maxRetries = 5, retryWhenRecoveredOngoing = true
      )

      // Simulate a crash after starting execution
      eventSourcedTestKit.runCommand(Start("trx-recover", recoverStep, Some(probe.ref)))
      try {
        Thread.sleep(500L)
      } catch {
        case ignored: Throwable => ()
      }
      eventSourcedTestKit.restart()
      logger.info("restarting executor")

      // The actor should automatically retry the operation
      probe.expectMessage(10.seconds, StepCompleted[String, String](
        transactionId = "trx-recover",
        result = SagaResult("Success after retry"),
        state = StepExecutor.State(step = Some(recoverStep),
          transactionId = Some("trx-recover"),
          status = Succeed,
          retries = 2,
          lastError = Some(RetryableFailure("Retry needed")),
          replyTo = Some(probe.ref.path.toSerializationFormat))
      ))
    }

    "persist events and recover state" in {
      val probe = createTestProbe[StepResult[String, String]]()
      val participant = SuccessfulParticipant
      val eventSourcedTestKit = createTestKit("test-persist")

      val step = SagaTransactionStep[String, String](
        "persist-step", PreparePhase, participant
      )

      eventSourcedTestKit.runCommand(Start("trx-persist", step, Some(probe.ref)))

      // Verify persisted events
      val persistedEvents = eventSourcedTestKit.persistenceTestKit.persistedInStorage("test-persist")
      persistedEvents should contain(ExecutionStarted("trx-persist", step, probe.ref.path.toSerializationFormat))
      persistedEvents should contain(OperationSucceeded(SagaResult("Prepared")))

      // Simulate restart and verify recovered state
      eventSourcedTestKit.restart()
      val recoveredState = eventSourcedTestKit.getState()
      recoveredState.status shouldBe Succeed
      recoveredState.transactionId shouldBe Some("trx-persist")
    }
  }
}

case object SuccessfulParticipant extends SagaParticipant[String, String] with CborSerializable {
  override def doPrepare(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Prepared")))

  override def doCommit(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => NonRetryableFailure("never retry")
  }
}

case class RetryingParticipant() extends SagaParticipant[String, String] with CborSerializable {
  private var attempts = 0
  private val succeedAfter = 3

  override def doPrepare(transactionId: String) = {
    attempts += 1
    try {
      Thread.sleep(500L)
    } catch {
      case ignored: Throwable => ()
    }
    logger.warn(s"RetryingParticipant is doing prepare $attempts times")
    if (attempts < succeedAfter) Future.failed(RetryableFailure("Retry needed"))
    else Future.successful(Right[String, SagaResult[String]](SagaResult("Success after retry")))
  }

  override def doCommit(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => NonRetryableFailure("never retry")
  }
}


case object TimeoutParticipant extends SagaParticipant[RetryableOrNotException, String] {
  override def doPrepare(transactionId: String) = Future.never // Simulating a long-running operation

  override def doCommit(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => NonRetryableFailure("never retry")
  }
}

case object AlwaysFailingParticipant extends SagaParticipant[String, String] {
  override def doPrepare(transactionId: String) = {
    logger.warn(s"AlwaysFailingParticipant is failing after 5 seconds")
    try {
      Thread.sleep(1000L)
    } catch {
      case ignored: Throwable => ()
    }
    Future.failed(RetryableFailure("Always fails"))
  }

  override def doCommit(transactionId: String) =     Future.failed(RetryableFailure("Always fails"))


  override def doCompensate(transactionId: String) =     Future.failed(RetryableFailure("Always fails"))


  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => NonRetryableFailure("never retry")
  }
}

case object NonRetryableFailingParticipant extends SagaParticipant[RetryableOrNotException, String] {
  override def doPrepare(transactionId: String) = Future.failed(new RuntimeException())

  override def doCommit(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Compensated")))


  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case _ => NonRetryableFailure("Critical error")
  }
}

case class CircuitBreakerParticipant() extends SagaParticipant[RetryableOrNotException, String] {
  private var attempts = 0

  override def doPrepare(transactionId: String) = {
    attempts += 1
    Future.failed(RetryableFailure(s"Failure attempt $attempts"))
  }

  override def doCommit(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[RetryableOrNotException, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => RetryableFailure("Retry needed")
  }
}

case class TimeoutParticipant() extends SagaParticipant[String, String] {
  override def doPrepare(transactionId: String) = {
    Thread.sleep(1000) // Simulate long-running operation
    Future.successful(Right[String, SagaResult[String]](SagaResult("Prepared")))
  }

  override def doCommit(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Committed")))

  override def doCompensate(transactionId: String) = Future.successful(Right[String, SagaResult[String]](SagaResult("Compensated")))

  override protected def customClassification: PartialFunction[Throwable, RetryableOrNotException] = {
    case it@RetryableFailure("Retry needed") => it
    case _ => RetryableFailure("Retry needed")
  }
}
